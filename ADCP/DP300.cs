using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;//写入文件
using System.IO.Ports;//串口类命名空间
using System.Runtime.InteropServices; //创建联合的空间
using System.Collections;//动态数组
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading;
using System.Drawing.Drawing2D;
using Coordinate_transform;
//using Aladdin.HASP;
using Position_Transform_namespace;
using Calcflow;
using System.Globalization;
using System.Text.RegularExpressions;
using JDL.UILib;   //绘制tip控件
using System.ComponentModel.Design;

#pragma warning disable IDE0017
#pragma warning disable IDE1006
#pragma warning disable IDE0059

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structure of DP300.cs  Modified 2011-8-24
// namespace ADCP
// {
//     public partial class DP300_Windows : Form
//     {
// include:
//                      public DP300_Windows(){}
//                      private void GPS_sp_DataReceived(object sender, SerialDataReceivedEventArgs e){}
//                      private void GPS_GGAdecode(string data1){}
//                      private void GPS_VTGdecode(string data1){}
//                      private void GPS_HDTdecode(string data1{}
//                      private void GPS_ROTdecode(string data1){}
//                      private void VXVY_decode(string data1){}
//                      private void getInfoFromNMEAData(string data){}
//                      private void MainPanel_Paint(object sender, PaintEventArgs e){}
//                      private void VerticalPanel_Paint(object sender, PaintEventArgs e){}
//                      private void ComputeCombinedWaterVilocity(int currentXposition{}
//                      private void horizontalPanel_Paint(object sender, PaintEventArgs e){}
//                      private void HPR_DisplayerPanel_Paint(object sender, PaintEventArgs e){}
//                      private void InfoPanel_Paint(object sender, PaintEventArgs e){}
//                      public class ArrayClass {}
//                      private struct TestUnion{}
//                      private byte ByteArrayToByte(byte[] packet){}
//                      private int ByteArrayToInt(byte[] packet){}
//                      private string ByteArrayToString(byte[] packet, int len{}
//                      private float ByteArrayToFloat(byte[] packet{}
//                      void DecodeEnsemble(byte[] packet, ArrayClass m, int PacketSize){}
//                      private class EnsemblesInfo{}
//                      private void sp_DataReceived(object sender, SerialDataReceivedEventArgs e){}
//                      private float getAverageB_depth(ArrayClass a){}
//                      private void PickAndDecodeEnsemble(){}
//                      private void ByteArrayWriteToBinFile(byte[] rawBytesPacket, int fileNumber){}
//                      private byte[] BinFileWriteToByteArray(int BinfileNumber, string path){}
//                      private void WriteToDataPage(ArrayClass arr){}
//                      private void SaveAsBinaryFormat(Object obj, int fileNum){}
//                      private EnsemblesInfo LoadFromBinaryFile(string path){}
//                      private int GetVelocityBins(ArrayClass Arr, int flag){}
//                      private int GetVelocityBeams(ArrayClass Arr, int flag){}
//                      private Velocity getHPR_Vel_B(ArrayClass Arr, Velocity v){}
//                      private Velocity getHPR_Vel_W(ArrayClass Arr, Velocity v){}
//                      private Velocity getPR_Vel_W(ArrayClass Arr, Velocity v){}
//                      private Velocity getPR_Vel_B(ArrayClass Arr, Velocity v){}
//                      private struct Velocity{}
//                      private void GetBottomTrackVelocity(ArrayClass Arr, double theta){}
//                      private void GetWaterVelocityToBottom(ArrayClass Arr, double theta){}
//                      private void GetVelocityToColor(ArrayClass Arr){}
//                      private Color GetNewRGB(Color c, int colorStyle, float ColorMultiple){}
//                      private Color NumToColor(float Num, int type, bool DirectionFlag){}
//                      private void WaterSpeedTransToColor(Velocity[] WaterVel{}
//                      private void WaterVelocityTransToColor(Velocity[] WaterVel){}
//                      private bool BytesEquals(byte[] b1, byte[] b2){}
//                      public static byte[] CRC16Chksum(byte[] DataPacket){}
//                      private void ArrayClassWriteToFile(ArrayClass m){}
//                      private void WriteAllSettingsToFiles(){}
//                      private void writeAllSettingsToCfg(){}
//                      private void WriteProjectInfoToCfg(){}
//                      private void buttonProjectSet_Click(object sender, EventArgs e){}
//                      private void writeCommInfoToCfg(){}
//                      private void connectComm(){}
//                      private void closeComm(){}
//                      private void buttonCommOK_Click(object sender, EventArgs e){}
//                      private bool IsNumber(String str){}
//                      private void BtnSendCommand_Click(object sender, EventArgs e){}
//                      private void MainPanel_MouseDoubleClick(object sender, MouseEventArgs e){}
//                      private void TrackDisplayerPanel_MouseDoubleClick(object sender, MouseEventArgs e){}
//                      private void BlackWhite_CheckedChanged(object sender, EventArgs e){}
//                      private void SixColor_CheckedChanged(object sender, EventArgs e){}
//                      private void RedBlueGreen_CheckedChanged(object sender, EventArgs e){}
//                      private void YelloBlackCyan_CheckedChanged(object sender, EventArgs e){}
//                      private void MainPanel_MouseMove(object sender, MouseEventArgs e){}
//                      private void ProcessBar_Paint(object sender, PaintEventArgs e){}
//                      private void ProcessBar_MouseEnter(object sender, EventArgs e){}
//                      private void ProcessBar_MouseLeave(object sender, EventArgs e){}
//                      private void ProcessBar_MouseDown(object sender, MouseEventArgs e){}
//                      private void ProcessBar_MouseMove(object sender, MouseEventArgs e){}
//                      private string NumToTime(float mt){}
//                      private void ProcessBar_MouseUp(object sender, MouseEventArgs e){}
//                      public void PalyBackBtn_Click(object sender, EventArgs e){}
//                      private void PlayBackCenter(object sender, System.Timers.ElapsedEventArgs e){}
//                      private void RefreshPanels(){}
//                      private void decodeBinFile(ArrayList a){}
//                      private void GetOtherMembers(){}
//                      private void ClearEnsemblesInfoToStore(){}
//                      private void InitialAllParam(){}
//                      public void RealDisPlay_Click(object sender, EventArgs e){}
//                      protected override void OnFormClosing(FormClosingEventArgs e){}
//                      private void GPScheckbox_CheckedChanged(object sender, EventArgs e){}
//                      private void initialGPSData(){}
//                      private void sendCfgCommand(){}
//                      private void writeCommandToCfg(){}
//                      private void button_CfgOK_Click(object sender, EventArgs e){}
//                      private void displayprocessbar(int time, ProgressBar pb){}
//                      private bool checkCfgText(){}
//                      private void readCfg(string pathStr){}
//                      private void button_CfgLoad_Click(object sender, EventArgs e){}
//                      private void buttonCommConnect_Click(object sender, EventArgs e){}
//                      private void buttonStart_Click(object sender, EventArgs e){}
//                      private void trackBarMaxV_Scroll(object sender, EventArgs e){}
//                      private void trackBarCellNum_Scroll(object sender, EventArgs e){}
//                      private void pictureBox_W_A_Paint(object sender, PaintEventArgs e){}
//                      private void pictureBox_W_A_Mousewheel(object sender, MouseEventArgs e){}
//                      private void vScrollBar_W_A_Scroll(object sender, ScrollEventArgs e){}
//                      private void pictureBox_W_A_MouseEnter(object sender, EventArgs e){}
//                      private void tabPage32_Paint(object sender, PaintEventArgs e){}
//                      private void panel_W_A_Paint(object sender, PaintEventArgs e){}
//                      private void radioButtonWhole_WA_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonPart_WA_CheckedChanged(object sender, EventArgs e){}
//                      private void buttonPause_Click(object sender, EventArgs e){}
//                      private void radioButtonWSpeed_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonNVelocity_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonEVelocity_CheckedChanged(object sender, EventArgs e){}
//                      private void panel_W_C_Paint(object sender, PaintEventArgs e){}
//                      private void pictureBox_W_C_MouseEnter(object sender, EventArgs e){}
//                      private void pictureBox_W_C_Mousewheel(object sender, MouseEventArgs e){}
//                      private void vScrollBar_W_C_Scroll(object sender, ScrollEventArgs e){}
//                      private void tabPage35_Paint(object sender, PaintEventArgs e){}
//                      private void pictureBox_W_C_Paint(object sender, PaintEventArgs e){}
//                      private void radioButtonWhole_WC_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonPart_WC_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonRealTime_WA_CheckedChanged(object sender, EventArgs e{}
//                      private void radioButtonHistory_WA_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonRealTime_WC_CheckedChanged(object sender, EventArgs e){}
//                      private void radioButtonHistory_WC_CheckedChanged(object sender, EventArgs e){}
//                      public static Image RotateImage(Image img, float RotationAngle){}
//                      private void HPRpictureBox_Paint(object sender, PaintEventArgs e){}
//                      private void hScrollBarPlaybackSpeed_Scroll(object sender, ScrollEventArgs e){}
//                      private void checkBox_CellsStretch_CheckedChanged(object sender, EventArgs e){}
//                      private void checkBoxGPSCompass_CheckedChanged(object sender, EventArgs e){}
//                      private void checkBoxCompass_CheckedChanged(object sender, EventArgs e){}
//                      private void checkBoxAverageVelocity_CheckedChanged(object sender, EventArgs e){}
//     }
// }
///////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace ADCP
{
    public partial class DP300_Windows : Form
    {

        #region Variables

        /// <summary>
        /// Project file to hold all the settings
        /// and transects.  Project is used in QRev.
        /// </summary>
        RttProject _qrevProject;

        /// <summary>
        /// Current Transect to use in QRev.
        /// This project will contain the settings
        /// and the file associated with the transect.
        /// </summary>
        TransectConfig _qrevTransect;

        /// <summary>
        /// The number of ensembles in the start edge.
        /// </summary>
        int _qrevStartEnsCount;


        /// <summary>
        /// Flag to know if we should be count the start edge ensembles.
        /// </summary>
        bool _bIsQRevStartCounter;


        /// <summary>
        /// The number of ensembles in the end edge.
        /// </summary>
        int _qrevEndEnsCount;

        /// <summary>
        /// The number of ensembles in the moving section.
        /// </summary>
        int _qrevMovingEnsCount;

        /// <summary>
        /// Flag to know if we should be count the end edge ensembles.
        /// </summary>
        bool _bIsQRevEndCounter;

        /// <summary>
        /// The current ensemble output file.
        /// This is the file name for the binary file that is being written.
        /// </summary>
        string _ensOutputFileName;

        #endregion


        public class NoPaintBackGroundPanel : Panel
        {
            protected override void OnPaintBackground(PaintEventArgs e)
            {
                //不绘制背景,即跳过面板的背景绘制环节，这样在面板上绘图替换时两个缓冲区?图形之间就不会因为夹着一块背景图出现闪烁了
            }
        }

        /// LPJ 2012-4-20 
        System.ComponentModel.ComponentResourceManager res = new ComponentResourceManager(typeof(DP300_Windows));

        //////LPJ 2012-4-20 
        /// 应用资源
        /// ApplyResources 的第一个参数为要设置的控件
        ///                  第二个参数为在资源文件中的ID，默认为控件的名称
        public void ApplyResource()
        {
            GetControl(this.Controls);

            //Caption
            res.ApplyResources(this, "$this");

        }

        ////LPJ 2012-4-20 遍历所有控件
        public void GetControl(Control.ControlCollection ctl)
        {
            try
            {
                foreach (Control ctl1 in ctl)
                {
                    res.ApplyResources(ctl1, ctl1.Name);
                    if (ctl1.HasChildren)
                    {
                        GetControl(ctl1.Controls);
                    }
                   
                }
            }
            catch { }
        }

        ////LPJ 2012-4-20 判断语言类型
        public void ChooseLanguage()
        {
            if (Form1.Language_ZH == false)
            {
              //  this.WindowState = FormWindowState.Normal;

                Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en");
                ApplyResource();

                //FormNewADCP_Project newProjectForm = new FormNewADCP_Project(this);
                //newProjectForm.ChooseLanguage();

                defCfg.Language = "English"; //LPJ 2013-5-29

                this.WindowState = FormWindowState.Maximized;
            }
            else
            {
                this.WindowState = FormWindowState.Normal;

                Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("zh");
                ApplyResource();

                //FormNewADCP_Project newProjectForm = new FormNewADCP_Project(this);
                //newProjectForm.ChooseLanguage();

                defCfg.Language = "Chinese"; //LPJ 2013-5-29

                this.WindowState = FormWindowState.Maximized;
            }

            this.lV_MeasuredQ.Refresh();//LPJ 2013-5-29 更新流量汇总栏

            //this.WindowState = FormWindowState.Maximized;  //LPJ 2012-10-20
            //this.Show();                                   //LPJ 2012-10-20
        }

        public DP300_Windows()
        {
            defCfg = new DefaultCfg();

            try
            {
                InitializeComponent();
                CheckRiverAuthority(); //LPJ 2013-9-18 cancel

            }
            catch (Exception ex) //LPJ 2013-6-11
            {
                MessageBox.Show(ex.Message + " DP300_Windows InitializeComponent");
            }

            //Modified 2011-8-31 add
            //SailTrackDisplayer = new DisplayDelegate(SailTrackSetPosion); //委托指针指向 SetPosion 函数

            //headingBitmap = new Bitmap(Application.StartupPath + "\\heading.bmp");  //LPJ 2013-6-7
            //headingBitmap.MakeTransparent(Color.White);
            //pitchBitmap = new Bitmap(Application.StartupPath + "\\pitch.bmp");
            //pitchBitmap.MakeTransparent(Color.White);
            //rollBitmap = new Bitmap(Application.StartupPath + "\\roll.bmp");
            //rollBitmap.MakeTransparent(Color.White);

            //headingBitmap = new Bitmap(Application.StartupPath + "\\Resources\\heading.bmp"); //LPJ 2013-6-11
            //headingBitmap.MakeTransparent(Color.White);
            //pitchBitmap = new Bitmap(Application.StartupPath + "\\Resources\\pitch.bmp");
            //pitchBitmap.MakeTransparent(Color.White);
            //rollBitmap = new Bitmap(Application.StartupPath + "\\Resources\\roll.bmp");
            //rollBitmap.MakeTransparent(Color.White);

            try
            {
                headingBitmap = new Bitmap(pictureBox2.Image); //LPJ 2013-6-11
                headingBitmap.MakeTransparent(Color.White);
                pitchBitmap = new Bitmap(pictureBox3.Image);
                pitchBitmap.MakeTransparent(Color.White);
                rollBitmap = new Bitmap(pictureBox4.Image);
                rollBitmap.MakeTransparent(Color.White);
            }
            catch(Exception ee)
            {
                MessageBox.Show(ee.Message+" in DP300_Windows new Bitmap");
            }

            //2011-9-10
            //TrackForwardBitmap = new Bitmap(Application.StartupPath + "\\TrackForward.bmp");
            //TrackPauseBitmap = new Bitmap(Application.StartupPath + "\\TrackPause.bmp");
            //TrackStopBitmap = new Bitmap(Application.StartupPath + "\\TrackStop.bmp");

            //BlackWhite.Checked = true;   // 取消将黑白作为默认选项   JZH  2011-12-21
          
            sp = new SerialPort("COM1", 115200, Parity.None, 8, StopBits.One); //用默认值初始化串口;
            
            /*
            sp.ReadBufferSize = 16 * 65536;
            sp.BaudRate = 115200;
            sp.StopBits = StopBits.One;
            sp.Parity = Parity.None;
            sp.DataBits = 8;
            sp.Handshake = Handshake.None;//_serialPort.Handshake = Handshake.RequestToSend;
            sp.DtrEnable = true;
            //Set the read/write timeouts
            sp.ReadTimeout = 50;
            sp.WriteTimeout = 500;
            */
            sp.ReadBufferSize = 11836 * 7; // 1024 * 20 * 3; // 注意设置一下接收缓冲区大小>=(payload + 64)，否则一次不能接受整个数据包，纠结了一天半！
            sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);


            DecodeBytesData = new DisplayDelegate(PickAndDecodeEnsemble);//委托指针指向 PickAndDecodeEnsemble 函数 
            //DecodeBytesDataGPS = new DisplayDelegate(PickAndDecodeEnsemble_GPS);//LPJ 2013-11-14 委托指针指向 PickAndDecodeEnsemble 函数 

            RefreshDishargePanel = new DischargePanelDelegate(LV_MeasuredDischarge_Paint); //LPJ 2013-6-8
            RefreshNavigation = new NavigationListViewDelegate(Navigation_Paint); //LPJ 2013-6-18
            RefreshOthers = new OthersListViewDelegate(Others_Paint); //LPJ 2013-6-18
            RefreshSummaryList = new RefreshSummaryDelegate(ListView_Summary_Paint); //LPJ 2013-6-19 

            CalDischargeRefresh = new CalDischargeDelegate(CalDischarge); //LPJ 2013-6-8
            MainPanel_Refresh = new MainPanelRefreshDelegate(MainPanelPaint); //LPJ 2013-6-9

            TrackPanel_Refresh = new TrackPanelRefreshDelegate(TrackPanelPaint); //LPJ 2016-10-27

            PaintRefreshEvent = new PaintRefreshEventHandler(PrivatePaintRefreshEvent); //LPJ 2014-3-11
            WriteToDataPageEvent = new WriteToDataPageEventHandler(WriteToDataPage); //LPJ 2014-3-11
            
            GPS_sp = new SerialPort("COM2", 9600, Parity.None, 8, StopBits.One);

            /*
            GPS_sp.ReadBufferSize = 16 * 65536;
            GPS_sp.BaudRate = 9600;
            GPS_sp.StopBits = StopBits.One;
            GPS_sp.Parity = Parity.None;
            GPS_sp.DataBits = 8;
            GPS_sp.Handshake = Handshake.None;//_serialPort.Handshake = Handshake.RequestToSend;
            GPS_sp.DtrEnable = true;

            //Set the read/write timeouts
            GPS_sp.ReadTimeout = 50;
            GPS_sp.WriteTimeout = 500;
            */

            GPS_sp.DataReceived += new SerialDataReceivedEventHandler(GPS_sp_DataReceived);
            //getGPS_spDATA = new GPSDelegate(getInfoFromNMEAData); //委托指针指向 PickAndDecodeEnsemble 函数
           
            //LPJ 2012-06-13 显示文件路径
            //  this.Text = Directory.GetCurrentDirectory()+ "\\dp300Data" ;

            //Modified 2011-8-29 move bostBitmap here from Sailtrack panel
            //SailTrackBoatBitmap = new Bitmap(Application.StartupPath + "\\Resources\\SmallBoat.bmp"); //LPJ 2013-6-11 cancle 没有用到该bitmap
            //SailTrackBoatBitmap.MakeTransparent(Color.White);//白色置为透明（背景）
            //SailTrackRotatedBoatBitmap = (Bitmap)RotateImage(SailTrackBoatBitmap, 22.5F);

            this.SetStyle(ControlStyles.OptimizedDoubleBuffer |
                    ControlStyles.ResizeRedraw |
                    ControlStyles.AllPaintingInWmPaint, true); //LPJ 2013-7-4
            this.UpdateStyles();

            //MainPanelStayTimer.Elapsed += new System.Timers.ElapsedEventHandler(MainPanelStayTimer_Elapsed); //LPJ 2013-11-20
        }

        //int currentGPSCount = -1;
        private void GPS_sp_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            iAlarmTime_GPS = 0;

            string data = string.Empty;

            try
            {
                data = GPS_sp.ReadLine();   // was string data = GPS_sp.ReadLine();
            }
            catch
            {
                //MessageBox.Show("Error! 线程已断，无法接受GPS数据。");
                //LPJ 2012-4-20
                MessageBox.Show(Resource1.str_errorGPS);
            }

            if (data.Length > 0)       //Modified 2011-8-8 *************************
            {
                getInfoFromNMEAData(data);
            }
        }

        //private void GPS_GGAdecode(string data,ref string GPS_Latitude, ref string GPS_Longitude)
        //{
        //    try
        //    {    
        //        string[] gga1 = data.Split(',');   
                      
        //        GPS_Latitude = gga1[2];  
        //        GPS_Longitude = gga1[4];

        //        int latitude_Degree = 0, latitude_Min = 0;
        //        int latitude_Sec = 0;
        //        int longitude_Degree = 0, longitude_Min = 0;
        //        int longitude_Sec = 0;
                
        //        EarthCoorDecode(GPS_Latitude, ref latitude_Degree, ref latitude_Min, ref latitude_Sec);

        //        GPS_Latitude = latitude_Degree.ToString() + "º" + latitude_Min.ToString("") + "'" + latitude_Sec.ToString("") + gga1[3];
        //        //GPS_Latitude = GPS_Latitude.Insert(2, "º") + gga1[3];
        //        //GPS_Longitude = GPS_Longitude.Insert(3, "º") + gga1[5];

        //        EarthCoorDecode(GPS_Longitude, ref longitude_Degree, ref longitude_Min, ref longitude_Sec);
        //        GPS_Longitude = longitude_Degree.ToString() + "º" + longitude_Min.ToString("") + "'" + longitude_Sec.ToString("") + gga1[3];
        //    }
        //    catch
        //    {

        //        GPS_Latitude = "0000.000";
        //        GPS_Longitude = "00000.000";
                
        //    }
        //}

        //LPJ 2013-9-17 解析地球坐标，格式为DDDMM.sssss，其中DDD为度，MM为分，sssss为秒
        //返回参数分别为Degree为度，Min为分，Sec为秒
        //private void EarthCoorDecode(string earthCoor, ref int Degree, ref int Min, ref int Sec)
        //{
        //    string[] str_Lat = earthCoor.Split('.');
        //    int sec = int.Parse(str_Lat[1].Substring(0,3));
        //    int degree_Lat = int.Parse(str_Lat[0]);
        //    Degree = degree_Lat / 100;
        //    Min = degree_Lat - Degree * 100;
        //    Sec = (int)(sec / 1000.0f * 60);

        //}

        //private void GPS_GGAdecode(string data1)
        //{
        //    try
        //    {
        //        string[] split1 = data1.Split('$');    //Modified 2011-7-26
        //        string GGA_str1 = split1[1];           //Modified 2011-7-26
        //        string[] gga1 = GGA_str1.Split(',');   //Modified 2011-7-26
        //        gpsTime = gga1[1];                     //Modified 2011-7-26
        //        GPS_latitude = gga1[2];                //Modified 2011-7-26 
        //        NorthSouth = gga1[3];                  //Modified 2011-7-26
        //        GPS_longitude = gga1[4];               //Modified 2011-7-25
        //        EastWest = gga1[5];                    //Modified 2011-7-26
        //        defaultGPGGA = data1;
        //        //Modified 2011-9-21 store float lat and long
        //        GPS_FloatLatitude = float.Parse(GPS_latitude);

        //        if (NorthSouth == "S")
        //        {
        //            GPS_FloatLatitude *= -1.0f;
        //        }
        //        GPS_latitude = GPS_latitude.Insert(2, "º") + NorthSouth;

        //        GPS_FloatLongitude = float.Parse(GPS_longitude);
        //        if (EastWest == "W")
        //        {
        //            GPS_FloatLongitude *= -1.0f;
        //        }
        //        GPS_longitude = GPS_longitude.Insert(3, "º") + EastWest;
        //    }
        //    catch
        //    {
        //        GPS_GGAbuffer = defaultGPGGA;
        //        GPS_latitude = "0000.000";
        //        GPS_longitude = "00000.000";
        //        GPS_HDT = "0.0";
        //        //MessageBox.Show("GPS 错误！");
        //    }
        //}

        private void GPS_VTGdecode(string data1)
        {
            //Modified 2011-8-10 ***************************%%%%%%%%%%%%%%%%%%%%
            try
            {
                string[] split2 = data1.Split('$');    //Modified 2011-7-26
                string VTG_str = split2[1];            //Modified 2011-7-26
                string[] vtg1 = VTG_str.Split(',');     //Modified 2011-7-26
                gpsShipSpeed = vtg1[5];                 //Modified 2011-7-26
                defaultGPVTG = data1;
            }
            catch
            {
                GPS_VTGbuffer = defaultGPVTG;
                GPS_latitude = "0000.000";
                GPS_longitude = "00000.000";
                GPS_HDT = "0.0";
                //MessageBox.Show("GPS 错误！");
            }
        }

        private void GPS_HDTdecode(string data1)
        {
            //Modified 2011-8-10 ***************************
            try
            {
                string[] split3 = data1.Split('$');    //Modified 2011-7-26
                string HDT_str = split3[1];            //Modified 2011-7-26
                string[] HDT1 = HDT_str.Split(',');     //Modified 2011-7-26
                GPS_HDT = HDT1[1];
                defaultGPHDT = data1;
            }
            catch
            {
                GPS_HDTbuffer = defaultGPHDT;
                GPS_HDT = "0.0";
            }
        }

        private void GPS_ROTdecode(string data1)
        {
            //Modified 2011-8-10 ***************************
            try
            {
                string[] split3 = data1.Split('$');    //Modified 2011-7-26
                string ROT_str = split3[1];            //Modified 2011-7-26
                string[] ROT1 = ROT_str.Split(',');     //Modified 2011-7-26
                //GPS_ROT = ROT1[1];
                defaultGPROT = data1;
            }
            catch
            {
                GPS_ROTbuffer = defaultGPROT;
            }
        }

        /*
        private void VXVY_decode(string data1)
        {
            //Modified 2011-8-10 ***************************
            try
            {
                string[] split3 = data1.Split('$');    //Modified 2011-7-26
                string VX_str = split3[1];            //Modified 2011-7-26
                string[] VX = VX_str.Split(',');     //Modified 2011-7-26
                VXread = VX[1];
                VYread = VX[2];
                //VXread = "-1.234";
                VXsum = (float)Convert.ToDecimal(VXread);
                VYsum = (float)Convert.ToDecimal(VYread);
                //labelReceiveTime.Text = VYsum.ToString("0.000");  //cancelled 2011-8-15
            }
            catch
            {
                VXread = "";
                VYread = "";
            }

          
        }
        */
        int GPSLines = 0;
        string GPStempData = "";
        private void getInfoFromNMEAData(string data)
        {
            //Modified, 2011-8-9 next is totally rewrite
            ////Modified start
            lock (locker1) //lock: to prevent other thread get into the program till this function is done, Modified 2011-7-21
            {
                {
                    string[] split = data.Split(',');
                    string dd = split[0];

                    switch (dd)
                    {
                        case "$GPGGA":
                            GPS_GGAbuffer = data;
                            ggaNum = 1;
                            GPSLines++;
                            GPStempData += (data + "\r\n");
                            break;
                        case "$GPVTG":
                            GPS_VTGbuffer = data;
                            vtgNum = 1;
                            GPSLines++;
                            GPStempData += (data + "\r\n");
                            break;
                        case "$GPHDT":
                            GPS_HDTbuffer = data;
                            hdtNum = 1;
                            GPSLines++;
                            GPStempData += (data + "\r\n");
                            break;
                        case "$GPROT":
                            GPS_ROTbuffer = data;
                            rotNum = 1;
                            GPSLines++;
                            GPStempData += (data + "\r\n");
                            break;
                    }
                    gpsFlag = vtgNum + hdtNum + rotNum + ggaNum;
                    //vtgNum = ggaNum = hdtNum = rotNum = 0;
                    if (GPSLines == gpsFlag)
                    {
                        GPS_receiveData = GPStempData;
                        GPStempData = "";
                        GPSLines = 0;
                        //vtgNum = ggaNum = hdtNum = rotNum = 0;
                    }
                    //if (dd == "$GPVTG")
                    //{
                    //    GPS_VTGbuffer = data;
                    //    vtgNum++;
                    //}
                    //if (dd == "$GPHDT" || dd == "$HEHDT")
                    //{
                    //    GPS_HDTbuffer = data;
                    //    hdtNum++;
                    //}
                    //if (dd == "$GPROT" || dd == "$HEROT")
                    //{
                    //    GPS_ROTbuffer = data;
                    //}
                    //if (dd == "$GPGGA")
                    //{
                    //    GPS_GGAbuffer = data;
                    //    ggaNum++;
                    //}
                }
            }
            //Modified end
        }

        private void CheckRiverAuthority()
        {
            if (playBackMode)
            {
                if (PlayBackTimeLenth < 200)
                {
                    PlayBackTimeLenth = 200;
                }

                try
                {
                    PlayBackTimer.Stop();
                    PlayBackTimer.Close();
                    PlayBackTimer = new System.Timers.Timer();
                    PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
                    PlayBackTimer.Interval = setPlaybackTimeLength;
                    PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
                    ProcessBar.Refresh();
                    if (!bPlaybackStop) //LPJ 2013-11-19
                        PlayBackTimer.Start();
                }
                catch
                {
                }
            }

        }

     
        //static object locker = new object();
        //bool bAutoZoom = false;  //JZH Debug
        //LPJ 2013-6-9
        delegate void MainPanelRefreshDelegate(); //LPJ 2013-6-9
        MainPanelRefreshDelegate MainPanel_Refresh; //LPJ 2013-6-9

        delegate void TrackPanelRefreshDelegate(); //LPJ 2013-6-9
        TrackPanelRefreshDelegate TrackPanel_Refresh; //LPJ 2013-6-9
        private void MainPanelPaint() //LPJ 2013-6-9
        {
            MainPanel.Refresh(); //LPJ 2013-6-9
            //panelGPSTrack.Refresh(); //LPJ 2013-6-9
            
        }

        private void TrackPanelPaint() //LPJ 2016-10-27
        {
            panelGPSTrack.Refresh(); //LPJ 2013-6-9
        }

        
        private void ChangeToNewRGB() //LPJ 2013-7-4 当滑动滑块时，修改所有的颜色，最开始载入数据后，就修改颜色
        {
            if (trackBarMaxV.Value != 0)
                adjustedMultiple = 100f / trackBarMaxV.Value;
            else
                adjustedMultiple = 100;

            EnsemblesInfoToStore.NewWaterSpeedToSixColor.Clear();
            EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPS.Clear();
            EnsemblesInfoToStore.NewWaterSpeedToSixColor_Null.Clear(); //LPJ 2013-12-3
            EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPGGA.Clear();

            int icounts = EnsemblesInfoToStore.WaterSpeedToSixColor.Count; //LPJ 2013-7-12

            //FrmProgressBar frmProgressBar = new FrmProgressBar(0, icounts);
            //frmProgressBar.Show();

            for (int i = 0; i < icounts; i++)
            {
                //frmProgressBar.setPos(i);
                int j = 0;
                try
                {
                    Color[] VelClr;
                    VelClr = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor[i];

                    Color[] NewVelClr = new Color[VelClr.Count()];

                    j = 0;
                    foreach (Color color in VelClr)
                    {
                        NewVelClr[j] = GetNewRGB(color, adjustedMultiple);
                        j++;
                    }

                    EnsemblesInfoToStore.NewWaterSpeedToSixColor.Add(NewVelClr);
                }
                catch
                {
                }

                //LPJ 2013-7-31 --start
                try
                {
                    Color[] VelClr_GPS;
                    VelClr_GPS = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_GPS[i];

                    Color[] NewVelClr_GPS = new Color[VelClr_GPS.Count()];
                    j = 0;
                    foreach (Color color in VelClr_GPS)
                    {
                        NewVelClr_GPS[j] = GetNewRGB(color, adjustedMultiple);
                        j++;
                    }
                    EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPS.Add(NewVelClr_GPS);
                }
                catch
                {
                }
                //LPJ 2013-7-31 --end

                //LPJ 2013-12-3 更新船速无参考的流速色图 --start
                try
                {
                    Color[] VelClr_Null;

                    VelClr_Null = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_Null[i];


                    Color[] NewVelClr_Null = new Color[VelClr_Null.Count()];
                    j = 0;
                    foreach (Color color in VelClr_Null)
                    {
                        NewVelClr_Null[j] = GetNewRGB(color, adjustedMultiple);
                        j++;
                    }
                    EnsemblesInfoToStore.NewWaterSpeedToSixColor_Null.Add(NewVelClr_Null);
                }
                catch
                {
                }
                //LPJ 2013-12-3 --end

                //LPJ 2016-8-11 --start
                try
                {
                    Color[] VelClr_GPGGA;
                    VelClr_GPGGA = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA[i];

                    Color[] NewVelClr_GPGGA = new Color[VelClr_GPGGA.Count()];
                    j = 0;
                    foreach (Color color in VelClr_GPGGA)
                    {
                        NewVelClr_GPGGA[j] = GetNewRGB(color, adjustedMultiple);
                        j++;
                    }
                    EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPGGA.Add(NewVelClr_GPGGA);
                }
                catch
                {
                }
                //LPJ 2016-8-11 --end
            }
            //frmProgressBar.Close();
        }

        //在测量模式下，更新颜色
        private void ChangeToNewRGB_Survey() //LPJ 2016-8-15
        {
            int i = EnsemblesInfoToStore.WaterSpeedToSixColor.Count - 1;
            int j = 0;
            try
            {
                Color[] VelClr;
                VelClr = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor[i];

                Color[] NewVelClr = new Color[VelClr.Count()];

                j = 0;
                foreach (Color color in VelClr)
                {
                    NewVelClr[j] = GetNewRGB(color, adjustedMultiple);
                    j++;
                }

                EnsemblesInfoToStore.NewWaterSpeedToSixColor.Add(NewVelClr);
            }
            catch
            {
            }

            //LPJ 2013-7-31 --start
            try
            {
                Color[] VelClr_GPS;
                VelClr_GPS = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_GPS[i];

                Color[] NewVelClr_GPS = new Color[VelClr_GPS.Count()];
                j = 0;
                foreach (Color color in VelClr_GPS)
                {
                    NewVelClr_GPS[j] = GetNewRGB(color, adjustedMultiple);
                    j++;
                }
                EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPS.Add(NewVelClr_GPS);
            }
            catch
            {
            }
            //LPJ 2013-7-31 --end

            //LPJ 2013-12-3 更新船速无参考的流速色图 --start
            try
            {
                Color[] VelClr_Null;

                VelClr_Null = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_Null[i];


                Color[] NewVelClr_Null = new Color[VelClr_Null.Count()];
                j = 0;
                foreach (Color color in VelClr_Null)
                {
                    NewVelClr_Null[j] = GetNewRGB(color, adjustedMultiple);
                    j++;
                }
                EnsemblesInfoToStore.NewWaterSpeedToSixColor_Null.Add(NewVelClr_Null);
            }
            catch
            {
            }
            //LPJ 2013-12-3 --end

            //LPJ 2016-8-11 --start
            try
            {
                Color[] VelClr_GPGGA;
                VelClr_GPGGA = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA[i];

                Color[] NewVelClr_GPGGA = new Color[VelClr_GPGGA.Count()];
                j = 0;
                foreach (Color color in VelClr_GPGGA)
                {
                    NewVelClr_GPGGA[j] = GetNewRGB(color, adjustedMultiple);
                    j++;
                }
                EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPGGA.Add(NewVelClr_GPGGA);
            }
            catch
            {
            }
        }

        private bool bGPSConnect = false; //LPJ 2013-6-21 用于标记是否连接GPS
        private void MainPanel_Paint(object sender, PaintEventArgs e)
        {
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;//获取当前绘图主缓冲区上下文
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, MainPanel.DisplayRectangle);
                //设置双缓冲的图形缓冲区：使用指定的e.Graphics像素格式，创建指定大小panelTrackDisplayer.DisplayRectangle的图形缓冲区

                using (Graphics g = MainBuffer.Graphics)
                {
                    //lock (locker)
                    {
                        //g.FillRectangle(Brushes.Honeydew, this.MainPanel.ClientRectangle);
                        g.FillRectangle(Brushes.White, this.MainPanel.ClientRectangle);
                        //Color cc;

                        //JZH 2011-12-26 为实时显示时初始化BinDataEnsembleNum
                        if (playBackMode == false && EnsemblesInfoToStore.WaterSpeedToSixColor.Count > 0)
                        {
                            BinDataEnsembleNum = EnsemblesInfoToStore.WaterSpeedToSixColor.Count;
                        }
                        //else//LPJ 2013-7-26
                        //{
                        //    BinDataEnsembleNum = EnsemblesInfoToStore.bottomDepth.Count;
                        //}

                        //float PixelRectangleWidth = 3; 
                        float PixelRectangleWidth = 1;   //JZH Debug
                        float PixelRectangleHeight = 0;

                        //SM>
                        float dep = 0;
                        float maxDep = 0;
                        //float dep;
                        //dep = cells * cellSize;  //10*0.5=5m
                        //LPJ 2013-5-25 添加自动缩放功能，动态设置最大深度 --start
                        //float maxDep = dep;
                        //SM<

                        if (BinDataEnsembleNum > 0)
                        {   
                            try //LPJ 2013-8-6
                            {
                                dep = (float)EnsemblesInfoToStore.BinSize[0];
                                maxDep = (float)EnsemblesInfoToStore.bottomDepth[0];
                                for (int iflag = 0; iflag < BinDataEnsembleNum; iflag++)
                                {
                                    if (maxDep < (float)EnsemblesInfoToStore.bottomDepth[iflag])
                                        maxDep = (float)EnsemblesInfoToStore.bottomDepth[iflag];

                                    if(dep < (float)EnsemblesInfoToStore.BinSize[iflag])
                                        dep = (float)EnsemblesInfoToStore.BinSize[iflag];
                                }
                            }
                            catch
                            {
                                //dep = dep;
                            }
                        }
                        if (maxDep > 0)  //LPJ 2014-1-8
                            dep = maxDep;
                        //LPJ 2013-5-25 添加自动缩放功能，动态设置最大深度 --end

                        //SM>
                        /*
                        //float uplen = upBlank + insDep;   //JZH 2012-02-14 第一个单元起始位置=RangeOfFirstBin - cellsize/2 + 仪器入水深度
                        //JZH 2012-02-14                  
                        if (EnsemblesInfoToStore.RangeOfFirstBin.Count > 0)
                        {
                            //upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[0] - cellSize / 2.0f;  //默认一次测量中第一个单元起始位置不变，实际上变化非常微小，可以忽略不计
                            //JZH 2012-05-18  默认用最后一个单元的起始位置
                            if (BinDataEnsembleNum > 0)
                                upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[BinDataEnsembleNum - 1] - cellSize / 2.0f;
                            else
                                upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[0] - cellSize / 2.0f;
                        }
                        float uplen = upBlank + insDep;
                        */
                        float uplen = 0;
                        float preBottom = 0;
                        //SM<

                        //InsInfotextBox.Text = uplen.ToString(); //Modified

                        //Modified 2011-10-14 display surface blind zone
                        
                        float seafaceLenToScreen;
                                               
                        {
                            seafaceLenToScreen = 0;
                        }

                        //if (true == SixColor.Checked)
                        {
                            //g.FillRectangle(Brushes.White, MainPanel.Width - (MainPanel.Width - 68 + 5), 5, (MainPanel.Width - 69 + 5), 300); //JZH 2011-12-27 Adjust //LPJ 2013-5-16
                            g.FillRectangle(Brushes.Gray, 35, 0, MainPanel.Width, MainPanel.Height);
                            //cc = Color.Black;
                            if (EnsemblesInfoToStore.WaterSpeedToSixColor.Count >= 1)
                            {
                                //int StartX = this.MainPanel.Width - 1;
                                float StartX = this.MainPanel.Width - 1;

                                //JZH 2011-12-25 一次将所有的图形显示出来 
                                PixelRectangleWidth = (MainPanel.Width - 35) / (float)BinDataEnsembleNum;  ////JZH 2011-12-27 Adjust
                                //JZH 2011-12-25
                                //for (int i = EnsemblesInfoToStore.WaterSpeedToSixColor.Count - 1; i >= 0; i--) //JZH Debug 

                                Color[] VelClr;
                                Pen blackPen = new Pen(Color.WhiteSmoke, 2); //LPJ 2013-7-8
                                SolidBrush colorBrush = new SolidBrush(Color.White); //LPJ 2013-7-8
                                PointF[] linesPnt = new PointF[3 * BinDataEnsembleNum];  //LPJ 2013-7-8 在这里考虑划线的时候，一次性直接画折线
                                int iLines = 0;
                                
                                for (int i = BinDataEnsembleNum - 1; i >= 0; i--) //LPJ 2013-6-9 该循环很费时，占CPU较多，考虑方法解决该问题
                                {
                                    //VelClr = (Color[])EnsemblesInfoToStore.NewWaterSpeedToSixColor[i];
                                    ////LPJ 2013-7-31 start
                                    if ("GPS VTG" == labelVesselRef.Text)
                                    {
                                        VelClr = (Color[])EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPS[i];
                                    }
                                    else if ("GPS GGA" == labelVesselRef.Text)
                                    {
                                        VelClr = (Color[])EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPGGA[i];
                                    }
                                    else if (Resource1.String233 == labelVesselRef.Text)
                                    {
                                        VelClr = (Color[])EnsemblesInfoToStore.NewWaterSpeedToSixColor_Null[i];
                                    }
                                    else
                                    {
                                        VelClr = (Color[])EnsemblesInfoToStore.NewWaterSpeedToSixColor[i];
                                    }//LPJ 2013-7-31 end

                                    //VelClr = (Color[])EnsemblesInfoToStore.WaterSpeedToSixColor[i]; //LPJ 2013-7-4 change

                                    //if (maxCells < VelClr.Length)   //LPJ 2013-7-4 作用是什么？
                                    //{
                                    //    maxCells = VelClr.Length;
                                    //    //labelMaxCellNum.Text = ((int)(((float)trackBarCellNum.Value / 200) * maxCells)).ToString();
                                    //}

                                    //SM>
                                    //PixelRectangleHeight = (MainPanel.Height - seafaceLenToScreen) / (dep / cellSize); //LPJ 2013-5-28
                                    float FirstPixel = 0;
                                    float PixelsPerMeter = 0;
                                    if (EnsemblesInfoToStore.RangeOfFirstBin.Count > 0)
                                    {
                                        seafaceLenToScreen = 0;
                                        cellSize = (float)EnsemblesInfoToStore.BinSize[i];
                                        upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[i] - cellSize / 2.0f;
                                        uplen = upBlank + insDep;
                                        //if (dep > 0 && uplen >= 0 && cellSize > 0)
                                        //{
                                        //    seafaceLenToScreen = (MainPanel.Height / ((dep - uplen) / cellSize)) - (MainPanel.Height / (dep / cellSize));
                                        //    if (seafaceLenToScreen < 0)
                                        //        seafaceLenToScreen = 0;
                                        //}
                                        //PixelRectangleHeight = (MainPanel.Height - seafaceLenToScreen) / (dep / cellSize);

                                        if (dep > 0)
                                        {
                                            PixelsPerMeter = MainPanel.Height / (dep + insDep);
                                            FirstPixel = (uplen - cellSize / 2) * PixelsPerMeter;
                                            PixelRectangleHeight = cellSize * PixelsPerMeter;
                                        }
                                    }
                                    else
                                    {
                                        uplen = 0;
                                        cellSize = 0;
                                        PixelRectangleHeight = 1;
                                    }
                                    
                                    
                                    //SM<

                                    if (PixelRectangleWidth == 0)
                                    {
                                        PixelRectangleWidth = 1;
                                    }
                                    //StartX -= (int)PixelRectangleWidth;
                                    StartX -= PixelRectangleWidth;

                                    //int j = 0;
                                    //foreach (Color color in VelClr)
                                    //{
                                    //    //if (j < (int)( maxCells)) //LPJ 2013-7-4 cancel
                                    //    {
                                    //        float StartY = seafaceLenToScreen + j * PixelRectangleHeight;
                                    //        //LPJ 2013-5-16 在这里增加一个判断，是否是有效剖面，如果是，则填充色块，若不是，则填充黑色色块 --start
                                    //        if (j < (int)EnsemblesInfoToStore.iGoodBin[i])
                                    //        {
                                    //            g.FillRectangle(new SolidBrush(color), StartX, StartY, PixelRectangleWidth, PixelRectangleHeight);
                                    //        }
                                    //        else if (j >= (int)EnsemblesInfoToStore.iGoodBin[i] && j < ((float)EnsemblesInfoToStore.bottomDepth[i] - upBlank) / cellSize - 1)
                                    //        {
                                    //            g.FillRectangle(Brushes.Black, StartX, StartY, PixelRectangleWidth, PixelRectangleHeight);
                                    //        }
                                    //        //LPJ 2013-5-16 在这里增加一个判断，是否是有效剖面，如果是，则填充色块，若不是，则填充黑色色块 --end

                                    //        j++;
                                    //    }
                                    //}
                                    //int imaxCells = (int)(((float)EnsemblesInfoToStore.bottomDepth[i] - upBlank) / cellSize);
                                    int iGoodBin = 0;
                                    try
                                    {
                                        //SM>
                                        //iGoodBin = (int)EnsemblesInfoToStore.iGoodBin[i] + 1;//LPJ 2016-12-15 多显示一层
                                        iGoodBin = (int)EnsemblesInfoToStore.iGoodBin[i];
                                        //SM<
                                    }
                                    catch
                                    {
                                        iGoodBin = 0;
                                    }
                                    
                                    for (int j = 0; j < iGoodBin; j++)
                                    {
                                        try  //LPJ 2017-1-3
                                        {
                                            colorBrush.Color = VelClr[j]; //LPJ 2013-7-8
                                        }
                                        catch
                                        {
                                            //j = j;
                                        }
                                        //SM>
                                        //float StartY = seafaceLenToScreen + j * PixelRectangleHeight;
                                        //uplen = insDep;
                                        //seafaceLenToScreen = 0;
                                        //if (dep > 0 && uplen >= 0 && cellSize > 0)
                                        //{
                                        //    seafaceLenToScreen = (MainPanel.Height / ((dep - uplen) / cellSize)) - (MainPanel.Height / (dep / cellSize));
                                        //    if (seafaceLenToScreen < 0)
                                        //        seafaceLenToScreen = 0;
                                        //}
                                        // nono float StartY = seafaceLenToScreen + j * PixelRectangleHeight;
                                        float StartY = FirstPixel +  j * PixelRectangleHeight;
                                        //SM<
                                        //LPJ 2013-5-16 在这里增加一个判断，是否是有效剖面，如果是，则填充色块，若不是，则填充黑色色块 --start
                                        g.FillRectangle(colorBrush, StartX, StartY, PixelRectangleWidth, PixelRectangleHeight);

                                    }

                                    //g.FillRectangle(Brushes.Black, StartX, StartY, PixelRectangleWidth, PixelRectangleHeight + heightY);

                                    //LPJ 2013-5-16 在这里增加一个判断，是否是有效剖面，如果是，则填充色块，若不是，则填充黑色色块 --end

                                    if (dep > 0)
                                    {
                                        //SM>
                                        /*
                                        float s1 = ((float)EnsemblesInfoToStore.bottomDepth[i] - upBlank) / dep;
                                        if (s1 > 1) 
                                            s1 = 1;
                                        else 
                                        if (s1 < 0) 
                                            s1 = 0;
                                        //float bottomToPanel = seafaceLenToScreen + s1 * (300f - seafaceLenToScreen) + 5;  //LPJ 2013-5-16
                                        float bottomToPanel = seafaceLenToScreen + s1 * (MainPanel.Height - seafaceLenToScreen);

                                        float StartY = seafaceLenToScreen + iGoodBin * PixelRectangleHeight; 
                                        float recHeight = bottomToPanel - StartY;
                                        */

                                        float curBottom = (float)EnsemblesInfoToStore.bottomDepth[i];

                                        if (curBottom < 0.0001)
                                            curBottom = preBottom;

                                        float StartY =  FirstPixel + (iGoodBin + 1) * PixelRectangleHeight;
                                        float BottomPixel = (curBottom + insDep) * PixelsPerMeter;
                                        float recHeight = BottomPixel - StartY;
                                        float bottomToPanel = BottomPixel;



                                        //SM<
                                        try
                                        {
                                            if (recHeight > 0)
                                                g.FillRectangle(Brushes.Black, StartX, StartY, PixelRectangleWidth, recHeight); //LPJ 2013-7-5 将有效层数以下到底的部分填充黑色
                                        }
                                        catch
                                        {
                                        }

                                        //using (Pen blackPen = new Pen(Color.WhiteSmoke, 2))
                                        {
                                            float StartXpt = StartX + PixelRectangleWidth;
                                            //g.DrawLine(blackPen, StartXpt, bottomToPanel, StartX, bottomToPanel);

                                            if (i < EnsemblesInfoToStore.NewWaterSpeedToSixColor.Count - 1)
                                            {
                                                //SM>
                                                /*
                                                float s2 = ((float)EnsemblesInfoToStore.bottomDepth[i + 1] - upBlank) / dep;
                                                if (s2 > 1) s2 = 1;
                                                else if (s2 < 0) s2 = 0;
                                                //float preBottomToPanel = seafaceLenToScreen + s2 * (300f - seafaceLenToScreen) + 5; //LPJ 2013-5-16
                                                float preBottomToPanel = seafaceLenToScreen + s2 * (MainPanel.Height - seafaceLenToScreen);
                                                //g.DrawLine(blackPen, StartXpt, preBottomToPanel, StartXpt, bottomToPanel);
                                                */
                                                float preBottomPixel = (preBottom + insDep) * PixelsPerMeter;// (float)EnsemblesInfoToStore.bottomDepth[i + 1] * PixelsPerMeter;
                                                float preBottomToPanel = preBottomPixel; 
                                                //SM<
                                                linesPnt[iLines].X = StartXpt; //LPJ 2013-7-8
                                                linesPnt[iLines++].Y = preBottomToPanel; //LPJ 2013-7-8

                                                if(curBottom > 0)
                                                    preBottom = curBottom;
                                            }

                                            linesPnt[iLines].X = StartXpt; //LPJ 2013-7-8
                                            linesPnt[iLines++].Y = bottomToPanel; //LPJ 2013-7-8

                                            linesPnt[iLines].X = StartX; //LPJ 2013-7-8
                                            linesPnt[iLines++].Y = bottomToPanel; //LPJ 2013-7-8

                                        }
                                    }
                                    //if (StartX <= MainPanel.Width - 471) break;   //JZH debug
                                    if (StartX <= 35)  ////JZH 2011-12-27 Adjust
                                    {
                                        try
                                        {
                                            for (int t = iLines; t < 3 * BinDataEnsembleNum; t++) //LPJ 2013-7-10
                                            {
                                                linesPnt[t] = linesPnt[iLines - 1];
                                            }
                                        }
                                        catch
                                        {
                                        }
                                        break;
                                    }
                                }
                                if (BinDataEnsembleNum > 0)
                                    g.DrawLines(blackPen, linesPnt); //LPJ 2013-7-8

                                colorBrush.Dispose(); //LPJ 2013-7-8
                                blackPen.Dispose();
                            }
                        }

                        g.DrawRectangle(Pens.Black, 35, 0, (MainPanel.Width - 25), MainPanel.Height);  //JZH 2011-12-27 Adjust
                        SizeF size;
                        Font font = new Font("Arial", 8);

                        //LPJ 2013-8-7 将之前固定显示20行的深度，修改为根据水深显示，当水深层数超过20时，只显示20行
                        int watercells = (int)(dep / cellSize);
                        if (watercells > 20)
                            watercells = 20; //LPJ 2013-8-7

                        //SM>
                        if (EnsemblesInfoToStore.RangeOfFirstBin.Count > 0)
                        {
                            if (BinDataEnsembleNum > 0)
                                upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[BinDataEnsembleNum - 1] - cellSize / 2.0f;
                            else
                                upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[0] - cellSize / 2.0f;
                        }
                        upBlank = 0;
                        uplen = upBlank + insDep;
                        //SM<
                        for (int i = 0; i < watercells; i++) //LPJ 2013-8-7  for (int i = 0; i < 20; i++)
                        {
                            //g.DrawLine(Pens.Black,  35, seafaceLenToScreen + i * (MainPanel.Height - seafaceLenToScreen) / 20 ,  //JZH 2011-12-27 Adjust
                            //    35, seafaceLenToScreen + i * (MainPanel.Height - seafaceLenToScreen) / 20 );   //JZH 2011-12-27 Adjust
                            //using (Font font = new Font("Arial", 8))
                            {
                                float x, y;
                                PointF pt;
                                size = g.MeasureString((uplen + i * dep / watercells).ToString("0.00"), font); //size = g.MeasureString((uplen + i * dep / 20f).ToString("0.00"), font);
                                x = 35 - size.Width;      //JZH 2011-12-27 Adjust
                                //y = seafaceLenToScreen + i * (MainPanel.Height - seafaceLenToScreen) / 20 - size.Height / 2 +5;     //JZH 2011-12-27 Adjust
                                y = seafaceLenToScreen + i * (MainPanel.Height - seafaceLenToScreen) / watercells - size.Height / 2 + 5; //LPJ 2013-8-7
                                pt = new PointF(x, y);
                                //g.DrawString((uplen + i * dep / 20f).ToString("0.00"), font, Brushes.Black, pt);
                                //LPJ 2013-6-26 当选择英制单位时，将显示的数据修改
                                //if (labelUnit.Text == Resource1.String237)
                                if (!bEnglish2Metric)
                                {
                                    //double fdepth = projectUnit.MeterToFeet((uplen + i * dep / 20f), 1);
                                    double fdepth = projectUnit.MeterToFeet((uplen + i * dep / watercells), 1);  //LPJ 2013-8-7
                                    g.DrawString(fdepth.ToString("0.00"), font, Brushes.Black, pt);
                                    //labelMainPanelFigure.Text = Resource1.String220 + labelVesselRef.Text + "(ft/s)";
                                }
                                else
                                {
                                    //g.DrawString((uplen + i * dep / 20f).ToString("0.00"), font, Brushes.Black, pt);
                                    g.DrawString((uplen + i * dep / watercells).ToString("0.00"), font, Brushes.Black, pt); //LPJ 2013-8-7
                                    //labelMainPanelFigure.Text = Resource1.String220 + labelVesselRef.Text + "(m/s)";
                                }
                            }
                        }

                        if (!bEnglish2Metric)
                        {
                            labelMainPanelFigure.Text = Resource1.String220 + labelVesselRef.Text + "(ft/s)";
                        }
                        else
                        {
                            labelMainPanelFigure.Text = Resource1.String220 + labelVesselRef.Text + "(m/s)";
                        }

                        font.Dispose();

                        //using (Font font = new Font("Arial", 8))
                        //{
                        //    size = g.MeasureString((uplen + 12 * dep / 20f).ToString("0.00"), font);
                        //    }

                    }
                    if (EnsemblesInfoToStore.WaterVelocity.Count > 0 && playBackMode == false)
                    {
                        //if (totalNum > currentGPSCount)
                        {
                            //Modified 2011-8-10 Found sometimes GPS is lost
                            if (bGPSConnect) //LPJ 2013-6-21
                            {
                                //current_EsambleTotaleNum = totalNum.ToString() + " GPS(" + GPSstoredNumber.ToString() + ")"; //Modified 2011-8-5 testing for GPS file recording*******************
                                current_EsambleTotaleNum = totalNum.ToString();
                                #region Decode GPGGA ---start   LPJ 2014-7-10
                                CDecodeGPS decodeGPS = new CDecodeGPS();
                                decodeGPS.GPS_GGAdecode(GPS_GGAbuffer, ref gpsTime, ref GPS_longitude, ref GPS_latitude, ref NorthSouth, ref EastWest);
                                defaultGPGGA = GPS_GGAbuffer;
                                GPS_FloatLatitude = float.Parse(GPS_latitude);
                                if (NorthSouth == "S")
                                    GPS_FloatLatitude *= -1.0f;
                                GPS_latitude = GPS_latitude.Insert(2, "º") + NorthSouth;
                                GPS_FloatLongitude = float.Parse(GPS_longitude);
                                if (EastWest == "W")
                                {
                                    GPS_FloatLongitude *= -1.0f;
                                }
                                GPS_longitude = GPS_longitude.Insert(3, "º") + EastWest;
                                #endregion

                                //GPS_GGAdecode(GPS_GGAbuffer);
                                GPS_VTGdecode(GPS_VTGbuffer);
                                GPS_HDTdecode(GPS_HDTbuffer);
                                GPS_ROTdecode(GPS_ROTbuffer);

                                current_LatitudeText = GPS_latitude; // +" " + NorthSouth;
                                current_LongitudeText = GPS_longitude; // +" " + EastWest;

                                //labelShipSpeedText.Text = gpsShipSpeed;

                                //if (TrueNorth) //LPJ 2013-9-25
                                current_TrueNorthText = GPS_HDT;

                                //GPScontrolPanel.Refresh(); //Modified 2011-9-1
                            }
                            else
                            {
                                //labelEsambleTotaleNum.Text = totalNum.ToString();  //LPJ 2012-10-10 取消，样本总数显示开始测量后的总数
                                current_EsambleTotaleNum = MeasTotalNum.ToString();    //LPJ 2012-10-10 增加，样本总数显示开始测量后的总数
                            }

                            //current_TotalTimelabel = (NumToTime((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] * 1000)).ToString();
                            current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - (float)EnsemblesInfoToStore.RecivedTime[0]) * 1000)).ToString();   //JZH 2013-08-01 
                            current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[EnsemblesInfoToStore.RecivedDataTime.Count - 1];

                            //labelCellsNum.Text = gpsFlag.ToString();

                        }
                    }
                    // 自定义缓冲中的图形渲染在屏幕上
                    MainBuffer.Render(e.Graphics);
                    MainBuffer.Dispose();
                }
            }
            catch
            {
            }
        }


        private double MaxWaterSpeed = 0; //LPJ 2013-8-6 设置最大水流速
        private void ComputeCombinedWaterVilocity(int currentXposition)
        {
            int xx = 0;
            //int yy = 0;


            VXsum = 0.0f;
            VYsum = 0.0f;

            //float AvgDepth = 0.0f;  //JZH　2012-01-10 平均水深

            if (callNum != currentXposition)  //to ensure call only once for each ping
            {
                //Modified 2011-8-10. EnsemblesInfoToStore is purged every restoreNum of points
                CCC = (currentXposition % restoreNum);
                if (CCC == 0 && totalNum > 2)
                {
                    //CurrentGPSFileNumber++;
                }
                //LPJ 2012-5-4  记录保存GPS数据的文件个数
                if ((MeasTotalNum % restoreNum) == 0 && MeasTotalNum > 2)
                {
                    //SaveGPSFileNumber++;
                }

                if (currentXposition <= restoreNum)
                {
                    xx = currentXposition - 1;
                }
                else
                {
                    xx = CCC;  //KKKKKKKKKKKK -1 because the call to this function is earlier than the data formated
                }

                if (currentXposition > 0)
                {
                    VXsum = 0.0f;
                    VYsum = 0.0f;

                    //JZH 2012-01-10 新版计算平均流速
                    //CalculateAverageWaterSpeed(currentXposition - 1, ref VXsum, ref VYsum, ref AvgDepth); //LPJ 2013-7-3

                    //LPJ 2013-5-16 计算有效单元层数 -start
                    //int iGoodBinNum = CalGoodBinNumber(currentXposition - 1);
                    int iGoodBinNum = GetAverageWaterSpeed(currentXposition - 1, ref VXsum, ref VYsum);
                    EnsemblesInfoToStore.iGoodBin.Add(iGoodBinNum);
                    if (bStartMeasQ) //LPJ 2012-5-4
                    {
                        SaveEnsemblesInfo.iGoodBin.Add(iGoodBinNum);
                    }
                    //LPJ 2013-5-16 计算有效单元层数 -end

                    VXstore = VXsum;
                    VYstore = VYsum;

                    AverageVXsave[GGAsaveCount] = VXstore; //LPJ 2016-8-25
                    AverageVYsave[GGAsaveCount] = VYstore;

                    //LPJ  2013-5-18 计算水流方向和船速流速比--start
                    double fWaterDir;
                    fWaterDir = System.Math.Atan2(VXsum, VYsum);
                    if (fWaterDir < 0)
                        fWaterDir = fWaterDir / Math.PI * 180 + 360;
                    else
                        fWaterDir = fWaterDir / Math.PI * 180;
                    EnsemblesInfoToStore.WaterDir.Add(fWaterDir);
                    if (bStartMeasQ)
                        SaveEnsemblesInfo.WaterDir.Add(fWaterDir);

                    double fWaterSpeed = Math.Sqrt(Math.Pow(VXsum, 2) + Math.Pow(VYsum, 2));

                    if (MaxWaterSpeed < fWaterSpeed) //LPJ 2013-8-6 根据最大流速确定绘制的流速线的比例尺
                    {
                        MaxWaterSpeed = fWaterSpeed;
                        AverageScale = (int)(this.panelGPSTrack.Width / 8 / MaxWaterSpeed);
                    }

                    double fBoatWater = 0;
                    if (fWaterSpeed > 0.0001)
                        fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed[currentXposition - 1] / fWaterSpeed;
                    EnsemblesInfoToStore.BoatWater.Add(fBoatWater);
                    if (bStartMeasQ)
                        SaveEnsemblesInfo.BoatWater.Add(fBoatWater);
                    //LPJ  2013-5-18 计算水流方向和船速流速比---end

                    if (!bEnglish2Metric)  //LPJ 2016-8-26 显示当前选择船速的流速信息
                    {
                        current_WaterSpeed = projectUnit.MeterToFeet(fWaterSpeed, 1).ToString("0.000");
                    }
                    else
                    {
                        current_WaterSpeed = fWaterSpeed.ToString("0.000");
                    }
                    current_WaterDirection = fWaterDir.ToString("0.0");

                    #region GPS VTG
                    try
                    //if ("GPS VTG" == labelVesselRef.Text && bGPSConnect)
                    {
                        GetAverageWaterSpeed_GPS(currentXposition - 1, ref VXsum, ref VYsum);
                        VXstore = VXsum;//LPJ 2015-11-2 当船速采用GPS VTG时，该值才可用
                        VYstore = VYsum;

                        AverageVXsave_GPS[GGAsaveCount] = VXstore; //LPJ 2016-8-25
                        AverageVYsave_GPS[GGAsaveCount] = VYstore;

                        fWaterDir = System.Math.Atan2(VXsum, VYsum);
                        if (fWaterDir < 0)
                            fWaterDir = fWaterDir / Math.PI * 180 + 360;
                        else
                            fWaterDir = fWaterDir / Math.PI * 180;
                        EnsemblesInfoToStore.WaterDir_GPS.Add(fWaterDir);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.WaterDir_GPS.Add(fWaterDir);

                        fWaterSpeed = Math.Sqrt(Math.Pow(VXsum, 2) + Math.Pow(VYsum, 2));
                        if (fWaterSpeed != 0)
                            fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed_GPS[currentXposition - 1] / fWaterSpeed;
                        EnsemblesInfoToStore.BoatWater_GPS.Add(fBoatWater);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.BoatWater_GPS.Add(fBoatWater);

                        if ("GPS VTG" == labelVesselRef.Text)
                        {
                            if (!bEnglish2Metric)  //LPJ 2016-8-26 显示当前选择船速的流速信息
                            {
                                current_WaterSpeed = projectUnit.MeterToFeet(fWaterSpeed, 1).ToString("0.000");
                            }
                            else
                            {
                                current_WaterSpeed = fWaterSpeed.ToString("0.000");
                            }
                            current_WaterDirection = fWaterDir.ToString("0.0");
                        }
                    }
                    catch
                    {
                    }
                    #endregion

                    #region GPS GGA
                    //if ("GPS GGA" == labelVesselRef.Text && bGPSConnect)
                    try
                    {
                        GetAverageWaterSpeed_GPGGA(currentXposition - 1, ref VXsum, ref VYsum);
                        VXstore = VXsum;//LPJ 2015-11-2 当船速采用GPS VTG时，该值才可用
                        VYstore = VYsum;

                        AverageVXsave_GPGGA[GGAsaveCount] = VXstore; //LPJ 2016-8-25
                        AverageVYsave_GPGGA[GGAsaveCount] = VYstore;

                        fWaterDir = System.Math.Atan2(VXsum, VYsum);
                        if (fWaterDir < 0)
                            fWaterDir = fWaterDir / Math.PI * 180 + 360;
                        else
                            fWaterDir = fWaterDir / Math.PI * 180;
                        EnsemblesInfoToStore.WaterDir_GPGGA.Add(fWaterDir);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.WaterDir_GPGGA.Add(fWaterDir);

                        fWaterSpeed = Math.Sqrt(Math.Pow(VXsum, 2) + Math.Pow(VYsum, 2));
                        if (fWaterSpeed != 0)
                            fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed_GPGGA[currentXposition - 1] / fWaterSpeed;
                        EnsemblesInfoToStore.BoatWater_GPGGA.Add(fBoatWater);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.BoatWater_GPGGA.Add(fBoatWater);

                        if ("GPS GGA" == labelVesselRef.Text)
                        {
                            if (!bEnglish2Metric)  //LPJ 2016-8-26 显示当前选择船速的流速信息
                            {
                                current_WaterSpeed = projectUnit.MeterToFeet(fWaterSpeed, 1).ToString("0.000");
                            }
                            else
                            {
                                current_WaterSpeed = fWaterSpeed.ToString("0.000");
                            }
                            current_WaterDirection = fWaterDir.ToString("0.0");
                        }
                    }
                    catch
                    {
                    }
                    #endregion

                    #region null //LPJ 2016-8-15
                    //if (Resource1.String233 == labelVesselRef.Text)
                    try
                    {
                        GetAverageWaterSpeed_Null(currentXposition - 1, ref VXsum, ref VYsum);
                        VXstore = VXsum;//LPJ 2015-11-2 当船速采用GPS VTG时，该值才可用
                        VYstore = VYsum;

                        AverageVXsave_Null[GGAsaveCount] = VXstore; //LPJ 2016-8-25
                        AverageVYsave_Null[GGAsaveCount] = VYstore;

                        fWaterDir = System.Math.Atan2(VXsum, VYsum);
                        if (fWaterDir < 0)
                            fWaterDir = fWaterDir / Math.PI * 180 + 360;
                        else
                            fWaterDir = fWaterDir / Math.PI * 180;
                        EnsemblesInfoToStore.WaterDir_Null.Add(fWaterDir);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.WaterDir_Null.Add(fWaterDir);

                        fWaterSpeed = Math.Sqrt(Math.Pow(VXsum, 2) + Math.Pow(VYsum, 2));
                        //if (fWaterSpeed != 0)
                        //    fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed_Null[currentXposition - 1] / fWaterSpeed;
                        EnsemblesInfoToStore.BoatWater_Null.Add(0);
                        if (bStartMeasQ)
                            SaveEnsemblesInfo.BoatWater_Null.Add(0);

                        if (Resource1.String233 == labelVesselRef.Text)
                        {
                            if (!bEnglish2Metric)  //LPJ 2016-8-26 显示当前选择船速的流速信息
                            {
                                current_WaterSpeed = projectUnit.MeterToFeet(fWaterSpeed, 1).ToString("0.000");
                            }
                            else
                            {
                                current_WaterSpeed = fWaterSpeed.ToString("0.000");
                            }
                            current_WaterDirection = fWaterDir.ToString("0.0");
                        }
                    }
                    catch
                    {
                    }
                    #endregion

                    //LPJ 2013-8-2 将计算船速、水流速放在这里 -start
                    float fAveDepth = (float)EnsemblesInfoToStore.bottomDepth[currentXposition - 1];
                    if (!bEnglish2Metric)
                    {
                        current_Depth = projectUnit.MeterToFeet(fAveDepth, 1).ToString("0.00");
                    }
                    else
                    {
                        current_Depth = fAveDepth.ToString("0.00");
                    }
                  
                    //LPJ 2013-8-2 将计算船速、水流速放在这里 -end

                    ///////////////////////////////////////////////////////////////////////////////
                    //Modified 2011-8-19 add GPS data to EnsemblesInfoToStore the following way does not clear the EnsemblesInfoToStore
                    //Modified 2011-9-24 only the following way works. other wise EnsemblesInfoToStore data are not cleard
                    //JZH 2011-12-29 由于EnsemblesInfoToStore里面的数据不再清除，取消数据清除
                    //if (restoreNum == EnsemblesInfoToStore.UTMpoint.Count)
                    //{
                    //    EnsemblesInfoToStore.UTMpoint.RemoveAt(0);              //Modified 2011-9-23
                    //}
                    GGAsave[GGAsaveCount] = GPS_GGAbuffer; //LPJ 2012-8-9 移到前面
                    EnsemblesInfoToStore.GPS_GGAbuffer.Add(GPS_GGAbuffer);   //LPJ 2012-8-9 移到前面

                    ComputeXYposition(GPS_GGAbuffer); //recorde mode //LPJ 2012-8-9 解析GPS经纬度坐标

                    EnsemblesInfoToStore.UTMpoint.Add(UTMpoint);
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.UTMpoint.Add(UTMpoint);

                    //if (restoreNum == EnsemblesInfoToStore.GPS_latitude.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_latitude.RemoveAt(0);          //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.GPS_latitude.Add(GPS_FloatLatitude);       //Modified 2011-9-21
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_latitude.Add(GPS_FloatLatitude);

                    //GGAsave[GGAsaveCount] = GPS_GGAbuffer; //LPJ 2012-8-9 移到前面
                    //if (restoreNum == EnsemblesInfoToStore.GPS_longitude.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_longitude.RemoveAt(0);         //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.GPS_longitude.Add(GPS_FloatLongitude);     //Modified 2011-9-21
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_longitude.Add(GPS_FloatLongitude); 

                    //if (restoreNum == EnsemblesInfoToStore.gpsShipSpeed.Count)
                    //{
                    //    EnsemblesInfoToStore.gpsShipSpeed.RemoveAt(0);          //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.gpsShipSpeed.Add(gpsShipSpeed);            //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.gpsShipSpeed.Add(gpsShipSpeed);

                    //if (restoreNum == EnsemblesInfoToStore.GPS_HDT.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_HDT.RemoveAt(0);               //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.GPS_HDT.Add(GPS_HDT);                      //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_HDT.Add(GPS_HDT); 

                    //if (restoreNum == EnsemblesInfoToStore.VXstore.Count)
                    //{
                    //    EnsemblesInfoToStore.VXstore.RemoveAt(0);               //Modified 2011-9-18 
                    //}
                    EnsemblesInfoToStore.VXstore.Add(VXstore);                      //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.VXstore.Add(VXstore);   

                    //AverageVXsave[GGAsaveCount] = VXstore;
                    //if (restoreNum == EnsemblesInfoToStore.VYstore.Count)
                    //{
                    //    EnsemblesInfoToStore.VYstore.RemoveAt(0);               //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.VYstore.Add(VYstore);                      //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.VYstore.Add(VYstore);

                    //AverageVYsave[GGAsaveCount] = VYstore;
                    //if (restoreNum == EnsemblesInfoToStore.GPS_GGAbuffer.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_GGAbuffer.RemoveAt(0);         //Modified 2011-9-18
                    //}
                    //EnsemblesInfoToStore.GPS_GGAbuffer.Add(GPS_GGAbuffer);          //Modified 2011-9-18 //LPJ 2012-8-9 移到前面
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_GGAbuffer.Add(GPS_GGAbuffer);

                    //GGAsave[GGAsaveCount] = GPS_GGAbuffer;           //LPJ 2012-8-9 取消，与前面重复
                    //if (restoreNum == EnsemblesInfoToStore.GPS_VTGbuffer.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_VTGbuffer.RemoveAt(0);         //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.GPS_VTGbuffer.Add(GPS_VTGbuffer);          //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_VTGbuffer.Add(GPS_VTGbuffer);

                    //if (restoreNum == EnsemblesInfoToStore.GPS_HDTbuffer.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_HDTbuffer.RemoveAt(0);         //Modified 2011-9-18
                    //}
                    EnsemblesInfoToStore.GPS_HDTbuffer.Add(GPS_HDTbuffer);          //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_HDTbuffer.Add(GPS_HDTbuffer);  

                    //if (restoreNum == EnsemblesInfoToStore.GPS_ROTbuffer.Count)
                    //{
                    //    EnsemblesInfoToStore.GPS_ROTbuffer.RemoveAt(0);
                    //}
                    EnsemblesInfoToStore.GPS_ROTbuffer.Add(GPS_ROTbuffer);          //Modified 2011-9-18
                    //if(bStartMeasQ)   //LPJ 2012-5-4
                    //    SaveEnsemblesInfo.GPS_ROTbuffer.Add(GPS_ROTbuffer);

                    if (bStartMeasQ) //LPJ 2012-5-4
                    {
                        SaveEnsemblesInfo.UTMpoint.Add(UTMpoint);
                        SaveEnsemblesInfo.GPS_latitude.Add(GPS_FloatLatitude);
                        SaveEnsemblesInfo.GPS_longitude.Add(GPS_FloatLongitude);
                        SaveEnsemblesInfo.gpsShipSpeed.Add(gpsShipSpeed);
                        SaveEnsemblesInfo.GPS_HDT.Add(GPS_HDT);
                        SaveEnsemblesInfo.VXstore.Add(VXstore);
                        SaveEnsemblesInfo.VYstore.Add(VYstore);
                        SaveEnsemblesInfo.GPS_GGAbuffer.Add(GPS_GGAbuffer);
                        SaveEnsemblesInfo.GPS_VTGbuffer.Add(GPS_VTGbuffer);
                        SaveEnsemblesInfo.GPS_HDTbuffer.Add(GPS_HDTbuffer);
                        SaveEnsemblesInfo.GPS_ROTbuffer.Add(GPS_ROTbuffer);
                    }

                    LatitudeSave[GGAsaveCount] = GPS_FloatLatitude;  //Modified 2011-11-11 temp cancel
                    LongitudeSave[GGAsaveCount] = GPS_FloatLongitude;

                    GGAsaveCount++;  //record mode
                }

                callNum = currentXposition;


                //Modified 2011-12-16, find time gap between two pings
                currentInstrumentTime = (float)(EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1]);
                if (totalNum == 1)
                {
                    lastInstrumentTime = currentInstrumentTime;
                }
                InstrumentTimeElapse = currentInstrumentTime - lastInstrumentTime;
                if (InstrumentTimeElapse == 0)
                {
                    InstrumentTimeElapse = 1;
                }
                //InsInfotextBox.Text = "ping: " + totalNum.ToString() + 
                //    "\r\ncurrent Time: " + currentInstrumentTime.ToString() +
                //    "\r\nGap: " + InstrumentTimeElapse.ToString("0.000") +
                //    "\r\nLast Time: " + lastInstrumentTime.ToString();
                lastInstrumentTime = currentInstrumentTime;

                //JZH 2012-02-13 取消此处流量计算
                //Modified 2011-12-17, compute River Q
                //if (RiverQRecordStart)
                //{
                //    if(leftToRight)
                //    {
                //        if (leftDischargeStart)
                //        {
                //            //Modified 2011-12-17, do two things: 1, record left bank 20 times, 2 record the start point totalNum
                //            //leftBankStartNum = totalNum; //store this number to file
                //            leftDischargeCount++;

                //            RiverLeftBankFlowDataList.Add(DesignEnsembleData(RiverQArrayClass));

                //            textBoxLeftCount.Text = leftDischargeCount.ToString();

                //            if (leftDischargeCount == 10)
                //            {
                //                ComputeLeftBankFlow();

                //                if (RiverQLeftBankComputaionOkay)
                //                {
                //                    leftDischargeStart = false;
                //                    //MiddleRiverDischargeStart = true;
                //                }
                //            } 
                //        }
                //        if (rightDischargeStart)
                //        {
                //            rightDischargeCount++;
                //            RiverRightBankFlowDataList.Add(DesignEnsembleData(RiverQArrayClass));

                //            textBoxRightCount.Text = rightDischargeCount.ToString();

                //            if (rightDischargeCount == 10)
                //            {
                //                ComputeRightBankFlow();

                //                if (RiverQRightBankComputaionOkay)
                //                {
                //                    leftDischargeStart = false;
                //                    //MiddleRiverDischargeStart = false;
                //                }
                //            }
                //        }
                //        if (MiddleRiverDischargeStart)
                //        {
                //            RiverQMiddleCount++;
                //            textBoxMiddleCount.Text = RiverQMiddleCount.ToString();

                //            ComputeRiverFlow(DesignEnsembleData(RiverQArrayClass));
                //        }
                //    }
                //}

                //保存GPSdata000000.txt文件，当开始测量后才保存
                string GPSfileNam = "";
                String VXVYinfo = "$VXVY," + VXstore.ToString("0.000") + "," + VYstore.ToString("0.000") + "\r\n";
                String FileNumber = "#" + totalNum.ToString("000000") + "\r\n";
                String SaveFileNumber = "#" + MeasTotalNum.ToString("000000") + "\r\n"; //LPJ 2012-5-4 测量总数
                //Modified 2011-8-30, change to GPSdata000000.txt
                //GPSfileNam = newPath + "\\GPS" + "\\GPSdata" + CurrentGPSFileNumber.ToString("000000") + ".txt";
                //Version_2_CurrentGPSFileName = "GPSdata" + CurrentGPSFileNumber.ToString("000000") + ".txt";

                //LPJ 2012-5-4 保存GPS数据文件路径
                //GPSfileNam = newPath + "\\GPS" + "\\GPSdata" + SaveGPSFileNumber.ToString("000000") + ".txt";
                GPSfileNam = Path.Combine(newPath, ProjectFullName +  ".gps"); //LPJ 2014-7-29 更改GPS文件保存路径
                //Version_2_CurrentGPSFileName = "GPSdata" + SaveGPSFileNumber.ToString("000000") + ".txt";

                //string GPSfileNam = newPath + "\\GPS" + "\\GPSdata.txt";
                String addNum1 = "";

                //Modified 2011-8-9 dispaly and store GPS and Vx, Vy here ***************************
                if (bGPSConnect)
                {
                    GPSdisplayData = String.Empty;
                    GPSInfoData = String.Empty;
                    if (GPS_GGAbuffer != "")
                    {
                        GPSdisplayData += GPS_GGAbuffer;
                        GPSInfoData = GPSdisplayData;
                    }
                    else
                    {
                        GPSdisplayData += defaultGPGGA;
                        GPSInfoData = GPSdisplayData;
                    }
                    if (GPS_VTGbuffer != "")
                    {
                        GPSdisplayData += GPS_VTGbuffer;
                        GPSInfoData = GPSdisplayData;
                    }
                    else
                    {
                        GPSdisplayData += defaultGPVTG;
                        GPSInfoData = GPSdisplayData;
                    }

                    if (GPSCompass == false)
                    {
                        GPSdisplayData += "\r\n";
                        GPSInfoData = GPSdisplayData;
                    }
                    GPSdisplayData += GPS_HDTbuffer;
                    GPSInfoData = GPSdisplayData + "\r\n";
                    GPSInfoData += "\r\n";
                    GPSInfoData += "\r\n";
                    GPSInfoData += "\r\n";
                    GPSdisplayData += GPS_ROTbuffer;
                    GPSInfoData = GPSdisplayData;
                    GPSInfoData += "\r\n";

                    //String FileNumber = "#" + totalNum.ToString("000000") + "\r\n";
                    GPSdisplayData += VXVYinfo;
                    //string GPSfileNam = newPath + "\\GPS" + "\\GPSdata.txt";
                    //addNum = FileNumber + GPSdisplayData;  //Modified, 2011-8-9, ************************
                    //File.AppendAllText(GPSfileNam, addNum); //保存GPS数据
                    if (bStartMeasQ) //LPJ 2012-5-4 当开始测量后才开始保存GPSdata数据                  
                        File.AppendAllText(GPSfileNam, (SaveFileNumber + GPSdisplayData)); //保存GPS数据

                    addNum1 = FileNumber + GPSInfoData + VXVYinfo;

                 
                    //addNum = String.Empty;
                    //GPSstoredNumber++;

                    //ComputeXYposition(GPS_GGAbuffer); //recorde mode  //LPJ 2012-8-9 将提取GPS坐标移到保存EnsembleData前面
                }
                else
                {
                    addNum1 = FileNumber + VXVYinfo;
                //当连接GPS后才保存GPS数据
                    //if (bStartMeasQ) //LPJ 2012-5-4  当开始测量后才保存GPSdata                                            
                    //    File.AppendAllText(GPSfileNam, (SaveFileNumber + VXVYinfo)); //保存GPS数据

                    //addNum = String.Empty;
                }


                //LPJ 2012-5-4 保存palybackdata的info.infm文件，当开始测量后才保存
                if (bStartMeasQ)
                {
                    //Modified 2011-11-3, write info.Infm file every ping to prevent unexpected break. Verified works
                    string str = "";
                    //if (totalNum > 0)
                    //{
                    //    str = MaxVelocityByCostommer.ToString() + "\r\n" + totalNum.ToString();
                    //}
                    //LPJ 2012-5-4 
                    if (MeasTotalNum > 0)
                    {
                        str = MaxVelocityByCostommer.ToString() + "\r\n" + MeasTotalNum.ToString();
                    }
                    //MessageBox.Show(str);  //Modified 2011-11-3, number of 3
                    //File.WriteAllText(newPath + "\\PlaybackData\\" + "info.infm", str); //保存info.infm文件 //LPJ 2014-7-29 cancel
                }
            }
        }

        //LPJ 2012-10-11 add
        
        /*
        private void getWaterVelocity(ArrayClass Arr,ref Velocity[] velWater) //在测量模式下，计算绝对流速
        {
            int n = GetVelocityBins(Arr, 0);          //得到水单元层数           
            Velocity[] waterVel = new Velocity[n];    //定义一个数组，包含一次样本所有的水层速度

            Velocity Bv = new Velocity();
           
            Bv.VX = Arr.B_Earth[0]; //当选择低跟踪船速时
            Bv.VY = Arr.B_Earth[1];
            Bv.VZ = Arr.B_Earth[2];
            if (Bv.VX >= 80.0 || Bv.VY >= 80.0 || Bv.VZ >= 80.0)
            {
                Bv.VX = 0;
                Bv.VY = 0;
                Bv.VZ = 0;
            }
            
            for (int i = 0; i < n; i++)
            {
                waterVel[i].VX = Arr.Earth[0, i];
                waterVel[i].VY = Arr.Earth[1, i];
                waterVel[i].VZ = Arr.Earth[2, i];
                //绝对速度
                if (waterVel[i].VX <= 80.0 && waterVel[i].VY <= 80.0 && waterVel[i].VZ <= 80.0)
                {
                    waterVel[i].VX += Bv.VX;  //获取绝对速度
                    waterVel[i].VY += Bv.VY;
                    waterVel[i].VZ += Bv.VZ;
                }
            }
            velWater = waterVel; //LPJ 2013-7-3
        }
      */

        //LPJ 2012-10-11 该函数用于计算采集数据时的平均水流速，由于修复采集数据和回放数据的平均流速、总面积不一致的问题
        /*
        private void CalculateAverageWaterSpeedMeasured(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY, ref float fAverageDepth)
        {
            float VXvalue = 0;
            float VYvalue = 0;
            int iGoodBinNum = 0;    //数据组中深度有效单元数
            fAverageVX = 0;
            fAverageVY = 0;
            fAverageDepth = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //float RangeOfFirstBinDepth = 0;//EnsemblesInfoToStore.  //第一个单元距离换能器的起始位置
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = RTIdata[iEnsemblesNum].A_CellSize;
            //SM<
            float fBoatVelX = 0;
            float fBoatVelY = 0;
            //fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VX; //LPJ 2012-10-11
            //fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VY; //LPJ 2012-10-11
            fBoatVelX = RTIdata[iEnsemblesNum].B_Earth[0];   //LPJ 2012-10-11
            fBoatVelY = RTIdata[iEnsemblesNum].B_Earth[1];   //LPJ 2012-10-11
            if (fBoatVelY >= 88.0f || fBoatVelX >= 88.0f)
                fBoatVelY = fBoatVelX = 0;
            //fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum]; //LPJ 2012-10-11
            fAverageDepth = getAverageB_depth(RTIdata[iEnsemblesNum]);  //LPJ 2012-10-11
            //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
            //RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize);  //去掉底部盲区后的最大有效深度 注意目前方法为初步估计值，以后修正   //JZH 2012-05-22 cancel
            //RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));  //LPJ 2012-10-11
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - (RTIdata[iEnsemblesNum].A_FirstCellDepth - BinSize / 2.0f));   //LPJ 2012-10-11

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
            int iBinCount = 0;  //
            //iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数  //LPJ 2012-10-11
            iBinCount = GetVelocityBins(RTIdata[iEnsemblesNum], 0); //获取单元数    //LPJ　2012-10-11
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;
            int icountValid = 0;   //有效的单元数
            Velocity[] vel = new Velocity[iBinCount];  //LPJ 2012-10-11
            for (int icount = 0; icount < iGoodBinNum; icount++)
            {
                //VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VY);　//LPJ 2012-10-11
                //VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VX);　　//LPJ 2012-10-11

                getWaterVelocity(RTIdata[iEnsemblesNum],ref vel);  //LPJ 2012-10-11  //在测量模式下，采用计算后的绝对流速
                VYvalue = vel[icount].VY;    //LPJ 2012-10-11
                VXvalue = vel[icount].VX;　　//LPJ 2012-10-11


                //JZH 2012-05-18 改写该判断方法,该方法会导致有效剖面单元数偏小
                //if (VXvalue >= 88.0f || VYvalue >= 88.0f || icount > maxCells)
                //    break;
                //JZH 2012-05-18 新判断方法
                if (icount >= maxCells)
                {
                    break;
                }
                else if (VXvalue >= 88.0f || VYvalue >= 88.0f)
                {
                    continue;
                }
                icountValid++;
                fAverageVX += VXvalue;
                fAverageVY += VYvalue;
            }

            if (icountValid == 0)
            {
                fAverageVX = 0;
                fAverageVY = 0;
            }
            else
            {
                fAverageVX = fAverageVX / icountValid;
                fAverageVY = fAverageVY / icountValid;
                //fAverageVX = fAverageVX + fBoatVelX;   //JZH 2011-12-30 获取当前的绝对流速 参考底跟踪 注意：当底跟踪丢失后！！！！//JZH 2012-03-21  绝对速度已经在GetWaterVelocityToBottom中实现
                //fAverageVY = fAverageVY + fBoatVelY;   //JZH 2011-12-30 获取当前的绝对流速 参考底跟踪
            }
        }
        */
        /*
        private int CalGoodBinNumber(int iEnsemblesNum) //LPJ 2013-5-16
        {
            int iGoodBinNum = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
            //SM<
            float fBoatVelX = 0;
            float fBoatVelY = 0;
            float fAverageDepth = 0;

            fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VX;
            fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VY;
            if (fBoatVelY >= 88.0f || fBoatVelX >= 88.0f)
                fBoatVelY = fBoatVelX = 0;
            fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            int iBinCount = 0;  //
            iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;

            return iGoodBinNum;
        }
        */
        //JZH 2011-12-29 计算当前数据组平均流速，注意 参考：底跟踪 以后需要修改成参考：GPS，再做相应的修正
        private void CalculateAverageWaterSpeed(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY, ref float fAverageDepth)
        {
            float VXvalue = 0;
            float VYvalue = 0;
            int iGoodBinNum = 0;    //数据组中深度有效单元数
            fAverageVX = 0;
            fAverageVY = 0;
            fAverageDepth = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //float RangeOfFirstBinDepth = 0;//EnsemblesInfoToStore.  //第一个单元距离换能器的起始位置
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
            //SM<
            float fBoatVelX = 0;
            float fBoatVelY = 0;
            fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VX;
            fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VY;
            if (fBoatVelY >= 88.0f || fBoatVelX >= 88.0f)
                fBoatVelY = fBoatVelX = 0;
            fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
            //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
            //RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize);  //去掉底部盲区后的最大有效深度 注意目前方法为初步估计值，以后修正   //JZH 2012-05-22 cancel
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
            int iBinCount = 0;  //
            iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;

            int icountValid = 0;   //有效的单元数
            for (int icount = 0; icount < iGoodBinNum; icount++)
            {
                VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VX);
                //if(true) //LPJ 2013-7-31
                //{
                //     VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPS[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                //     VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPS[iEnsemblesNum])[icount].VX);
                //}

                //JZH 2012-05-18 改写该判断方法,该方法会导致有效剖面单元数偏小
                //if (VXvalue >= 88.0f || VYvalue >= 88.0f || icount > maxCells)
                //    break;
                //JZH 2012-05-18 新判断方法
                if (icount >= maxCells)
                {
                    break;
                }
                //else if (VXvalue >= 88.0f || VYvalue >= 88.0f)
                else if (Math.Abs(VXvalue) > 20 || Math.Abs(VYvalue) > 20)  //LPJ 2017-5-15
                {
                    continue;
                }
                icountValid++;
                fAverageVX += VXvalue;
                fAverageVY += VYvalue;
            }

            if (icountValid == 0)
            {
                fAverageVX = 0;
                fAverageVY = 0;
            }
            else
            {
                fAverageVX /= icountValid;
                fAverageVY /= icountValid;
                fAverageVX -= fBoatVelX;   //JZH 2011-12-30 获取当前的绝对流速 参考底跟踪 注意：当底跟踪丢失后！！！！//JZH 2012-03-21  绝对速度已经在GetWaterVelocityToBottom中实现
                fAverageVY -= fBoatVelY;   //JZH 2011-12-30 获取当前的绝对流速 参考底跟踪
            }
        }


        private int GetAverageWaterSpeed(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY)
        {
            try
            {
                float VXvalue = 0;
                float VYvalue = 0;
                int iGoodBinNum = 0;    //数据组中深度有效单元数
                fAverageVX = 0;
                fAverageVY = 0;

                float RangeOfMaxDepth = 0;     //最大有效数据单元深度
                //SM>
                //float BinSize = cellSize;               //单元尺寸
                float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
                //SM<

                float fBoatVelX = 0;
                float fBoatVelY = 0;
                fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VX;
                fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[iEnsemblesNum]).VY;
                if (fBoatVelY >= 88.0f || fBoatVelX >= 88.0f)
                    fBoatVelY = fBoatVelX = 0;
                float fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
                //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
                RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

                iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
                //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
                int iBinCount = 0;  //
                iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
                if (iGoodBinNum > iBinCount)
                    iGoodBinNum = iBinCount;

                int icountValid = 0;   //有效的单元数
                for (int icount = 0; icount < iGoodBinNum; icount++)
                {
                    VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                    VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterVelocity[iEnsemblesNum])[icount].VX);

                    if (icount >= iBinCount)
                    {
                        break;
                    }

                    //else if (VXvalue >= 88.0f || VYvalue >= 88.0f)
                    if (Math.Abs(VXvalue) > 20 || Math.Abs(VYvalue) > 20)  //LPJ 2016-12-6
                    {
                        continue;
                    }

                    icountValid++;
                    fAverageVX += VXvalue;
                    fAverageVY += VYvalue;
                }

                if (icountValid == 0)
                {
                    fAverageVX = 0;
                    fAverageVY = 0;
                }
                else
                {
                    fAverageVX /= icountValid;
                    fAverageVY /= icountValid;
                }
                return iGoodBinNum;
            }
            catch
            {
                return 0;
            }
        }

        private void GetAverageWaterSpeed_GPS(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY) //LPJ 2013-7-31
        {
            float VXvalue = 0;
            float VYvalue = 0;
            int iGoodBinNum = 0;    //数据组中深度有效单元数
            fAverageVX = 0;
            fAverageVY = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
            //SM<

            float fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
            //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
            int iBinCount = 0;  //
            iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;

            int icountValid = 0;   //有效的单元数
            for (int icount = 0; icount < iGoodBinNum; icount++)
            {
                try
                {
                    VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPS[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                    VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPS[iEnsemblesNum])[icount].VX);
                }
                catch
                {
                    continue;
                }

                if (icount >= iBinCount)
                {
                    break;
                }
                //else if (Math.Abs(VXvalue) >= 88.0f || VYvalue >= 88.0f)
                else if (Math.Abs(VXvalue) >20 || Math.Abs(VYvalue) >20)  //LPJ 2017-5-10
                {
                    continue;
                }
                icountValid++;
                fAverageVX += VXvalue;
                fAverageVY += VYvalue;
            }

            if (icountValid == 0)
            {
                fAverageVX = 0;
                fAverageVY = 0;
            }
            else
            {
                fAverageVX /= icountValid;
                fAverageVY /= icountValid;
            }
        }

        private void GetAverageWaterSpeed_GPGGA(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY) //LPJ 2013-7-31
        {
            float VXvalue = 0;
            float VYvalue = 0;
            int iGoodBinNum = 0;    //数据组中深度有效单元数
            fAverageVX = 0;
            fAverageVY = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
            //SM<

            float fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
            //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
            int iBinCount = 0;  //
            iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;

            int icountValid = 0;   //有效的单元数
            for (int icount = 0; icount < iGoodBinNum; icount++)
            {
                try
                {
                    VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                    VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[iEnsemblesNum])[icount].VX);
                }
                catch
                {
                    continue;
                }

                if (icount >= iBinCount)
                {
                    break;
                }
                //else if (VXvalue >= 88.0f || VYvalue >= 88.0f)
                else if (Math.Abs(VXvalue) > 20 || Math.Abs(VYvalue) > 20)  //LPJ 2017-5-10
                {
                    continue;
                }
                icountValid++;
                fAverageVX += VXvalue;
                fAverageVY += VYvalue;
            }

            if (icountValid == 0)
            {
                fAverageVX = 0;
                fAverageVY = 0;
            }
            else
            {
                fAverageVX /= icountValid;
                fAverageVY /= icountValid;
            }
        }

        private void GetAverageWaterSpeed_Null(int iEnsemblesNum, ref float fAverageVX, ref float fAverageVY) //LPJ 2013-7-31
        {
            float VXvalue = 0;
            float VYvalue = 0;
            int iGoodBinNum = 0;    //数据组中深度有效单元数
            fAverageVX = 0;
            fAverageVY = 0;

            float RangeOfMaxDepth = 0;     //最大有效数据单元深度
            //SM>
            //float BinSize = cellSize;               //单元尺寸
            float BinSize = (float)EnsemblesInfoToStore.BinSize[iEnsemblesNum];
            //SM<

            float fAverageDepth = (float)EnsemblesInfoToStore.bottomDepth[iEnsemblesNum];
            //JZH 2012-05-22 注意此方法不正确,应考虑第一个单元的起始位置!           
            RangeOfMaxDepth = (float)(fAverageDepth * (1 - 0.06) - BinSize - ((float)EnsemblesInfoToStore.RangeOfFirstBin[iEnsemblesNum] - BinSize / 2.0f));

            iGoodBinNum = (int)(RangeOfMaxDepth / BinSize);
            //JZH 2012-01-17 注意最大水深可能不是正确数据，或者最大水深超过最大流速测量单元深度！
            int iBinCount = 0;  //
            iBinCount = ((double[])EnsemblesInfoToStore.WaterSpeed[iEnsemblesNum]).Count(); //获取单元数
            if (iGoodBinNum > iBinCount)
                iGoodBinNum = iBinCount;

            int icountValid = 0;   //有效的单元数
            for (int icount = 0; icount < iGoodBinNum; icount++)
            {
                try
                {
                    VYvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_Null[iEnsemblesNum])[icount].VY); //WaterVelocity为绝对流速
                    VXvalue = (float)(((Velocity[])EnsemblesInfoToStore.WaterV_Null[iEnsemblesNum])[icount].VX);
                }
                catch
                {
                    continue;
                }

                if (icount >= iBinCount)
                {
                    break;
                }
                //else if (VXvalue >= 88.0f || VYvalue >= 88.0f)
                else if (Math.Abs(VXvalue) > 20 || Math.Abs(VYvalue) > 20)  //LPJ 2017-5-10
                {
                    continue;
                }
                icountValid++;
                fAverageVX += VXvalue;
                fAverageVY += VYvalue;
            }

            if (icountValid == 0)
            {
                fAverageVX = 0;
                fAverageVY = 0;
            }
            else
            {
                fAverageVX /= icountValid;
                fAverageVY /= icountValid;
            }
        }

        //JZH 2012-03-25 计算累计航迹长度参数

        //bool bNewEnsemble = false; //JZH 2012-03-26
     
        private void InfoPanel_Paint(object sender, PaintEventArgs e)
        {
            BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
            BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, InfoPanel.DisplayRectangle);
            using (Graphics g = MainBuffer.Graphics)
            {
                //g.FillRectangle(Brushes.Honeydew, InfoPanel.DisplayRectangle);
                g.FillRectangle(Brushes.White, InfoPanel.DisplayRectangle); //LPJ 2013-6-24
                
                 //if (true == SixColor.Checked)
                {
                    for (int num = 0; num <= 1275; num++)
                    {
                     //   float x = 470f * ((float)num / 1275) + 16;
                        float x = InfoPanel.Width * ((float)num / 1275); //LPJ 2013-6-22
                        Color c;
                        if (num <= 255)
                        {
                            c = Color.FromArgb(0, num, 255);
                        }
                        else if (num <= 510)
                        {
                            c = Color.FromArgb(0, 255, 510 - num);
                        }
                        else if (num <= 765)
                        {
                            c = Color.FromArgb(num - 510, 255, 0);
                        }
                        else if (num <= 1020)
                        {
                            c = Color.FromArgb(255, 1020 - num, 0);
                        }
                        else
                        {
                            c = Color.FromArgb(255, 0, num - 1020);
                        }
                        using (Pen p = new Pen(c))
                        {
                          //  p.Width = 470f / 1275;
                            p.Width = InfoPanel.Width / 1275; //LPJ 2013-6-22
                            g.DrawLine(p, x, 0, x, 16);
                            p.Dispose();
                        }
                    }
                    using (Font font = new Font("Arial", 8))
                    {
                        //SizeF size;
                        //float x;
                        //PointF pt;
                        //for (int n = 0; n <= 4; n++)
                        //{
                        //    size = g.MeasureString((n * trackBarMaxV.Value / 40f).ToString(), font);
                        //   // x = 16 - size.Width / 2 + n * 470f / 4f;
                        //    x = 2 - size.Width / 2 + n * InfoPanel.Width / 4f; //LPJ 2013-6-22
                        //    pt = new PointF(x, 16);
                        //    g.DrawString((n * trackBarMaxV.Value / 40f).ToString(), font, Brushes.Black, pt);
                        //}

                        //LPJ 2013-6-24
                        SizeF size = g.MeasureString((trackBarMaxV.Value / 40f).ToString("0.00"), font);

                        //if (Resource1.String237 == labelUnit.Text)
                        if (!bEnglish2Metric)
                        {
                            g.DrawString("0.00", font, Brushes.Black, new PointF(1, 16));
                            g.DrawString(projectUnit.MeterToFeet(trackBarMaxV.Value / 20f,1).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel.Width / 2f - size.Width / 2, 16));
                            g.DrawString(projectUnit.MeterToFeet(trackBarMaxV.Value / 10f,1).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel.Width - size.Width - 1, 16));

                            labelMavV.Text = (projectUnit.MeterToFeet(trackBarMaxV.Value / 10f, 1)).ToString("0.00") + "(ft/s)";
                        }
                        else
                        {
                            g.DrawString("0.00", font, Brushes.Black, new PointF(1, 16));
                            g.DrawString((trackBarMaxV.Value / 20f).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel.Width / 2f - size.Width / 2, 16));
                            g.DrawString((trackBarMaxV.Value / 10f).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel.Width - size.Width - 1, 16));
                        }

                    }
                }
            
              //  g.DrawRectangle(Pens.Black, 16, 0, 470f, 16);
                g.DrawRectangle(Pens.Black, 0, 0, InfoPanel.Width, 16);//LPJ 2013-6-22

                MainBuffer.Render(e.Graphics);
                g.Dispose();
                MainBuffer.Dispose();
            }
        }

        /*
        private byte ByteArrayToByte(byte[] packet)
        {
            return (packet[PacketPointer++]);
        }
        */
        private int ByteArrayToInt(byte[] packet)
        {
            ByteArrayToNumber.A = packet[PacketPointer++];
            ByteArrayToNumber.B = packet[PacketPointer++];
            ByteArrayToNumber.C = packet[PacketPointer++];
            ByteArrayToNumber.D = packet[PacketPointer++];

            return ByteArrayToNumber.Int;
        }
        private string ByteArrayToString(byte[] packet, int len)
        {
            string s = "";
            int i;
            for (i = 0; i < len; i++)
            {
                s += (char)packet[PacketPointer++];
            }
            return s;
        }
        private float ByteArrayToFloat(byte[] packet)
        {
            ByteArrayToNumber.A = packet[PacketPointer++];
            ByteArrayToNumber.B = packet[PacketPointer++];
            ByteArrayToNumber.C = packet[PacketPointer++];
            ByteArrayToNumber.D = packet[PacketPointer++];

            return ByteArrayToNumber.Float;
        }

        void DecodeEnsemble(byte[] packet, ArrayClass m, int PacketSize)
        {
            int SizeCount = 0;
            int ArrayCount = 0;

            m.VelocityAvailable = false;
            m.InstrumentAvailable = false;
            m.EarthAvailable = false;
            m.AmplitudeAvailable = false;
            m.CorrelationAvailable = false;
            m.BeamNAvailable = false;
            m.XfrmNAvailable = false;
            m.EnsembleDataAvailable = false;
            m.AncillaryAvailable = false;
            m.BottomTrackAvailable = false;
            m.NmeaAvailable = false;

            int i = 0;
            PacketPointer = HDRLEN;
            for (; i < MaxArray; i++)
            {
                m.Type[i] = ByteArrayToInt(packet);
                m.Bins[i] = ByteArrayToInt(packet);
                m.Beams[i] = ByteArrayToInt(packet);
                m.Imag[i] = ByteArrayToInt(packet);
                m.NameLen[i] = ByteArrayToInt(packet);
                m.Name[i] = ByteArrayToString(packet, 8);

                ArrayCount = m.Bins[i] * m.Beams[i];
                SizeCount = PacketPointer;

                if (VelocityID.Equals(m.Name[i], StringComparison.Ordinal))
                {
                    m.VelocityAvailable = true;
                    for (int beam = 0; beam < m.Beams[i]; beam++)
                    {
                        for (int bin = 0; bin < m.Bins[i]; bin++)
                        {
                            m.Velocity[beam, bin] = ByteArrayToFloat(packet);
                        }
                    }
                }
                else
                {
                    if (InstrumentID.Equals(m.Name[i], StringComparison.Ordinal))
                    {
                        m.InstrumentAvailable = true;

                        for (int beam = 0; beam < m.Beams[i]; beam++)
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                m.Instrument[beam, bin] = ByteArrayToFloat(packet);
                            }
                        }
                    }
                    else
                    {
                        if (EarthID.Equals(m.Name[i], StringComparison.Ordinal))
                        {
                            m.EarthAvailable = true;
                            for (int beam = 0; beam < m.Beams[i]; beam++)
                            {
                                for (int bin = 0; bin < m.Bins[i]; bin++)
                                {
                                    m.Earth[beam, bin] = ByteArrayToFloat(packet);
                                }
                            }
                        }
                        else
                        {
                            if (AmplitudeID.Equals(m.Name[i], StringComparison.Ordinal))
                            {
                                m.AmplitudeAvailable = true;
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    for (int bin = 0; bin < m.Bins[i]; bin++)
                                    {
                                        m.Amplitude[beam, bin] = ByteArrayToFloat(packet);
                                    }
                                }
                            }
                            else
                            {
                                if (CorrelationID.Equals(m.Name[i], StringComparison.Ordinal))
                                {
                                    m.CorrelationAvailable = true;
                                    for (int beam = 0; beam < m.Beams[i]; beam++)
                                    {
                                        for (int bin = 0; bin < m.Bins[i]; bin++)
                                        {
                                            m.Correlation[beam, bin] = ByteArrayToFloat(packet);
                                        }
                                    }
                                }
                                else
                                {
                                    if (BeamNID.Equals(m.Name[i], StringComparison.Ordinal))
                                    {
                                        m.BeamNAvailable = true;
                                        for (int beam = 0; beam < m.Beams[i]; beam++)
                                        {
                                            for (int bin = 0; bin < m.Bins[i]; bin++)
                                            {
                                                m.BeamN[beam, bin] = ByteArrayToInt(packet);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (XfrmNID.Equals(m.Name[i], StringComparison.Ordinal))
                                        {
                                            m.XfrmNAvailable = true;
                                            for (int beam = 0; beam < m.Beams[i]; beam++)
                                            {
                                                for (int bin = 0; bin < m.Bins[i]; bin++)
                                                {
                                                    m.XfrmN[beam, bin] = ByteArrayToInt(packet);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (EnsembleDataID.Equals(m.Name[i], StringComparison.Ordinal))
                                            {
                                                m.EnsembleDataAvailable = true;
                                                m.E_EnsembleNumber = ByteArrayToInt(packet);
                                                m.E_Cells = ByteArrayToInt(packet);
                                                m.E_Beams = ByteArrayToInt(packet);
                                                m.E_PingsInEnsemble = ByteArrayToInt(packet);
                                                m.E_PingCount = ByteArrayToInt(packet);
                                                m.E_Status = ByteArrayToInt(packet);
                                                ////////////////2010-01-14添加的改动////////////////
                                                m.YYYY = ByteArrayToInt(packet);
                                                m.MM = ByteArrayToInt(packet);
                                                m.DD = ByteArrayToInt(packet);
                                                m.HH = ByteArrayToInt(packet);
                                                m.mm = ByteArrayToInt(packet);
                                                m.SS = ByteArrayToInt(packet);
                                                m.hsec = ByteArrayToInt(packet);
                                                ///////////////////////////////////////////////////
                                            }
                                            else
                                            {
                                                if (AncillaryID.Equals(m.Name[i], StringComparison.Ordinal))
                                                {
                                                    m.AncillaryAvailable = true;
                                                    m.A_FirstCellDepth = ByteArrayToFloat(packet);
                                                    m.A_CellSize = ByteArrayToFloat(packet);
                                                    m.A_FirstPingSeconds = ByteArrayToFloat(packet);
                                                    m.A_LastPingSeconds = ByteArrayToFloat(packet);

                                                    m.A_Heading = ByteArrayToFloat(packet);
                                                    m.A_Pitch = ByteArrayToFloat(packet);
                                                    m.A_Roll = ByteArrayToFloat(packet);
                                                    m.A_WaterTemperature = ByteArrayToFloat(packet);
                                                    m.A_BoardTemperature = ByteArrayToFloat(packet);
                                                    m.A_Salinity = ByteArrayToFloat(packet);
                                                    m.A_Pressure = ByteArrayToFloat(packet);
                                                    m.A_Depth = ByteArrayToFloat(packet);
                                                    m.A_SpeedOfSound = ByteArrayToFloat(packet);
                                                }
                                                else
                                                {
                                                    if (BottomTrackID.Equals(m.Name[i], StringComparison.Ordinal))
                                                    {
                                                        m.BottomTrackAvailable = true;
                                                        m.B_FirstPingSeconds = ByteArrayToFloat(packet);
                                                        m.B_LastPingSeconds = ByteArrayToFloat(packet);
                                                        m.B_Heading = ByteArrayToFloat(packet);
                                                        m.B_Pitch = ByteArrayToFloat(packet);
                                                        m.B_Roll = ByteArrayToFloat(packet);
                                                        m.B_WaterTemperature = ByteArrayToFloat(packet);
                                                        m.B_BoardTemperature = ByteArrayToFloat(packet);
                                                        m.B_Salinity = ByteArrayToFloat(packet);
                                                        m.B_Pressure = ByteArrayToFloat(packet);
                                                        m.B_Depth = ByteArrayToFloat(packet);
                                                        m.B_SpeedOfSound = ByteArrayToFloat(packet);
                                                        m.B_Status = ByteArrayToFloat(packet);
                                                        m.B_Beams = ByteArrayToFloat(packet);
                                                        m.B_PingCount = ByteArrayToFloat(packet);

                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Range[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_SNR[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Amplitude[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Correlation[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Velocity[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_BeamN[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Instrument[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_XfrmN[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_Earth[beam] = ByteArrayToFloat(packet);
                                                        for (int beam = 0; beam < m.B_Beams; beam++)
                                                            m.B_EarthN[beam] = ByteArrayToFloat(packet);
                                                    }
                                                    else
                                                    {
                                                        if (NMEAID.Equals(m.Name[i], StringComparison.Ordinal))
                                                        {
                                                            m.NmeaAvailable = true;
                                                            int j = 0;
                                                            while (packet[PacketPointer] != 0)
                                                            {
                                                                //m.NMEA_Buffer[j++] = packet[PacketPointer];
                                                                m.NMEA_Buffer[j++] = packet[PacketPointer++]; //LPJ 2013-7-31
                                                                if (j >= 8192)
                                                                    break;
                                                            }
                                                            for (int end = j; end < 8192; end++)
                                                            {
                                                                m.NMEA_Buffer[end] = 0;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                SizeCount = (PacketPointer - SizeCount) / 4;
                if (SizeCount != ArrayCount)
                {
                    PacketPointer += 4 * (ArrayCount - SizeCount);
                }

                if (PacketPointer + 4 >= PacketSize)
                    break;
            }
            m.nArray = i + 1;
            if (i >= 11)
            {
                m.nArray = 11;
            }
            if (m.E_Cells < 1)
                m.E_Cells = 1;
            PacketPointer = 0;
        }

        Queue queue = new Queue();  //JZH 2012-03-21 添加一个队列用于串口数据接收
        private void sp_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            iAlarmTime = 0;
            try
            {
                byte[] pack = new byte[sp.BytesToRead];   //LPJ 2012-5-7  Bug：端口被关闭？？？？？？？？？
                //try
                //{
                sp.Read(pack, 0, pack.Length);
                lock (l)
                {
                    //recStr += Encoding.Default.GetString(pack);  //JZH 2012-03-21 
                    //JZH 2012-03-21 更新UpdateInfotextBox
                    if (StartRecord == false)
                    {
                        ReceiveBufferString += Encoding.Default.GetString(pack);
                        //InsInfotextBox.BeginInvoke(new System.EventHandler(UpdateInsInfotextBox), recStr);

                        //strTime += ReceiveBufferString; //LPJ 2013-10-30 从仪器读取时间 //LPJ 2014-6-17 cancel
                        //ReceiveBufferString = null;  //LPJ 2014-6-17 cancel
                    }
                    //recStr = null;  //JZH 2012-03-21
                    //}
                    //JZH 2012-03-21 新版本的串口数据接收及处理方法
                    else   //当数据开始记录时再将进行数据处理
                    {
                        try  //2012-6-2
                        {
                            lock (locknull)   //LPJ 2012-06-07
                            {
                                queue.Enqueue(pack);  //将接收到的串口数据放到队列中,数据解析在定时器时间中完成
                            }
                        }
                        catch
                        {

                        }
                    }
                }
            }
            catch
            {
            }
            #region cancel
            //}
            //catch
            //{
            //}
            //JZH 2012-03-21 旧版本的串口数据接收及处理方法
            //BytesArray.AddRange(pack);
            //lock (thisLock)
            //{
            //    BytesArray.AddRange(pack);
            //    bool bPause = true;  //JZH 2012-02-16 等待一次解析结束               
            //    while (bPause)
            //    {
            //       if(PickAndDecodeEnsemble_FunctionIsFree)
            //       {
            //           PickAndDecodeEnsemble_FunctionIsFree = false;
            //           this.BeginInvoke(DecodeBytesData);//委托指针指向 PickAndDecodeEnsemble 函数
            //    //        this.Invoke(DecodeBytesData);
            //    //        //this.EndInvoke(ir);
            //            bPause = false;   //JZH 2012-02-16 一次解析结束
            //            return;
            //        }
            //        else  //JZH 2012-02-16 如果解析未结束等待
            //       {
            //            Thread.Sleep(500);  
            //       }
            //    }
            //}
            #endregion
        }

        //int iCount = 0; //LPJ 2016-6-8 验证采集模块
        object locknull = new object();  //LPJ 2012-06-07   
        //JZH 2012-03-21 实时数据处理定时器事件
        private void RealTimeProcessingTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            lock (locknull)  //LPJ 2012-06-07  
            {
                while (queue.Count >= 1)  //当队列中有数据时，解队列到BytesArray中
                {
                    try    //LPJ 2012-6-2 
                    {
                        BytesArray.AddRange((byte[])(queue.Dequeue()));   //目标数组的长度不够。请检查 destIndex 和长度以及数组的下限。Bug 2012-5-31 
                    }
                    catch
                    {
                        queue.Clear();
                        break;
                    }
                }
            }

            #region 测试采集功能与回放显示的流速矢量棒是否一致，从文件读取原始数据 2016-6-8
            //try
            //{
            //    string[] files = Directory.GetFiles("C:\\rawData", "*.bin");
            //    Array.Sort(files);

            //    FileStream fs;
            //    try
            //    {
            //        //if (iCount >= files.Length)
            //        //    iCount = 0;
            //        fs = new FileStream(files[iCount++], FileMode.Open);
            //    }
            //    catch
            //    {
            //        return;
            //    }
            //    //获取文件大小
            //    long size = fs.Length;
            //    byte[] array = new byte[size];

            //    //将文件读到byte数组中
            //    fs.Read(array, 0, array.Length);
            //    fs.Close();
            //    BytesArray.AddRange(array);
            //}
            //catch
            //{
            //}
            #endregion

            if (BytesArray.Count >= 736 && StartRecord)  //有数据时且开始发射后开始解析   //JZH 2012-03-21 一个Ensemble的最小字节数为736
            {
                //lock (thisLock)   //JZH 2012-06-11
                try //LPJ 2013-6-5 bug
                {
                    if (PickAndDecodeEnsemble_FunctionIsFree)
                    {
                        PickAndDecodeEnsemble_FunctionIsFree = false;
                        this.BeginInvoke(DecodeBytesData);//委托指针指向 PickAndDecodeEnsemble 函数
                    }
                }
                catch
                {
                }
            }
            //else if (BytesArray.Count >= 736 && bStartGPSCalibration) //LPJ 2013-11-14 GPS安装校正时
            //{
            //    try 
            //    {
            //        if (PickAndDecodeEnsemble_FunctionIsFree)
            //        {
            //            PickAndDecodeEnsemble_FunctionIsFree = false;
            //            this.BeginInvoke(DecodeBytesDataGPS);//委托指针指向  函数
            //        }
            //    }
            //    catch
            //    {
            //    }
            //}
        }

     

        ////////////////////////////////////////////////////////////////////////////
        //20110621舟山测试，发现底跟踪深度数据为0，临时写了以下函数，以就急！以后注释掉
        private float getAverageB_depth(ArrayClass a)
        {
            float dep = 0;
            float lim = 0.00001f;
            int j = 0;
            for (int i = 0; i < 4; i++)
            {
                if (a.B_Range[i] >= lim && a.B_Correlation[i] >= 0.9)  //LPJ 2017-6-9 底跟踪相关性大于0.9，认为该水深数据可用
                {
                    dep += a.B_Range[i];
                    j++;
                }
            }
            return (j == 0) ? 0f : (dep / j);
        }

        //Modified 2011-12-17 add ArrayClass
        //ArrayClass RiverQArrayClass; // = new ArrayClass;

        //JZH 2012-04-09 航迹计算全局变量
        //bool bFirstGoodEnsemble = false;
        //double dLastGoodEnsembleTime = 0;
        //int iPrevGoodEnsemble = 0;
        //float fAccuEast = 0;
        //float fAccuNorth = 0;
        //float fAccuLength = 0;
        //float fAccuDisMG = 0;
        //double dCourMG = 0;

        //JZH 2012-04-09 流量计算全局变量
        //double dTopFlow = 0;
        //double dMeasuredFlow = 0;
        //double dBottomFlow = 0;
        //double dRightFlow = 0;
        //double dLeftFlow = 0;

        //JZH 2012-04-16 流量计算初始化数据
        List<ArrayClass> leftBank = new List<ArrayClass>();
        List<ArrayClass> rightBank = new List<ArrayClass>();
        ArrayList arrayListEastLength = new ArrayList();
        ArrayList arrayListNorthLength = new ArrayList();
        ArrayList arrayListBottomDepth = new ArrayList();

        int dLeftShorePings = 10; //LPJ 2013-5-29 左岸平均呯数
        int dRightShorePings = 10;  //LPJ 2013-5-29 右岸平均呯数

        //JZH 2012-04-18    实测面积、岸边面积全局变量
        //float fMeasArea = 0;   //实测面积
        //float fMeasRiverWidth = 0;
        //double dGRightShoreArea = 0.0;
        //double dGLeftShoreArea = 0.0;

        //JZH 2012-04-18 计算平均流向、岸边流量正负系数全局参数
        //float fGAccVx = 0;
        //float fGAccVy = 0;
        //double dGShoreVelDir = 0.0;  //JZH 2012-04-18 岸边流速方向 用来判断岸边流量正负
        //double dGShoreCoff = 1.0;  //JZH 2012-04-18 岸边流量系数 用来判断岸边流量正负
        //double dGMeanFlowDir = 0.0;
        //float fGAveDepth = 0;

        private int CurrentState = TRANSECT_STATE_STOP;
        private int CurrentEdge = 99;//"%d,%d,%d,%f"
        private int [] EdgeType = new int[2];
        private double [] EdgeDistance = new double[2];
        private double[] EdgeReference = new double[2];


        private void PickAndDecodeEnsemble()  //Used for record. 回放时不用此函数 Modified 2011-7-28 
        {
            //JZH 2012-03-21 更新窗口的工作转移到sp_DataReceived事件中完成
            //lock (l)
            //{
            //    if (StartRecord == false)
            //    {
            //        InsInfotextBox.AppendText(recStr); //Modified 2011-8-3   HHHHHHHH                    
            //        BytesArray.Clear();
            //        //startPrintIndicator = true;
            //        PickAndDecodeEnsemble_FunctionIsFree = true;  //JZH 2012-02-16 在解析数据前返回
            //        recStr = null;
            //        return;
            //    }
            //    recStr = null;  //JZH 2012-02-16 提前返回，移至返回前            
            //}

            //JZH 2012-02-16 改写pickEnsemble
            //bool bTryOneEnsemble = false;  //JZH 2012-02-16  是否完成一次解析尝试
            //while (BytesArray.Count > 0 && (!bTryOneEnsemble))
            //{
            try
            {
                if (!HasCheckedPayload)
                {
                    if (HeaderFlag == false)
                    {
                        if (BytesArray.Count >= preNum + 16)
                        {
                            int j = 0;
                            for (int i = preNum; i < BytesArray.Count; i++)
                            {
                                if (BytesArray[i] == null)   //LPJ 2012-6-2 判断是否有空
                                {
                                    continue;
                                }
                                if (0x80 == (byte)BytesArray[i])
                                    HeaderFlagNum++;
                                else
                                {
                                    HeaderFlagNum = 0;
                                    HeaderFlag = false;
                                }

                                j++;
                                if (16 == HeaderFlagNum)
                                {
                                    HeaderFlag = true;
                                    break;
                                }
                            }
                            preNum += j;

                            if (HeaderFlag == true)
                            {
                                if (preNum - 16 > 0)
                                {
                                    lock (locknull)    //JZH 2012-06-11
                                    {
                                        BytesArray.RemoveRange(0, preNum - 16 /*- 28*/);
                                    }
                                }
                                HeaderFlagNum = 0;
                                preNum = 0;
                            }
                            //else  //JZH 2012-02-16 未找到数据头
                            //{
                            //    //BytesArray.RemoveRange(0, preNum);
                            //    bTryOneEnsemble = true;
                            //}
                        }
                        //else   //JZH 2012-02-16 数据长度不够，一次尝试解析结束
                        //{
                        //    bTryOneEnsemble = true;
                        //}
                    }
                    if (HeaderFlag == true)         //JZH 2012-03-21  在一次数据解析过程中完成
                    //else
                    {
                        if (BytesArray.Count >= 32)//第preNum + 25 至 preNum + 28位为Payload
                        {
                            //byte[] EsmN = new byte[4];
                            //byte[] _EsmN = new byte[4];
                            byte[] Lng = new byte[4];
                            byte[] _Lng = new byte[4];
                            for (int i = 0; i < 4; i++)
                            {
                                //EsmN[i] = (byte)BytesArray[16 + i];
                                //_EsmN[i] = (byte)BytesArray[20 + i];
                                Lng[i] = (byte)BytesArray[24 + i];
                                _Lng[i] = (byte)BytesArray[28 + i];
                            }
                            payloadLen = BitConverter.ToInt32(Lng, 0);
                            int _payloadLen = BitConverter.ToInt32(_Lng, 0);

                            //int IntEsmN = BitConverter.ToInt32(EsmN, 0);
                            //int _IntEsmN = BitConverter.ToInt32(_EsmN, 0);
                            //if (IntEsmN + 1 + _IntEsmN != 0)
                            //{
                            //    HeaderFlag = false;
                            //    HasCheckedPayload = false;
                            //    BytesArray.RemoveRange(0, 32);
                            //}
                            /*else*/
                            if ((payloadLen <= 0) || (payloadLen + 1 + _payloadLen != 0))//payloadLen必须为正，否则样本是错的
                            {
                                HeaderFlag = false;
                                HasCheckedPayload = false;
                                lock (locknull)   //JZH 2012-06-11
                                {
                                    BytesArray.RemoveRange(0, 32);
                                }
                            }
                            else
                                HasCheckedPayload = true;
                        }
                        //else  //JZH 2012-02-16 数据长度不够check payload
                        //{
                        //    bTryOneEnsemble = true;
                        //}
                    }
                }

                if ((BytesArray.Count >= 36 + payloadLen) && HasCheckedPayload)//PacketBytes = new byte[offset + EnsemblePacket.EnsembleHeader.Payload + 4],4为校验和的位数
                {
                    byte[] BytesPacket = new byte[payloadLen];
                    //int nullnum = 0;   //LPJ 2012-6-6
                    try   //LPJ 2012-6-2 
                    {
                        //LPJ 2012-6-11 cancle
                        BytesArray.CopyTo(32, BytesPacket, 0, payloadLen);  //源数组中至少有一个元素未能被向下转换到目标数组类型。Bug 2012-5-31
                        //int ip2 = 0;  //LPJ 2012-6-6 add     //JZH 2012-06-13 加锁后取消判断
                        //for (int ip = 32; ip < payloadLen + 32; ip++)
                        //{
                        //    if (BytesArray[ip] != null)
                        //        BytesPacket[ip2++] = (byte)BytesArray[ip];
                        //    else
                        //        nullnum++;    //判断空数据的个数
                        //}
                    }
                    catch
                    {
                        lock (locknull)  //LPJ 2012-06-12
                        {
                            BytesArray.RemoveRange(0, payloadLen + 36);
                        }
                        return;
                    }
                    //计算数据包除数据头、校验部分以外的所有数据校验和
                    byte[] ChksumBytes = new byte[4];
                    ChksumBytes = CRC16Chksum(BytesPacket);

                    //读取数据包中的校验和
                    byte[] CopyChksumBytes = new byte[4];
                    for (int i = payloadLen + 32; i < payloadLen + 36; i++)
                    {
                        CopyChksumBytes[i - payloadLen - 32] = (byte)BytesArray[i];
                    }

                    ArrayClass Arr = new ArrayClass();
                    //比较两个校验和是否相等
                    if (BytesEquals(ChksumBytes, CopyChksumBytes))
                    {
                        string CMD = "CRSTS " + CurrentState.ToString();
                        switch (CurrentState)
                        {
                            case TRANSECT_STATE_EDGE:
                                CMD += "," + CurrentEdge.ToString();
                                CMD += "," + EdgeType[CurrentEdge].ToString();
                                double dVal = EdgeDistance[CurrentEdge];
                                if (systSet.bEnglishUnit)
                                    dVal = projectUnit.FeetToMeter(dVal, 1);
                                CMD += "," + EdgeDistance[CurrentEdge].ToString("0.000");
                                break;
                        }
                        CMD += '\r';
                        sp.Write(CMD);

                        bool getArrSuccessful = true;
                        try
                        {
                            DecodeEnsemble(BytesPacket, Arr, payloadLen);

                            if (bBeamCheck)
                                ArrRaw.Add(Arr);//LPJ 2014-6-20 设置一个变量，用于存储解析的ArrayClass数据

                        }
                        catch
                        {
                            getArrSuccessful = false;
                        }
                        if (!playBackMode)
                        {

                        }
                        if (getArrSuccessful)
                        {
                            lock (locker1) //Modified 2011-11-4 found that GPS_receiveData is not used presently. Check getInfoFromNMEAData
                            {
                                //write GPS data to Ensemble from Dashuai, Modified 2011-7-25 ！！！
                                if (GPS_receiveData != null && GPS_receiveData != "")   //Playback GPS data display
                                {
                                    //string[] split = GPS_receiveData.Split('$'); //ModifiedModified
                                    //string GGA_str = split[1];
                                    //string[] gga = GGA_str.Split(','); 
                                    //string HDT_str = split[4];   //What is this?  Modified 2011-7-25， 索引超出了数组界限
                                    //string[] hdt = HDT_str.Split(',');
                                    //string HDT = hdt[1];

                                    //gpsTime =  gga[1];  //Modified add

                                    //theta = float.Parse(HDT) / 180.0 * Math.PI;
                                    //GPS_dataToEnsemble = GPS_receiveData;
                                }
                            }
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.RecivedTime.Count)
                            //{
                            //    EnsemblesInfoToStore.RecivedTime.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束
                            EnsemblesInfoToStore.RecivedTime.Add(Arr.A_FirstPingSeconds);
                            if (bStartMeasQ) SaveEnsemblesInfo.RecivedTime.Add(Arr.A_FirstPingSeconds); //LPJ 2012-5-4 

                            EnsemblesInfoToStore.Pitch.Add(Arr.A_Pitch);  //LPJ 2013-5-18 
                            if (bStartMeasQ) SaveEnsemblesInfo.Pitch.Add(Arr.A_Pitch);

                            EnsemblesInfoToStore.Roll.Add(Arr.A_Roll);  //LPJ 2013-5-18 
                            if (bStartMeasQ) SaveEnsemblesInfo.Roll.Add(Arr.A_Roll);

                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.RecivedDataTime.Count)
                            //{
                            //    EnsemblesInfoToStore.RecivedDataTime.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束


                            //////时间问题查找点 方, ModifiedModified HERE add GPS here?
                            //此“if - else”语句专为青岛客户预留
                            DateTime DT = System.DateTime.Now; //LPJ 2013-6-21 在smartPage页中，选择时间设置，仪器时间或电脑时间？？？？？？？？
                            //if (radioButtonGPSTime.Checked)//Fuck!!!青岛项目GPS罗经时间没提供年月日，故这里权宜之计，借用电脑获取的年月日，以后改！
                            //{
                            //    EnsemblesInfoToStore.RecivedDataTime.Add(
                            //        DT.Year.ToString() + "-" + DT.Month.ToString("00") + "-" + DT.Day.ToString("00") + " "
                            //        + gpsTime.Substring(0, 2) + ":" + gpsTime.Substring(2, 2) + ":" + gpsTime.Substring(4, 2));

                            //    if (bStartMeasQ)  //LPJ 2012-5-4
                            //        SaveEnsemblesInfo.RecivedDataTime.Add(DT.Year.ToString() + "-" + DT.Month.ToString("00") + "-" + DT.Day.ToString("00") + " "
                            //             + gpsTime.Substring(0, 2) + ":" + gpsTime.Substring(2, 2) + ":" + gpsTime.Substring(4, 2));
                            //}
                            //else if (radioButtonInsTime.Checked)
                            //{
                            //    EnsemblesInfoToStore.RecivedDataTime.Add(
                            //        Arr.YYYY.ToString() + "-" + Arr.MM.ToString("00") + "-" + Arr.DD.ToString("00") + " "
                            //        + Arr.HH.ToString("00") + ":" + Arr.mm.ToString("00") + ":" + Arr.SS.ToString("00"));

                            //    if (bStartMeasQ)  //LPJ 2012-5-4
                            //        SaveEnsemblesInfo.RecivedDataTime.Add(
                            //        Arr.YYYY.ToString() + "-" + Arr.MM.ToString("00") + "-" + Arr.DD.ToString("00") + " "
                            //        + Arr.HH.ToString("00") + ":" + Arr.mm.ToString("00") + ":" + Arr.SS.ToString("00"));
                            //}
                            //else//电脑时间
                            //if (bUsePCTime)  //LPJ 2017-2-14 采用仪器读取时间
                            //{
                            //    EnsemblesInfoToStore.RecivedDataTime.Add(
                            //       DT.Year.ToString() + "-" + DT.Month.ToString("00") + "-" + DT.Day.ToString("00") + " "
                            //       + DT.Hour.ToString("00") + ":" + DT.Minute.ToString("00") + ":" + DT.Second.ToString("00"));

                            //    if (bStartMeasQ)  //LPJ 2012-5-4
                            //        SaveEnsemblesInfo.RecivedDataTime.Add(
                            //       DT.Year.ToString() + "-" + DT.Month.ToString("00") + "-" + DT.Day.ToString("00") + " "
                            //       + DT.Hour.ToString("00") + ":" + DT.Minute.ToString("00") + ":" + DT.Second.ToString("00"));
                            //}
                            //else
                            {
                                EnsemblesInfoToStore.RecivedDataTime.Add(
                                   Arr.YYYY.ToString() + "-" + Arr.MM.ToString("00") + "-" + Arr.DD.ToString("00") + " "
                                   + Arr.HH.ToString("00") + ":" + Arr.mm.ToString("00") + ":" + Arr.SS.ToString("00"));

                                if (bStartMeasQ)  //LPJ 2012-5-4
                                    SaveEnsemblesInfo.RecivedDataTime.Add(
                                    Arr.YYYY.ToString() + "-" + Arr.MM.ToString("00") + "-" + Arr.DD.ToString("00") + " "
                                    + Arr.HH.ToString("00") + ":" + Arr.mm.ToString("00") + ":" + Arr.SS.ToString("00"));
                            }

                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.bottomDepth.Count)
                            //{
                            //    EnsemblesInfoToStore.bottomDepth.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束 

                            //EnsemblesInfoToStore.bottomDepth.Add(Arr.B_Depth);
                            EnsemblesInfoToStore.bottomDepth.Add(getAverageB_depth(Arr));
                            if (bStartMeasQ)  //LPJ 2012-5-4
                                SaveEnsemblesInfo.bottomDepth.Add(getAverageB_depth(Arr));

                            float time;
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.t.Count)
                            //{
                            //EnsemblesInfoToStore.t.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束

                            if (2 == EnsemblesInfoToStore.RecivedTime.Count)//第一个样本的时间间隔无法确定，尽是认为与第二个样本的时间差相同
                            {
                                time = (float)EnsemblesInfoToStore.RecivedTime[1] - (float)EnsemblesInfoToStore.RecivedTime[0];//时间差的绝对值
                                EnsemblesInfoToStore.t.Add(time);
                                EnsemblesInfoToStore.t.Add(time);

                                if (bStartMeasQ)  //LPJ 2012-5-4
                                {
                                    SaveEnsemblesInfo.t.Add(time);
                                    SaveEnsemblesInfo.t.Add(time);
                                }
                            }
                            else if (EnsemblesInfoToStore.RecivedTime.Count > 2)
                            {
                                time = (float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1]
                                    - (float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 2];//时间差的绝对值
                                EnsemblesInfoToStore.t.Add(time);

                                if (bStartMeasQ)  //LPJ 2012-5-4
                                    SaveEnsemblesInfo.t.Add(time);
                            }

                            #region LPJ 2016-8-10 当用户选择艏向参考外接罗盘时，将仪器坐标系数据重新转换为earth坐标系,????当没有接收到GPS数据时，还是用内置罗盘的艏向
                            if (labelHeadingRef.Text == Resource1.String231)
                            {
                                float fGPS_HDT = 0;
                                try
                                {
                                    string NMEA_buffer = "";
                                    string GPHDTbuffer = "";
                                    CDecodeGPS decodeGPS = new CDecodeGPS();
                                    if (bGPSConnect)
                                    {
                                        //fGPS_HDT = float.Parse(GPS_HDT);
                                        //NMEA_buffer = GPS_receiveData;
                                        GPHDTbuffer = GPS_HDTbuffer;
                                    }
                                    else
                                    {
                                        NMEA_buffer = Encoding.Default.GetString(Arr.NMEA_Buffer);
                                        decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPHDT", ref GPHDTbuffer);
                                    }

                                    decodeGPS.GPS_HDTdecode(GPHDTbuffer, ref fGPS_HDT);

                                    for (int i = 0; i < Arr.E_Cells; i++)
                                    {
                                        float fEarth = 0;
                                        float fNorth = 0;
                                        CalXYZ2ENU(Arr.Instrument[0, i], Arr.Instrument[1, i], Arr.Instrument[2, i], fGPS_HDT + (float)fHeadingOffset, Arr.A_Pitch, Arr.A_Roll, ref fEarth, ref fNorth);
                                        Arr.Earth[0, i] = fEarth;
                                        Arr.Earth[1, i] = fNorth;
                                    }

                                    #region  更新底跟踪流速  //LPJ 2017-5-10
                                    float fEarth_BT = 0;
                                    float fNorth_BT = 0;
                                    CalXYZ2ENU(Arr.B_Instrument[0], Arr.B_Instrument[1], Arr.B_Instrument[2], fGPS_HDT + (float)fHeadingOffset, Arr.B_Pitch, Arr.B_Roll, ref fEarth_BT, ref fNorth_BT);
                                    Arr.B_Earth[0] = fEarth_BT;
                                    Arr.B_Earth[1] = fNorth_BT;
                                    #endregion
                                }
                                catch
                                {
                                }
                            }
                            #endregion
                            #region 内接罗经时，改正磁偏角 //LPJ 2017-5-12
                            else
                            {
                                if (Math.Abs(fHeadingOffset) > 0.0000001)//LPJ 2017-5-16 当磁偏角不为0时，改正
                                {
                                    for (int i = 0; i < Arr.E_Cells; i++)
                                    {
                                        float fEarth = 0;
                                        float fNorth = 0;
                                        CalXYZ2ENU(Arr.Instrument[0, i], Arr.Instrument[1, i], Arr.Instrument[2, i], Arr.A_Heading + (float)fHeadingOffset, Arr.A_Pitch, Arr.A_Roll, ref fEarth, ref fNorth);
                                        Arr.Earth[0, i] = fEarth;
                                        Arr.Earth[1, i] = fNorth;
                                    }

                                    #region  更新底跟踪流速  //LPJ 2017-5-10
                                    float fEarth_BT = 0;
                                    float fNorth_BT = 0;
                                    CalXYZ2ENU(Arr.B_Instrument[0], Arr.B_Instrument[1], Arr.B_Instrument[2], Arr.B_Heading + (float)fHeadingOffset, Arr.B_Pitch, Arr.B_Roll, ref fEarth_BT, ref fNorth_BT);
                                    Arr.B_Earth[0] = fEarth_BT;
                                    Arr.B_Earth[1] = fNorth_BT;
                                    #endregion
                                }
                            }
                            #endregion

                            #region BT
                            GetBottomTrackVelocity(Arr);//, theta);
                            double fBx, fBy;
                            fBx = ((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VX;
                            fBy = ((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VY;
                            double boatSpeed = Math.Sqrt(Math.Pow
                                (((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VX, 2)
                                + Math.Pow(((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VY, 2));
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.BoatSpeed.Count)
                            //{
                            //    EnsemblesInfoToStore.BoatSpeed.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束
                            EnsemblesInfoToStore.BoatSpeed.Add(boatSpeed);
                            if (bStartMeasQ)  //LPJ 2012-5-4
                            {
                                SaveEnsemblesInfo.BoatSpeed.Add(boatSpeed);
                            }

                            double fBoatDir = System.Math.Atan2(fBx, fBy); //LPJ 2013-8-1 计算船方向
                            if (fBoatDir < 0)
                                fBoatDir = fBoatDir / Math.PI * 180 + 360;
                            else
                                fBoatDir = fBoatDir / Math.PI * 180;
                            EnsemblesInfoToStore.BoatDir.Add(fBoatDir);
                            if (bStartMeasQ)
                                SaveEnsemblesInfo.BoatDir.Add(fBoatDir);

                            GetWaterVelocityToBottom(Arr);//, theta); //计算绝对流速WaterVelocity

                            Velocity[] Vel = (Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1];
                            double[] waterSpeed = new double[Vel.Length];
                            int k = 0;
                            foreach (Velocity v in Vel)
                            {
                                waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                                k++;
                            }

                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------开始
                            //if (restoreNum == EnsemblesInfoToStore.WaterSpeed.Count)
                            //{
                            //    EnsemblesInfoToStore.WaterSpeed.RemoveAt(0);
                            //}
                            //JZH 2011-12-26  不要清除EnsemblesInfoToStore里面的数据 ------------结束

                            EnsemblesInfoToStore.WaterSpeed.Add(waterSpeed);
                            if (bStartMeasQ)  //LPJ 2012-5-4
                                SaveEnsemblesInfo.WaterSpeed.Add(waterSpeed);
                            //GetDepth(Arr);
                            #endregion

                            //LPJ 2013-7-31 当船速采用GPS VTG数据时，将E000011中的NEMA数据进行解析
                            #region GPS VTG
                            //if ("GPS VTG" == labelVesselRef.Text)
                            {
                                try
                                {
                                    string NMEA_buffer = "";
                                    string GPVTGbuffer = "";
                                    CDecodeGPS decodeGPS = new CDecodeGPS();
                                    if (bGPSConnect)
                                    {
                                        //NMEA_buffer =  GPS_receiveData;
                                        GPVTGbuffer = GPS_VTGbuffer;
                                    }
                                    else
                                    {
                                        NMEA_buffer = Encoding.Default.GetString(Arr.NMEA_Buffer);
                                        decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPVTG", ref GPVTGbuffer);
                                    }

                                    Velocity vGPS = new Velocity();
                                    float ve = 0, vn = 0;
                                    float GPS_boatspeed = 0;
                                    double GPS_angle = 0;
                                    decodeGPS.GPS_VTGdecode(GPVTGbuffer, ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn);

                                    //getDataFromNMEA_Buffer(NMEA_buffer, ref GPVTGbuffer);
                                    //if (GPVTGbuffer != "")
                                    //    getGPSBoatSpeed(GPVTGbuffer, ref ve, ref vn); //LPJ 2013-5-21
                                    //else if (checkBoxExternalGPSTest.Checked) //LPJ 2013-7-29 当选择从外接GPS获取船速时
                                    //    getGPSBoatSpeed((string)EnsemblesInfoToStore.GPS_VTGbuffer[EnsemblesInfoToStore.GPS_VTGbuffer.Count - 1], ref ve, ref vn);

                                    vGPS.VX = ve;
                                    vGPS.VY = vn;
                                    EnsemblesInfoToStore.BoatV_GPS.Add(vGPS);
                                    Velocity[] WaterVel = new Velocity[(int)Arr.E_Cells];
                                    GetWaterVelocityToBottom(Arr, vGPS, ref WaterVel); //计算绝对水流速
                                    EnsemblesInfoToStore.WaterV_GPS.Add(WaterVel);
                                    boatSpeed = Math.Sqrt(Math.Pow(vGPS.VX, 2) + Math.Pow(vGPS.VY, 2));
                                    fBoatDir = System.Math.Atan2(vGPS.VX, vGPS.VY); //LPJ 2013-8-1 计算船方向
                                    if (fBoatDir < 0)
                                        fBoatDir = fBoatDir / Math.PI * 180 + 360;
                                    else
                                        fBoatDir = fBoatDir / Math.PI * 180;

                                    EnsemblesInfoToStore.BoatSpeed_GPS.Add(boatSpeed);
                                    EnsemblesInfoToStore.BoatDir_GPS.Add(fBoatDir);

                                    k = 0;
                                    foreach (Velocity v in WaterVel)
                                    {
                                        waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                                        k++;
                                    }
                                    EnsemblesInfoToStore.WaterSpeed_GPS.Add(waterSpeed);

                                    if (bStartMeasQ)
                                    {
                                        SaveEnsemblesInfo.BoatV_GPS.Add(vGPS);
                                        SaveEnsemblesInfo.WaterV_GPS.Add(WaterVel);
                                        SaveEnsemblesInfo.BoatSpeed_GPS.Add(boatSpeed);
                                        SaveEnsemblesInfo.WaterSpeed_GPS.Add(waterSpeed);
                                    }
                                }
                                catch
                                {
                                }
                            }
                            #endregion
                            //LPJ 2013-7-31 end

                            #region 当底跟踪参考GPS GGA的数据
                            //if ("GPS GGA" == labelVesselRef.Text)
                            {
                                try
                                {
                                    string NMEA_buffer = "";
                                    string GPGGAbuffer = "";
                                    CDecodeGPS decodeGPS = new CDecodeGPS();
                                    if (bGPSConnect)
                                    {
                                        //NMEA_buffer = GPS_receiveData;
                                        GPGGAbuffer = GPS_GGAbuffer;
                                    }
                                    else
                                    {
                                        NMEA_buffer = Encoding.Default.GetString(Arr.NMEA_Buffer);
                                        decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPGGA", ref GPGGAbuffer);
                                    }

                                    string UTCtime = "", GPS_Long = "", GPS_Lat = "", GPS_NS = "", GPS_EW = "";
                                    decodeGPS.GPS_GGAdecode(GPGGAbuffer, ref UTCtime, ref GPS_Long, ref GPS_Lat, ref GPS_NS, ref GPS_EW);
                                    float fUTCtime = decodeGPS.GPS_Timedecode(UTCtime); //LPJ 2017-5-27 将GPS格式的hhmmss.ss时间转换为以s为单位的时间

                                    //将DDMM.mmmm转为DD.dddd的经纬度
                                    int degreeE1 = 0, minuteE1 = 0, degreeN1 = 0, minuteN1 = 0;
                                    double secondE1 = 0, secondN1 = 0;
                                    decodeGPS.TransferEarthCoordinate(double.Parse(GPS_Long), ref degreeE1, ref minuteE1, ref secondE1);
                                    decodeGPS.TransferEarthCoordinate(double.Parse(GPS_Lat), ref degreeN1, ref minuteN1, ref secondN1);
                                    double Longitude1 = degreeE1 + minuteE1 / 60.0 + secondE1 / 3600.0;
                                    double Latitude1 = degreeN1 + minuteN1 / 60.0 + secondN1 / 3600.0;

                                    if ("S" == GPS_NS)
                                        Latitude1 = -1 * Latitude1;
                                    if ("W" == GPS_EW)
                                        Longitude1 = -1 * Longitude1;

                                    EnsemblesInfoToStore.Latitude.Add(degreeN1.ToString() + "°" + minuteN1.ToString() + "'" + secondN1.ToString() + GPS_NS);
                                    EnsemblesInfoToStore.Longitude.Add(degreeE1.ToString() + "°" + minuteE1.ToString() + "'" + secondE1.ToString() + GPS_EW);
                                    if (bStartMeasQ)
                                    {
                                        SaveEnsemblesInfo.Latitude.Add(degreeN1.ToString() + "°" + minuteN1.ToString() + "'" + secondN1.ToString() + GPS_NS);
                                        SaveEnsemblesInfo.Longitude.Add(degreeE1.ToString() + "°" + minuteE1.ToString() + "'" + secondE1.ToString() + GPS_EW);
                                    }

                                    Velocity vGPS = new Velocity();
                                    //double gpgga_ve, gpgga_vn;
                                    float detT = 0;
                                    double Longitude2, Latitude2;
                                    //try
                                    //{
                                    //    Longitude2 = GPGGA_Longitude[GPGGA_Longitude.Count() - 1];
                                    //    Latitude2 = GPGGA_Latitude[GPGGA_Latitude.Count() - 1];
                                    //}
                                    //catch
                                    //{
                                    //    Longitude2 = Longitude1;
                                    //    Latitude2 = Latitude1;
                                    //}
                                    //try
                                    //{
                                    //    detT = float.Parse(UTCtime) - GPS_UTCTime[GPS_UTCTime.Count - 1];
                                    //}
                                    //catch
                                    //{
                                    //    detT = 0;
                                    //}

                                    if (EnsemblesInfoToStore.Latitude.Count < 1)
                                    {
                                        Longitude2 = Longitude1;
                                        Latitude2 = Latitude1;
                                        detT = 0;
                                    }
                                    else
                                    {
                                        Longitude2 = lastGPGGA_Longitude;
                                        Latitude2 = lastGPGGA_Latitude;

                                        detT = fUTCtime - lastGPS_UTCTime;  //LPJ 2016-8-25
                                        if (detT < 0) //LPJ 2017-5-27 当UTC时间跨天时，时间+86400
                                            detT += 86400;
                                    }

                                    if (detT < 0.00000001)
                                    {
                                        vGPS.VX = 0;
                                        vGPS.VY = 0;
                                    }
                                    else
                                    {
                                        //gpgga_ve = TransferGPS2Distance.GetDistance(Latitude1, Longitude1, Latitude1, Longitude2) / detT;
                                        //gpgga_vn = TransferGPS2Distance.GetDistance(Latitude1, Longitude2, Latitude2, Longitude2) / detT;

                                        //if (Latitude1 > Latitude2)
                                        //    gpgga_vn = -1 * gpgga_vn;
                                        //if (Longitude1 > Longitude2)
                                        //    gpgga_ve = -1 * gpgga_ve;

                                        //double Ve = TransferGPS2Distance.RotateX(gpgga_ve, gpgga_vn, fHeadingOffset);
                                        //double Vn = TransferGPS2Distance.RotateY(gpgga_ve, gpgga_vn, fHeadingOffset);

                                        double gps_speed = TransferGPS2Distance.GetDistance(Latitude2, Longitude2, Latitude1, Longitude1) / detT;
                                        double gps_angle = TransferGPS2Distance.GetDirection(Latitude1, Longitude1, Latitude2, Longitude2);

                                        double Ve = 0, Vn = 0;

                                        if (!double.IsNaN(gps_angle) && !double.IsNaN(gps_speed))  //LPJ 2016-12-15
                                        {
                                            Ve = gps_speed * Math.Sin(gps_angle);
                                            Vn = gps_speed * Math.Cos(gps_angle);
                                        }

                                        vGPS.VX = (float)Ve;
                                        vGPS.VY = (float)Vn;
                                    }

                                    EnsemblesInfoToStore.BoatV_GPGGA.Add(vGPS);
                                    Velocity[] WaterVel = new Velocity[(int)Arr.E_Cells];
                                    GetWaterVelocityToBottom(Arr, vGPS, ref WaterVel); //计算绝对水流速
                                    EnsemblesInfoToStore.WaterV_GPGGA.Add(WaterVel);
                                    boatSpeed = Math.Sqrt(Math.Pow(vGPS.VX, 2) + Math.Pow(vGPS.VY, 2));
                                    fBoatDir = System.Math.Atan2(vGPS.VX, vGPS.VY); //LPJ 2016-8-12 计算船方向
                                    if (fBoatDir < 0)
                                        fBoatDir = fBoatDir / Math.PI * 180 + 360;
                                    else
                                        fBoatDir = fBoatDir / Math.PI * 180;

                                    EnsemblesInfoToStore.BoatSpeed_GPGGA.Add(boatSpeed);
                                    EnsemblesInfoToStore.BoatDir_GPGGA.Add(fBoatDir);

                                    k = 0;
                                    foreach (Velocity v in WaterVel)
                                    {
                                        waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                                        k++;
                                    }
                                    EnsemblesInfoToStore.WaterSpeed_GPGGA.Add(waterSpeed);

                                    if (bStartMeasQ)
                                    {
                                        SaveEnsemblesInfo.BoatV_GPGGA.Add(vGPS);
                                        SaveEnsemblesInfo.WaterV_GPGGA.Add(WaterVel);
                                        SaveEnsemblesInfo.BoatSpeed_GPGGA.Add(boatSpeed);
                                        SaveEnsemblesInfo.WaterSpeed_GPGGA.Add(waterSpeed);
                                    }

                                    //GPS_UTCTime.Add(float.Parse(UTCtime));
                                    //GPGGA_Latitude.Add(Latitude1);
                                    //GPGGA_Longitude.Add(Longitude1);

                                    lastGPGGA_Latitude = Latitude1;
                                    lastGPGGA_Longitude = Longitude1;

                                    lastGPS_UTCTime = fUTCtime; //LPJ 2016-8-25
                                  
                                }
                                catch
                                {
                                }
                            }

                            #endregion

                            #region null
                            //if (Resource1.String233 == labelVesselRef.Text)
                            {
                                Velocity[] WaterVel = new Velocity[(int)Arr.E_Cells];
                                Velocity vNull = new Velocity();
                                vNull.VX = 0;
                                vNull.VY = 0;
                                GetWaterVelocityToBottom(Arr, vNull, ref WaterVel); //计算绝对水流速
                                EnsemblesInfoToStore.WaterV_Null.Add(WaterVel);
                                boatSpeed = 0;
                                fBoatDir = 0; //LPJ 2013-8-1 计算船方向

                                k = 0;
                                foreach (Velocity v in WaterVel)
                                {
                                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                                    k++;
                                }
                                EnsemblesInfoToStore.WaterSpeed_Null.Add(waterSpeed);

                                if (bStartMeasQ)
                                {
                                    SaveEnsemblesInfo.WaterV_Null.Add(WaterVel);
                                    SaveEnsemblesInfo.WaterSpeed_Null.Add(waterSpeed);
                                }
                            }
                            #endregion
                            //LPJ 2013-7-30 将船速计算放在这里--start
                            try
                            {
                                if (fBx <= 20 && fBy <= 20)
                                {
                                    if ("GPS VTG" == labelVesselRef.Text)
                                    {
                                        fBoatDir = (double)EnsemblesInfoToStore.BoatDir_GPS[EnsemblesInfoToStore.BoatDir_GPS.Count - 1];
                                        boatSpeed = (double)EnsemblesInfoToStore.BoatSpeed_GPS[EnsemblesInfoToStore.BoatSpeed_GPS.Count - 1];
                                    }
                                    else if ("GPS GGA" == labelVesselRef.Text)
                                    {
                                        fBoatDir = (double)EnsemblesInfoToStore.BoatDir_GPGGA[EnsemblesInfoToStore.BoatDir_GPGGA.Count - 1];
                                        boatSpeed = (double)EnsemblesInfoToStore.BoatSpeed_GPGGA[EnsemblesInfoToStore.BoatSpeed_GPGGA.Count - 1];
                                    }
                                    else if (Resource1.String233 == labelVesselRef.Text)
                                    {
                                        fBoatDir = (double)EnsemblesInfoToStore.BoatDir_Null[EnsemblesInfoToStore.BoatDir_Null.Count - 1];
                                        boatSpeed = 0;
                                    }
                                    else
                                    {
                                        fBoatDir = (double)EnsemblesInfoToStore.BoatDir[EnsemblesInfoToStore.BoatDir.Count - 1];
                                        boatSpeed = (double)EnsemblesInfoToStore.BoatSpeed[EnsemblesInfoToStore.BoatSpeed.Count - 1];
                                    }

                                    current_BoatDirection = fBoatDir.ToString("0.0");
                                    if (!bEnglish2Metric)
                                        current_BoatSpeed = projectUnit.MeterToFeet(boatSpeed, 1).ToString("0.000");
                                    else
                                        current_BoatSpeed = boatSpeed.ToString("0.000");
                                }
                                else
                                {
                                    current_BoatDirection = "Bad";
                                    current_BoatSpeed = "Bad";
                                }
                            }
                            catch
                            {
                                current_BoatDirection = "Bad";
                                current_BoatSpeed = "Bad";
                            }
                            //LPJ 2013-7-30 将船速计算放在这里--end

                            //GetVelocityToColor(Arr);
                            GetVelocityToColor();
                            //ChangeToNewRGB(); //修改颜色 //LPJ 2013-7-12
                            ChangeToNewRGB_Survey(); //LPJ 2016-8-15 在采集过程中，不用全部更新颜色，只更新新添加的

                            EnsemblesInfoToStore.ChangeNumSum++;
                            if (bStartMeasQ)  //LPJ 2012-5-4
                                SaveEnsemblesInfo.ChangeNumSum++;

                            totalNum++;
                            //Modified 2011-8-31, this is the time to store GPS @@@@@@@@@@@@@@@@

                            if (bStartMeasQ)
                                MeasTotalNum++;
                            //向GPSdata000000和info.infm中添加数据，当开始测量后才开始记录   
                            ComputeCombinedWaterVilocity(totalNum);   //Modified 2011-8-31 moved from DP300_Window_Paint (DPS and VX VY is not stored if not paint)


                            // QRev
                            // Count the ensemble if on the edge
                            if(_bIsQRevStartCounter)
                            {
                                // Start Edge Enabled
                                _qrevStartEnsCount++;
                            }
                            else if(_bIsQRevEndCounter)
                            {
                                // End Edge Enabled
                                _qrevEndEnsCount++;
                            }
                            else
                            {
                                // Moving Enabled
                                _qrevMovingEnsCount++;
                            }

                            //Modified 2011-12-17
                            //if (RiverQRecordStart)
                            //{
                            //    buttonRiverLeftDischarge.Enabled = true;
                            //    buttonRiverRightDischarge.Enabled = true;
                            //    buttonRiverLMiddleDischarge.Enabled = true;
                            //}
                            //else
                            //{
                            //    buttonRiverLeftDischarge.Enabled = false;
                            //    buttonRiverRightDischarge.Enabled = false;
                            //    buttonRiverLMiddleDischarge.Enabled = false;
                            //}
                            //Modified 2011-11-11 initialize the start position for Lat Long display
                            //if (totalNum < 10) //Modified 2011-11-8 //LPJ 2012-6-28 取消
                            if (System.Math.Abs(StartLatitude - GPS_FloatLatitude) > 10.0 || System.Math.Abs(StartLongitude - GPS_FloatLongitude) > 10.0) //LPJ 2012-6-28 修改，通过判断当前时刻GPS坐标与起始坐标的差值来确定绘图区显示的起始坐标位置
                            {
                                StartLatitude = GPS_FloatLatitude;
                                StartLongitude = GPS_FloatLongitude;
                                ComputeLatLongGridText(StartLatitude, StartLongitude);
                                ////double leftLongtudeOfDisplayArea;
                                ////double rightLongitudeOfDisplayArea;
                                ////double topLatitudeOfDisplayArea;
                                ////double bottomLatitudeOfDisplayArea;
                                //StartLongitude = GPS_FloatLongitude; //.ToString("0000.000");// GPS_longitude;
                                //leftLongitudeOfDisplayArea = StartLongitude - 0.4;
                                //rightLongitudeOfDisplayArea = leftLongitudeOfDisplayArea + 0.8;
                                //StartLatitude = GPS_FloatLatitude;
                                //topLatitudeOfDisplayArea = StartLatitude + 0.3;
                                //bottomLatitudeOfDisplayArea = topLatitudeOfDisplayArea - 0.7;
                                ////StartLongitudeText[3] = (string)StartLongitude.ToString("00000.000");
                                //for (int i = 0; i <= 8; i++)
                                //{
                                //    StartLongitudeText[i] = (string)(leftLongitudeOfDisplayArea + i * 0.1f).ToString("00000.000");
                                //    StartLatitudeText[i] = (string)(topLatitudeOfDisplayArea - i * 0.1f).ToString("0000.000");
                                //}
                            }

                            //label70Heading.Text = Arr.A_Heading.ToString("0.000"); //Modified 2011-7-21, add ToString display format
                            //label81Pitch.Text = Arr.A_Pitch.ToString("0.000"); //Modified 2011-7-21, add ToString display format
                            //if (Arr.A_Roll > 0)
                            //    label66Roll.Text = (180 - Arr.A_Roll).ToString("0.000");
                            //else
                            //    label66Roll.Text = (-180 - Arr.A_Roll).ToString("0.000");

                            //MainPanel.Refresh();
                            //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                            this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                            this.BeginInvoke(TrackPanel_Refresh);
                            //bNewEnsemble = true;    //JZH 2012-03-26 用来控制是否更新导航信息面板

                            //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16  JZH 2012-01-12
                            GPSdisplayPanel.Refresh(); //Modified 2011-9-15 for recording 
                            GPScontrolPanel.Refresh();
                            HPRpictureBox.Refresh();

                            //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                            //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                            //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                            //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                            //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                            //panelSerialTime.Refresh(); //LPJ 2013-9-22

                            this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

                            //if (EnsemblesInfoToStore.ChangeNumSum == restoreNum)//每接受restoreNum组样本数据，即序列化到二进制文件中
                            //{
                            //    fileNum++;
                            //   SaveAsBinaryFormat(EnsemblesInfoToStore, fileNum);   //保存playbackdata//part00000.dat数据
                            //   EnsemblesInfoToStore.ChangeNumSum = 0;
                            //}

                            //LPJ 2012-5-3 开始测量后才能够保存数据，bStartMeasQ为true
                            //if (SaveEnsemblesInfo.ChangeNumSum == restoreNum)   //LPJ 2014-7-29 cancel
                            //{
                            //    fileNum++;
                            //    SaveAsBinaryFormat(SaveEnsemblesInfo, fileNum);
                            //    ClearSaveEnsemblesGPSInfo();  //LPJ 2012-5-7 当存储数据超过restoreNum时
                            //    ClearSaveEnsemblesInfo();
                            //    SaveEnsemblesInfo.ChangeNumSum = 0;
                            //}

                            arrAmplitude = Arr.Amplitude;
                            arrCorrelation = Arr.Correlation;

                            pictureBox_W_A.Refresh();
                            pictureBox_W_C.Refresh();
                            //RiverQArrayClass = Arr;
                            this.BeginInvoke(WriteToDataPageEvent, Arr); //LPJ 2014-3-11
                            
                            if (bStartMeasQ)
                            {
                                RTIdata.Add(Arr);
                                //SM>
                                //CalDischarge_Survey(Arr, RTIdata.Count, EnsemblesInfoToStore, cellSize, ref dischargeMsg); //LPJ 2016-8-25 
                                CalDischarge_Survey(Arr, RTIdata.Count, EnsemblesInfoToStore, ref dischargeMsg);
                                //SM<
                            }

                            //LV_MeasuredQ_Paint(); //LPJ 2013-5-17 
                            this.BeginInvoke(RefreshDishargePanel);
                            this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
                            this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18
                        }

                        if (bStartMeasQ == true) //LPJ　2012-5-3　当开始测量后保存rawdata数据
                        {
                            byte[] rawPacket = new byte[payloadLen + 36];
                            BytesArray.CopyTo(0, rawPacket, 0, payloadLen + 36);
                            ByteArrayWriteToBinFile(rawPacket);//, fn);     //保存Bin数据
                            //fn++;
                        }
                    }
                    lock (locknull)   //JZH 2012-06-11
                    {
                        BytesArray.RemoveRange(0, payloadLen + 36);
                    }
                    HeaderFlag = false;
                    HasCheckedPayload = false;
                }
                //else  //JZH 2012-02-16 有效数据长度不够
                //{
                //    bTryOneEnsemble = true;
                //}
                //}
                PickAndDecodeEnsemble_FunctionIsFree = true;
            }
            catch
            {
            }
        }

        private void ByteArrayWriteToBinFile(byte[] rawBytesPacket)//, int fileNumber)
        {
            RiverPlaybackPath = Path.Combine(newPath, ProjectFullName); //Modified 2011-12-10
            using (FileStream fs = new FileStream(Path.Combine(newPath, _ensOutputFileName +  ".ens"), FileMode.Append)) //LPJ 2014-7-29
            //using (FileStream fs = new FileStream(newPath + "\\rawData" + "\\rawData" + fileNumber.ToString("0000000") + ".bin", FileMode.Create))
            {
                using (BinaryWriter w = new BinaryWriter(fs))
                {
                    for (int i = 0; i < rawBytesPacket.Length; i++)
                    {
                        w.Write(rawBytesPacket[i]);
                    }
                }
            }
        }

        /*
        private byte[] BinFileWriteToByteArray(int BinfileNumber, string path)
        {
            path += "\\rawData" + BinfileNumber.ToString("0000000") + ".bin";
            //try //Modified 2011-12-15, found that conflict to use "rawdata" at same time
            {
                using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))  //JZH debug
                //using(FileStream fs = new FileStream(path, FileMode.Open))
                {
                    using (BinaryReader r = new BinaryReader(fs))
                    {
                        byte[] binArray = new byte[fs.Length];
                        //try
                        {
                            r.Read(binArray, 0, binArray.Length);
                        }
                        //catch
                        //{
                        //}
                        return (binArray);
                    }
                }
            }
            //catch
            //{
            //    return null;
            //}
        }
        */
        private void WriteToDataPage(ArrayClass arr)
        {
            int n = GetVelocityBins(arr, 0);//得到水单元层数
            //Modified 2011-9-17 need to handle error
            Velocity[] v;
            try
            {
                // v = (Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1];
                v = (Velocity[])EnsemblesInfoToStore.WaterVelocity[BinDataEnsembleNum - 1];// JZH 2011-12-29
            }
            catch
            {
                return;
                //v = (Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 2];
            }

            //EarthWaterlistView.Items.Clear(); //LPJ 2013-6-13 使数据页不重新写数据，只是刷新改变的数据
            //BeamWaterlistView.Items.Clear(); //LPJ 2013-6-13
            //InstrmtWaterlistView.Items.Clear(); //LPJ 2013-6-13
            //EarthGdPnglistView.Items.Clear(); //LPJ 2013-6-13
            //BeamGdPnglistView.Items.Clear(); //LPJ 2013-6-13
            BEGdPngListview.Items.Clear();
            BIGPnglistView.Items.Clear();
            BBGPnglistView.Items.Clear();
            //WaterAmplitudelistView.Items.Clear(); //LPJ 2013-6-13
            BtmAmplitudelistView.Items.Clear();
            //WaterCorrelationlistView.Items.Clear();//LPJ 2013-6-13
            BtmCorrelationlistView.Items.Clear();

            labelBE_Vx.Text = arr.B_Earth[1].ToString("0.0000");
            labelBE_Vy.Text = arr.B_Earth[0].ToString("0.0000");
            labelBE_Vz.Text = arr.B_Earth[2].ToString("0.0000");
            labelBE_Vq.Text = arr.B_Earth[3].ToString("0.0000");
            labelBI_Vx.Text = arr.B_Instrument[0].ToString("0.0000");
            labelBI_Vy.Text = arr.B_Instrument[1].ToString("0.0000");
            labelBI_Vz.Text = arr.B_Instrument[2].ToString("0.0000");
            labelBI_Vq.Text = arr.B_Instrument[3].ToString("0.0000");
            labelBB0.Text = arr.B_Velocity[0].ToString("0.0000");
            labelBB1.Text = arr.B_Velocity[1].ToString("0.0000");
            labelBB2.Text = arr.B_Velocity[2].ToString("0.0000");
            labelBB3.Text = arr.B_Velocity[3].ToString("0.0000");

            for (int i = 1; i <= n; i++)
            {
                try //LPJ 2013-6-13
                {
                    EarthWaterlistView.Items[i-1].SubItems[0].Text =  i.ToString();
                    EarthWaterlistView.Items[i - 1].SubItems[1].Text = arr.Earth[0, i - 1].ToString("0.0000");
                    EarthWaterlistView.Items[i - 1].SubItems[2].Text = arr.Earth[1, i - 1].ToString("0.0000");
                    EarthWaterlistView.Items[i - 1].SubItems[3].Text = arr.Earth[2, i - 1].ToString("0.0000");
                    EarthWaterlistView.Items[i - 1].SubItems[4].Text = arr.Earth[3, i - 1].ToString("0.0000");

                    BeamWaterlistView.Items[i - 1].SubItems[0].Text = i.ToString();
                    BeamWaterlistView.Items[i - 1].SubItems[1].Text = arr.Velocity[0, i - 1].ToString("0.0000");
                    BeamWaterlistView.Items[i - 1].SubItems[2].Text = arr.Velocity[1, i - 1].ToString("0.0000");
                    BeamWaterlistView.Items[i - 1].SubItems[3].Text = arr.Velocity[2, i - 1].ToString("0.0000");
                    BeamWaterlistView.Items[i - 1].SubItems[4].Text = arr.Velocity[3, i - 1].ToString("0.0000");

                    InstrmtWaterlistView.Items[i - 1].SubItems[0].Text = i.ToString();
                    InstrmtWaterlistView.Items[i - 1].SubItems[1].Text = arr.Instrument[0, i - 1].ToString("0.0000");
                    InstrmtWaterlistView.Items[i - 1].SubItems[2].Text = arr.Instrument[1, i - 1].ToString("0.0000");
                    InstrmtWaterlistView.Items[i - 1].SubItems[3].Text = arr.Instrument[2, i - 1].ToString("0.0000");
                    InstrmtWaterlistView.Items[i - 1].SubItems[4].Text = arr.Instrument[3, i - 1].ToString("0.0000");


                    if (WaterAvgNum != 0)
                    {
                        // int WaterAvgNum = int.Parse(textWaterAvgNum.Text);
                        EarthGdPnglistView.Items[i - 1].SubItems[0].Text = i.ToString();
                        EarthGdPnglistView.Items[i - 1].SubItems[1].Text = (arr.XfrmN[1, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[1, i - 1].ToString("0") + ")";
                        EarthGdPnglistView.Items[i - 1].SubItems[2].Text = (arr.XfrmN[0, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[0, i - 1].ToString("0") + ")";
                        EarthGdPnglistView.Items[i - 1].SubItems[3].Text = (arr.XfrmN[2, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[2, i - 1].ToString("0") + ")";
                        EarthGdPnglistView.Items[i - 1].SubItems[4].Text = (arr.XfrmN[3, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[3, i - 1].ToString("0") + ")";
                   
                        //int WaterAvgNum = int.Parse(textWaterAvgNum.Text);
                        BeamGdPnglistView.Items[i - 1].SubItems[0].Text = i.ToString();
                        BeamGdPnglistView.Items[i - 1].SubItems[1].Text = (arr.BeamN[1, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[1, i - 1].ToString("0") + ")";
                        BeamGdPnglistView.Items[i - 1].SubItems[2].Text = (arr.BeamN[0, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[0, i - 1].ToString("0") + ")";
                        BeamGdPnglistView.Items[i - 1].SubItems[3].Text = (arr.BeamN[2, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[2, i - 1].ToString("0") + ")";
                        BeamGdPnglistView.Items[i - 1].SubItems[4].Text = (arr.BeamN[3, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[3, i - 1].ToString("0") + ")";
                    }

                    WaterAmplitudelistView.Items[i - 1].SubItems[0].Text = i.ToString();
                    WaterAmplitudelistView.Items[i - 1].SubItems[1].Text = arr.Amplitude[0, i - 1].ToString("0.00");
                    WaterAmplitudelistView.Items[i - 1].SubItems[2].Text = arr.Amplitude[1, i - 1].ToString("0.00");
                    WaterAmplitudelistView.Items[i - 1].SubItems[3].Text = arr.Amplitude[2, i - 1].ToString("0.00");
                    WaterAmplitudelistView.Items[i - 1].SubItems[4].Text = arr.Amplitude[3, i - 1].ToString("0.00");

                    WaterCorrelationlistView.Items[i - 1].SubItems[0].Text = i.ToString();
                    WaterCorrelationlistView.Items[i - 1].SubItems[1].Text = arr.Correlation[0, i - 1].ToString("0.00");
                    WaterCorrelationlistView.Items[i - 1].SubItems[2].Text = arr.Correlation[1, i - 1].ToString("0.00");
                    WaterCorrelationlistView.Items[i - 1].SubItems[3].Text = arr.Correlation[2, i - 1].ToString("0.00");
                    WaterCorrelationlistView.Items[i - 1].SubItems[4].Text = arr.Correlation[3, i - 1].ToString("0.00");
                }
                catch
                {
                    ListViewItem Eitem = new ListViewItem(i.ToString());
                    Eitem.SubItems.Add(arr.Earth[0, i - 1].ToString("0.0000"));//North  //
                    Eitem.SubItems.Add(arr.Earth[1, i - 1].ToString("0.0000"));//East
                    Eitem.SubItems.Add(arr.Earth[2, i - 1].ToString("0.0000"));
                    Eitem.SubItems.Add(arr.Earth[3, i - 1].ToString("0.0000"));//目前不知道怎么算大地坐标系下的水流Vq,以E00003的Vq为准
                    EarthWaterlistView.Items.Add(Eitem);
                   
                    ListViewItem Bitem = new ListViewItem(i.ToString());
                    Bitem.SubItems.Add(arr.Velocity[0, i - 1].ToString("0.0000"));
                    Bitem.SubItems.Add(arr.Velocity[1, i - 1].ToString("0.0000"));
                    Bitem.SubItems.Add(arr.Velocity[2, i - 1].ToString("0.0000"));
                    Bitem.SubItems.Add(arr.Velocity[3, i - 1].ToString("0.0000"));
                    BeamWaterlistView.Items.Add(Bitem);
               
                    ListViewItem Iitem = new ListViewItem(i.ToString());
                    Iitem.SubItems.Add(arr.Instrument[0, i - 1].ToString("0.0000"));
                    Iitem.SubItems.Add(arr.Instrument[1, i - 1].ToString("0.0000"));
                    Iitem.SubItems.Add(arr.Instrument[2, i - 1].ToString("0.0000"));
                    Iitem.SubItems.Add(arr.Instrument[3, i - 1].ToString("0.0000"));
                    InstrmtWaterlistView.Items.Add(Iitem);
               
                    ListViewItem EGdPngitem = new ListViewItem(i.ToString()); //LPJ 2013-6-3 用百分比显示测流 textWaterAvgNum
                    //if (textWaterAvgNum.Text != null && textWaterAvgNum.Text != "0")
                    if(WaterAvgNum!=0)
                    {
                        //int WaterAvgNum = int.Parse(textWaterAvgNum.Text);
                        EGdPngitem.SubItems.Add((arr.XfrmN[1, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[1, i - 1].ToString("0") + ")");
                        EGdPngitem.SubItems.Add((arr.XfrmN[0, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[0, i - 1].ToString("0") + ")");
                        EGdPngitem.SubItems.Add((arr.XfrmN[2, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[2, i - 1].ToString("0") + ")");
                        EGdPngitem.SubItems.Add((arr.XfrmN[3, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.XfrmN[3, i - 1].ToString("0") + ")");
                    }
                    EarthGdPnglistView.Items.Add(EGdPngitem);
               
                    ListViewItem BGdPngitem = new ListViewItem(i.ToString()); //LPJ 2013-6-3 用百分比显示
                    //BGdPngitem.SubItems.Add(arr.BeamN[1, i - 1].ToString());
                    //BGdPngitem.SubItems.Add(arr.BeamN[0, i - 1].ToString());
                    //BGdPngitem.SubItems.Add(arr.BeamN[2, i - 1].ToString());
                    //BGdPngitem.SubItems.Add(arr.BeamN[3, i - 1].ToString());
                    //if (textWaterAvgNum.Text != null && textWaterAvgNum.Text != "0")
                    if (WaterAvgNum != 0)
                    {
                        //int WaterAvgNum = int.Parse(textWaterAvgNum.Text);
                        BGdPngitem.SubItems.Add((arr.BeamN[1, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[1, i - 1].ToString("0") + ")");
                        BGdPngitem.SubItems.Add((arr.BeamN[0, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[0, i - 1].ToString("0") + ")");
                        BGdPngitem.SubItems.Add((arr.BeamN[2, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[2, i - 1].ToString("0") + ")");
                        BGdPngitem.SubItems.Add((arr.BeamN[3, i - 1] / (float)WaterAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.BeamN[3, i - 1].ToString("0") + ")");
                    }
                    BeamGdPnglistView.Items.Add(BGdPngitem);
               
                    ListViewItem WAitem = new ListViewItem(i.ToString());
                    WAitem.SubItems.Add(arr.Amplitude[0, i - 1].ToString("0.00"));
                    WAitem.SubItems.Add(arr.Amplitude[1, i - 1].ToString("0.00"));
                    WAitem.SubItems.Add(arr.Amplitude[2, i - 1].ToString("0.00"));
                    WAitem.SubItems.Add(arr.Amplitude[3, i - 1].ToString("0.00"));
                    WaterAmplitudelistView.Items.Add(WAitem);
                
                    ListViewItem WCitem = new ListViewItem(i.ToString());
                    WCitem.SubItems.Add(arr.Correlation[0, i - 1].ToString("0.00"));
                    WCitem.SubItems.Add(arr.Correlation[1, i - 1].ToString("0.00"));
                    WCitem.SubItems.Add(arr.Correlation[2, i - 1].ToString("0.00"));
                    WCitem.SubItems.Add(arr.Correlation[3, i - 1].ToString("0.00"));
                    WaterCorrelationlistView.Items.Add(WCitem);
                    
                }
            }

            ListViewItem BCitem = new ListViewItem("1");
            BCitem.SubItems.Add(arr.B_Correlation[0].ToString("0.00"));
            BCitem.SubItems.Add(arr.B_Correlation[1].ToString("0.00"));
            BCitem.SubItems.Add(arr.B_Correlation[2].ToString("0.00"));
            BCitem.SubItems.Add(arr.B_Correlation[3].ToString("0.00"));
            BtmCorrelationlistView.Items.Add(BCitem);

            ListViewItem BAitem = new ListViewItem("1");
            BAitem.SubItems.Add(arr.B_Amplitude[0].ToString("0.00"));
            BAitem.SubItems.Add(arr.B_Amplitude[1].ToString("0.00"));
            BAitem.SubItems.Add(arr.B_Amplitude[2].ToString("0.00"));
            BAitem.SubItems.Add(arr.B_Amplitude[3].ToString("0.00"));
            BtmAmplitudelistView.Items.Add(BAitem);

            ListViewItem BEGdPngitem = new ListViewItem("1"); //LPJ 2013-6-3 添加百分比显示底跟踪
            //BEGdPngitem.SubItems.Add(arr.B_EarthN[1].ToString());
            //BEGdPngitem.SubItems.Add(arr.B_EarthN[0].ToString());
            //BEGdPngitem.SubItems.Add(arr.B_EarthN[2].ToString());
            //BEGdPngitem.SubItems.Add(arr.B_EarthN[3].ToString());
            //if (textWaterAvgNum.Text != null && textWaterAvgNum.Text != "0")
            if (WaterAvgNum != 0)
            {
                //int BottomAvgNum = int.Parse(textWaterAvgNum.Text) / 10 + 1;
                int BottomAvgNum = WaterAvgNum / 10 + 1;
                BEGdPngitem.SubItems.Add((arr.B_EarthN[1] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_EarthN[1].ToString("0") + ")");
                BEGdPngitem.SubItems.Add((arr.B_EarthN[0] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_EarthN[1].ToString("0") + ")");
                BEGdPngitem.SubItems.Add((arr.B_EarthN[2] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_EarthN[1].ToString("0") + ")");
                BEGdPngitem.SubItems.Add((arr.B_EarthN[3] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_EarthN[1].ToString("0") + ")");
            }
            BEGdPngListview.Items.Add(BEGdPngitem);

            ListViewItem BIGdPngitem = new ListViewItem("1");  //LPJ 2013-6-3 用百分比显示
            //BIGdPngitem.SubItems.Add(arr.B_XfrmN[1].ToString());
            //BIGdPngitem.SubItems.Add(arr.B_XfrmN[0].ToString());
            //BIGdPngitem.SubItems.Add(arr.B_XfrmN[2].ToString());
            //BIGdPngitem.SubItems.Add(arr.B_XfrmN[3].ToString());
            //if (textWaterAvgNum.Text != null && textWaterAvgNum.Text != "0")
            if (WaterAvgNum != 0)
            {
                //int BottomAvgNum = int.Parse(textWaterAvgNum.Text) / 10 + 1;
                int BottomAvgNum = WaterAvgNum / 10 + 1;
                BIGdPngitem.SubItems.Add((arr.B_XfrmN[1] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_XfrmN[1].ToString("0") + ")");
                BIGdPngitem.SubItems.Add((arr.B_XfrmN[0] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_XfrmN[1].ToString("0") + ")");
                BIGdPngitem.SubItems.Add((arr.B_XfrmN[2] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_XfrmN[1].ToString("0") + ")");
                BIGdPngitem.SubItems.Add((arr.B_XfrmN[3] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_XfrmN[1].ToString("0") + ")");
            }
            BIGPnglistView.Items.Add(BIGdPngitem);

            ListViewItem BBGdPngitem = new ListViewItem("1");   //LPJ 2013-6-3 用百分比显示
            //BBGdPngitem.SubItems.Add(arr.B_BeamN[1].ToString());
            //BBGdPngitem.SubItems.Add(arr.B_BeamN[0].ToString());
            //BBGdPngitem.SubItems.Add(arr.B_BeamN[2].ToString());
            //BBGdPngitem.SubItems.Add(arr.B_BeamN[3].ToString());
            //if (textWaterAvgNum.Text != null && textWaterAvgNum.Text != "0")
            if (WaterAvgNum != 0)
            {
                //int BottomAvgNum = int.Parse(textWaterAvgNum.Text) / 10 + 1;
                int BottomAvgNum = WaterAvgNum / 10 + 1;
                BBGdPngitem.SubItems.Add((arr.B_BeamN[1] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_BeamN[1].ToString("0") + ")");
                BBGdPngitem.SubItems.Add((arr.B_BeamN[0] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_BeamN[1].ToString("0") + ")");
                BBGdPngitem.SubItems.Add((arr.B_BeamN[2] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_BeamN[1].ToString("0") + ")");
                BBGdPngitem.SubItems.Add((arr.B_BeamN[3] / (float)BottomAvgNum * 100.0f).ToString("0") + "%" + "(" + arr.B_BeamN[1].ToString("0") + ")");
            }
            BBGPnglistView.Items.Add(BBGdPngitem);

            try
            {
                if (playBackMode == false)  //LPJ 2013-8-20
                {
                    //if (bGPSConnect)
                    //{
                    //    labelNo.Text = totalNum.ToString() + " GPS(" + GPSstoredNumber.ToString() + ")";
                    //}
                    //else
                    //{
                    //    labelNo.Text = MeasTotalNum.ToString();
                    //}
                    labelNo.Text = totalNum.ToString(); //LPJ 2016-12-15
                }
                else
                {
                    labelNo.Text = BinDataEnsembleNum.ToString();
                }
                labelTime.Text = NumToTime(((float)arr.A_FirstPingSeconds - (float)EnsemblesInfoToStore.RecivedTime[0]) * 1000).ToString(); //LPJ 2013-8-20
            }
            catch
            {
                labelTime.Text = current_TotalTimelabel;//数据页的时间标签
                labelNo.Text = current_EsambleTotaleNum;
            }

            labelSysTmp.Text = arr.A_BoardTemperature.ToString("0.000"); //Modified 2011-7-21, add ToString format
            if (0 == arr.E_Status)
                labelWPStutas.Text = "Good";
            else if (32768 == arr.E_Status)
                labelWPStutas.Text = "Hardware Timeout";
            labelWPTmp.Text = arr.A_WaterTemperature.ToString("0.000");
            labelWPSSpd.Text = arr.A_SpeedOfSound.ToString("0.000");
            //labelWPSalinity.Text = arr.A_Salinity.ToString("0.000"); //Modified 2011-7-21 try
            //labelWPSalinity.Text = textWaterSalinity.Text;
            labelWPPressure.Text = arr.A_Pressure.ToString("0.000");
            labelWPBeams.Text = arr.E_Beams.ToString();
            labelWPBins.Text = arr.E_Cells.ToString();
            labelTransDepth.Text = arr.A_Depth.ToString();
            labelFrtBinRange.Text = arr.A_FirstCellDepth.ToString("0.00");
            labelBinSize.Text = arr.A_CellSize.ToString("0.00");
            labelPingsD.Text = arr.E_PingsInEnsemble.ToString();
            labelPingsA.Text = arr.E_PingCount.ToString();
            labelFrtPingT.Text = arr.A_FirstPingSeconds.ToString();
            labelLastPingT.Text = arr.A_LastPingSeconds.ToString();
            
            current_WPHeading = arr.A_Heading.ToString("0.000"); //Modified 2011-7-21, add ToString display format
            current_WPPitch = arr.A_Pitch.ToString("0.000"); //Modified 2011-7-21, add ToString display format //LPJ 2013-5-18 change

            if (arr.A_Roll > 0)
                current_WPRoll = (180 - arr.A_Roll).ToString("0.000"); //Modified 2011-7-21, add ToString display format
            else
                current_WPRoll = (-180 - arr.A_Roll).ToString("0.000"); //Modified 2011-7-21, add ToString display format

            labelWPHeading.Text = current_WPHeading; //LPJ 2013-8-20
            labelWPPitch.Text = current_WPPitch;  //LPJ 2013-8-20
            labelWPRoll.Text = current_WPRoll;  //LPJ 2013-8-20

            if (0 == arr.B_Status)
                labelBTStutas.Text = "Good";
            else if (1 == arr.B_Status)
                labelBTStutas.Text = "Water Track 3 Beam Solution";
            else if (2 == arr.B_Status)
                labelBTStutas.Text = "Bottom Track 3 Beam Solution";
            else if (4 == arr.B_Status)
                labelBTStutas.Text = "Bottom Track Hold";
            else if (8 == arr.B_Status)
                labelBTStutas.Text = "Bottom Track Searching";
            else if (32768 == arr.B_Status)
                labelBTStutas.Text = "Hardware Timeout";
            labelBTSysTmp.Text = arr.B_BoardTemperature.ToString("0.000"); //Modified 2011-7-21 diaplay format
            labelBTWaterTmp.Text = arr.B_WaterTemperature.ToString("0.000");
            labelBTPressure.Text = arr.B_Pressure.ToString("0.000");
            //labelBTSalinity.Text = arr.B_Salinity.ToString("0.000"); Modified 2011-7-21 change to value from CWS 
            //labelBTSalinity.Text = textWaterSalinity.Text; ////ModifiedModified //LPJ 2013-6-22 cancel
            labelBTSoundSpd.Text = arr.B_SpeedOfSound.ToString("0.000");
            labelBTBeams.Text = arr.B_Beams.ToString();
            labelBTDepth.Text = arr.B_Depth.ToString("0.00");
            labelVRB0.Text = arr.B_Range[0].ToString("0.000");
            labelVRB1.Text = arr.B_Range[1].ToString("0.000");
            labelVRB2.Text = arr.B_Range[2].ToString("0.000");
            if (arr.B_Range.Length == 4)
                labelVRB3.Text = arr.B_Range[3].ToString("0.000");
            else
                labelVRB3.Text = "-";
            labelSNRB0.Text = arr.B_SNR[0].ToString("0.000");
            labelSNRB1.Text = arr.B_SNR[1].ToString("0.000");
            labelSNRB2.Text = arr.B_SNR[2].ToString("0.000");
            if (arr.B_SNR.Length == 4)
                labelSNRB3.Text = arr.B_SNR[3].ToString("0.000");
            else
                labelSNRB3.Text = "-";
            labelBTPings.Text = arr.B_PingCount.ToString();
            labelBTFstPingT.Text = arr.B_FirstPingSeconds.ToString("0.000");
            labelBTLastPingT.Text = arr.B_LastPingSeconds.ToString("0.000");
            labelBTHeading.Text = arr.B_Heading.ToString("0.000");
            labelBTPitch.Text = arr.B_Pitch.ToString("0.000");
            if (arr.B_Roll > 0)
                labelBTRoll.Text = (180 - arr.B_Roll).ToString("0.000");
            else
                labelBTRoll.Text = (-180 - arr.B_Roll).ToString("0.000");
        }

        private void SaveAsBinaryFormat(Object obj, int fileNum)
        {
            BinaryFormatter binFormat = new BinaryFormatter();
            using (Stream fStream = new FileStream(Path.Combine(newPath, ProjectFullName) + "\\PlaybackData\\part" + fileNum.ToString("0000000") + ".dat",
                FileMode.Create, FileAccess.Write, FileShare.None))
            {
                binFormat.Serialize(fStream, obj);
            }
        }

        /*
        private EnsemblesInfo LoadFromBinaryFile(string path)
        {
            BinaryFormatter binFormat = new BinaryFormatter();
            try
            {
                using (Stream fStream = File.OpenRead(path))
                {
                    return (EnsemblesInfo)binFormat.Deserialize(fStream);
                }
            }
            catch
            {
                return null;
            }
        }
        */
        private int GetVelocityBins(ArrayClass Arr, int flag)
        {
            int i;
            if (flag == 0)
            {
                for (i = 0; i < MaxArray; i++)
                {
                    if (VelocityID.Equals(Arr.Name[i], StringComparison.Ordinal))
                    {
                        return Arr.Bins[i];
                    }
                }
            }
            else if (flag == 1)
            {
                for (i = 0; i < MaxArray; i++)
                {
                    if (BottomTrackID.Equals(Arr.Name[i], StringComparison.Ordinal))
                    {
                        return Arr.Bins[i];
                    }
                }
            }
            return 0;
        }

        //JZH  2012-01-06 该方法未调用
        /*
        private int GetVelocityBeams(ArrayClass Arr, int flag)
        {
            int i;
            if (flag == 0)
            {
                for (i = 0; i < MaxArray; i++)
                {
                    if (VelocityID.Equals(Arr.Name[i], StringComparison.Ordinal))
                    {
                        return Arr.Beams[i];
                    }
                }
            }
            else if (flag == 1)
            {
                for (i = 0; i < MaxArray; i++)
                {
                    if (BottomTrackID.Equals(Arr.Name[i], StringComparison.Ordinal))
                    {
                        return Arr.Beams[i];
                    }
                }
            }
            return 0;
        }
        */
        /*
        private Velocity getHPR_Vel_B(ArrayClass Arr, Velocity v)
        {
            Velocity Vel = new Velocity();
            if (v.VX == 88.888F || v.VY == 88.888F || v.VZ == 88.888F)
            {
                Vel.VX = 88.888F;
                Vel.VY = 88.888F;
                Vel.VZ = 88.888F;
            }
            else
            {
                float HEADING, PITCH, ROLL;
                HEADING = (float)Math.PI * (Arr.B_Heading) / 180.0F;
                PITCH = (float)Math.PI * (Arr.B_Pitch) / 180.0F;
                if (Arr.B_Roll > 0)
                    ROLL = (float)Math.PI * (180 - Arr.B_Roll) / 180.0F;
                else
                    ROLL = (float)Math.PI * (-180 - Arr.B_Roll) / 180.0F;

                double SH = Math.Sin(HEADING);
                double CH = Math.Cos(HEADING);
                double SP = Math.Sin(PITCH);
                double CP = Math.Cos(PITCH);
                double SR = Math.Sin(ROLL);
                double CR = Math.Cos(ROLL);

                //Vel.VX = (float)(v.VX * (CH * CP) - v.VY * (SH * CR - CH * SR * SP) - v.VZ * (SH * SR + CH * SP * CR));
                //Vel.VY = (float)(v.VX * (SH * CP) - v.VY * (CH * CR + SH * SR * SP) + v.VZ * (CH * SR - SH * CR * SP));
                //Vel.VZ = (float)(v.VX * (SP) - v.VY * (SR * CP) + v.VZ * (CP * CR));
                //JZH 2012-03-21 更正转换
                Vel.VX = (float)(v.VX * (SH * CP) - v.VY * (CH * CR + SH * SR * SP) + v.VZ * (CH * SR - SH * CR * SP));
                Vel.VY = (float)(v.VX * (CH * CP) + v.VY * (SH * CR - CH * SR * SP) - v.VZ * (SH * SR + CH * SP * CR));
                Vel.VZ = (float)(v.VX * (SP) + v.VY * (SR * CP) + v.VZ * (CP * CR));
            }
            return Vel;
        }

        private Velocity getHPR_Vel_W(ArrayClass Arr, Velocity v)
        {
            Velocity Vel = new Velocity();
            if (v.VX == 88.888F || v.VY == 88.888F || v.VZ == 88.888F)
            {
                Vel.VX = 88.888F;
                Vel.VY = 88.888F;
                Vel.VZ = 88.888F;
            }
            else
            {
                float HEADING, PITCH, ROLL;
                HEADING = (float)Math.PI * (Arr.A_Heading) / 180.0F;
                PITCH = (float)Math.PI * (Arr.A_Pitch) / 180.0F;
                if (Arr.A_Roll > 0)
                    ROLL = (float)Math.PI * (180 - Arr.A_Roll) / 180.0F;
                else
                    ROLL = (float)Math.PI * (-180 - Arr.A_Roll) / 180.0F;

                double SH = Math.Sin(HEADING);
                double CH = Math.Cos(HEADING);
                double SP = Math.Sin(PITCH);
                double CP = Math.Cos(PITCH);
                double SR = Math.Sin(ROLL);
                double CR = Math.Cos(ROLL);

                //Vel.VX = (float)(v.VX * (CH * CP) - v.VY * (SH * CR - CH * SR * SP) - v.VZ * (SH * SR + CH * SP * CR));
                //Vel.VY = (float)(v.VX * (SH * CP) - v.VY * (CH * CR + SH * SR * SP) + v.VZ * (CH * SR - SH * CR * SP));
                //Vel.VZ = (float)(v.VX * (SP) - v.VY * (SR * CP) + v.VZ * (CP * CR));
                //JZH 2012-03-21 更正转换
                Vel.VX = (float)(v.VX * (SH * CP) - v.VY * (CH * CR + SH * SR * SP) + v.VZ * (CH * SR - SH * CR * SP));
                Vel.VY = (float)(v.VX * (CH * CP) + v.VY * (SH * CR - CH * SR * SP) - v.VZ * (SH * SR + CH * SP * CR));
                Vel.VZ = (float)(v.VX * (SP) + v.VY * (SR * CP) + v.VZ * (CP * CR));
            }
            return Vel;
        }

        private Velocity getPR_Vel_W(ArrayClass Arr, Velocity v)
        {
            Velocity Vel = new Velocity();
            if (v.VX == 88.888F || v.VY == 88.888F || v.VZ == 88.888F)
            {
                Vel.VX = 88.888F;
                Vel.VY = 88.888F;
                Vel.VZ = 88.888F;
            }
            else
            {
                float PITCH, ROLL;
                PITCH = (float)Math.PI * (Arr.A_Pitch) / 180.0F;
                if (Arr.A_Roll > 0)
                    ROLL = (float)Math.PI * (180 - Arr.A_Roll) / 180.0F;
                else
                    ROLL = (float)Math.PI * (-180 - Arr.A_Roll) / 180.0F;

                double SP = Math.Sin(PITCH);
                double CP = Math.Cos(PITCH);
                double SR = Math.Sin(ROLL);
                double CR = Math.Cos(ROLL);

                Vel.VX = (float)(v.VX * CP + v.VY * SR * SP - v.VZ * SP * CR);
                Vel.VY = (float)(v.VZ * SR - v.VY * CR);
                Vel.VZ = (float)(v.VX * SP - v.VY * (SR * CP) + v.VZ * (CP * CR));
            }
            return Vel;
        }

        private Velocity getPR_Vel_B(ArrayClass Arr, Velocity v)
        {
            Velocity Vel = new Velocity();
            if (v.VX == 88.888F || v.VY == 88.888F || v.VZ == 88.888F)
            {
                Vel.VX = 88.888F;
                Vel.VY = 88.888F;
                Vel.VZ = 88.888F;
            }
            else
            {
                float PITCH, ROLL;
                PITCH = (float)Math.PI * (Arr.B_Pitch) / 180.0F;
                if (Arr.B_Roll > 0)
                    ROLL = (float)Math.PI * (180 - Arr.B_Roll) / 180.0F;
                else
                    ROLL = (float)Math.PI * (-180 - Arr.B_Roll) / 180.0F;

                double SP = Math.Sin(PITCH);
                double CP = Math.Cos(PITCH);
                double SR = Math.Sin(ROLL);
                double CR = Math.Cos(ROLL);
                Vel.VX = (float)(v.VX * CP + v.VY * SR * SP - v.VZ * SP * CR);
                Vel.VY = (float)(v.VZ * SR - v.VY * CR);
                Vel.VZ = (float)(v.VX * SP - v.VY * (SR * CP) + v.VZ * (CP * CR));
            }
            return Vel;
        }
        */
        private void GetBottomTrackVelocity(ArrayClass Arr)//, double theta)//船相对于水底的速度 BoatVelocityToBottom
        {
            //JZH 2012-01-06 取消500个点的清除限制
            //if (restoreNum == EnsemblesInfoToStore.BoatVelocity.Count)
            //{
            //    EnsemblesInfoToStore.BoatVelocity.RemoveAt(0);
            //}

            //JZH 2012-01-09 旧版的转换方法----------开始
            //Velocity Vel = new Velocity();
            //Velocity v = new Velocity();
            //v.VX = Arr.B_Instrument[0];
            //v.VY = Arr.B_Instrument[1];
            //v.VZ = Arr.B_Instrument[2];//先忽略

            //Velocity HPR_V;
            //if (GPScheckbox.Checked)
            //{
            //    HPR_V = getPR_Vel_B(Arr, v);

            //    if (HPR_V.VX == 88.888F || HPR_V.VY == 88.888F || HPR_V.VZ == 88.888F)
            //    {
            //        Vel.VX = 88.888F;
            //        Vel.VY = 88.888F;
            //        Vel.VZ = 88.888F;
            //    }
            //    else
            //    {
            //        double CosT = Math.Cos(theta);
            //        double SinT = Math.Sin(theta);

            //        Vel.VX = (float)(HPR_V.VX * CosT - HPR_V.VY * SinT);
            //        Vel.VY = (float)(HPR_V.VX * SinT + HPR_V.VY * CosT);
            //        Vel.VZ = HPR_V.VZ;
            //    }
            //}
            //else
            //{
            //    HPR_V = getHPR_Vel_B(Arr, v);
            //    if (HPR_V.VX == 88.888F || HPR_V.VY == 88.888F || HPR_V.VZ == 88.888F)
            //    {
            //        Vel.VX = 88.888F;
            //        Vel.VY = 88.888F;
            //        Vel.VZ = 88.888F;
            //    }
            //    else
            //    {
            //        Vel.VX = HPR_V.VX;
            //        Vel.VY = HPR_V.VY;
            //        Vel.VZ = HPR_V.VZ;
            //    }
            //}
            //JZH 2012-01-09 旧版的转换方法----------结束

            //JZH 2011-02-09 直接获取ADCP原始的地球坐标系数据
            //Velocity Vel = new Velocity();
            Velocity v = new Velocity();
            v.VX = Arr.B_Earth[0];
            v.VY = Arr.B_Earth[1];
            v.VZ = Arr.B_Earth[2];  //注意，以后要改写Velocity结构，加入VQ  JZH 2012-01-09
            EnsemblesInfoToStore.BoatVelocity.Add(v);
            if (bStartMeasQ)
                SaveEnsemblesInfo.BoatVelocity.Add(v);  //LPJ 2012-5-4

            //EnsemblesInfoToStore.BoatVelocity.Add(Vel);
        }
        /*
        private Velocity CalXYZ2ENU(Velocity V, float Heading, float Pitch, float Roll) //LPJ 2013-5-29
        {
            Velocity Ve;

            //将角度转为弧度
            float BeamAngle = (float)(Math.PI / 180.0) * 20;
            float X, Y, Z;
            X = V.VX;
            Y = V.VY;
            Z = V.VZ;

            Heading = (float)(Math.PI / 180.0) * Heading;
            Pitch = (float)(Math.PI / 180.0) * Pitch;
            Roll = (float)(Math.PI / 180.0) * Roll;

            float SH = (float)Math.Sin(Heading);
            float CH = (float)Math.Cos(Heading);
            float SP = (float)Math.Sin(Pitch);
            float CP = (float)Math.Cos(Pitch);
            float SR = (float)Math.Sin(Roll);
            float CR = (float)Math.Cos(Roll);
            float SBA = (float)Math.Sin(BeamAngle);
            float CBA = (float)Math.Cos(BeamAngle);

            Ve.VX = X * (SH * CP) - Y * (CH * CR + SH * SR * SP) + Z * (CH * SR - SH * CR * SP);
            Ve.VY = X * (CH * CP) + Y * (SH * CR - CH * SR * SP) - Z * (SH * SR + CH * SP * CR);
            Ve.VZ = X * (SP) + Y * (SR * CP) + Z * (CP * CR);

            return Ve;
        }
        */

        
        //从仪器坐标系到地球坐标系
        private void CalXYZ2ENU(float X, float Y, float Z, float Heading, float Pitch, float Roll, ref float East, ref float North)
        {
            Heading = (float)(Math.PI / 180.0) * Heading;
            Pitch = (float)(Math.PI / 180.0) * Pitch;
            Roll = (float)(Math.PI / 180.0) * Roll;
           
            float SH = (float)Math.Sin(Heading);
            float CH = (float)Math.Cos(Heading);
            float SP = (float)Math.Sin(Pitch);
            float CP = (float)Math.Cos(Pitch);
            float SR = (float)Math.Sin(Roll);
            float CR = (float)Math.Cos(Roll);

            if (Math.Abs(X) > 80 || Math.Abs(Y) > 80 || Math.Abs(Z) > 80) //LPJ 2017-7-7
            {
                East = 88.888f;
                North = 88.888f;
            }
            else
            {
                East = X * (SH * CP) - Y * (CH * CR + SH * SR * SP) + Z * (CH * SR - SH * CR * SP);
                North = X * (CH * CP) + Y * (SH * CR - CH * SR * SP) - Z * (SH * SR + CH * SP * CR);
            }
            
        }


        private void GetWaterVelocityToBottom(ArrayClass Arr)//, double theta)//水相对于水底的速度，绝对速度
        {
            int n = GetVelocityBins(Arr, 0);//得到水单元层数
            Velocity[] Vel = new Velocity[n];//定义一个数组，包含一次样本所有的水层速度

            //JZH 2012-01-09 新版获取ADCP数据方法
            //JZH 2012-03-21 
            Velocity Bv = new Velocity();
            Bv.VX = Arr.B_Earth[0];
            Bv.VY = Arr.B_Earth[1];
            Bv.VZ = Arr.B_Earth[2];
            if (Bv.VX >= 80.0 || Bv.VY >= 80.0 || Bv.VZ >= 80.0)
            {
                Bv.VX = 0;
                Bv.VY = 0;
                Bv.VZ = 0;
            }

            //if ("GPS" == labelVesselRef.Text) //LPJ 2013-11-22
            //{
            //}

            //LPJ 2013-5-29 当选择无船速时 --start //LPJ 2013-7-31 cancel
            //if ("Null" == defCfg.DefCfgInf.BoatSpeedRef)
            //if(Resource1.String233==labelVesselRef.Text)
            //{
            //    Bv.VX = 0;
            //    Bv.VY = 0;
            //    Bv.VZ = 0;
            //}
            ////当选择GPS计算船速时
            ////else if ("GPS" == defCfg.DefCfgInf.BoatSpeedRef)
            //else if("GPS"==labelVesselRef.Text)
            //{
            //    string GPS_VTGBuffer;
            //    if (EnsemblesInfoToStore.GPS_VTGbuffer.Count > 0)
            //    {
            //        GPS_VTGBuffer = EnsemblesInfoToStore.GPS_VTGbuffer[EnsemblesInfoToStore.GPS_VTGbuffer.Count - 1].ToString();
            //        getGPSBoatSpeed(GPS_VTGBuffer, ref Bv.VX, ref Bv.VY);
            //        Bv.VZ = 0;
            //    }
            //    else
            //    {
            //        Bv.VX = 0;
            //        Bv.VY = 0;
            //        Bv.VZ = 0;
            //    }
            //}
            //LPJ 2013-2-22 当用户勾选GPS计算船速时，并采用GPS数据计算绝对流速--end

            for (int i = 0; i < n; i++) //艏向采用仪器heading
            {
                Vel[i].VX = Arr.Earth[0, i];
                Vel[i].VY = Arr.Earth[1, i];
                Vel[i].VZ = Arr.Earth[2, i];  //注意，以后改写Velocity结构，加入VQ JZH 2012-03-21
                //JZH 2012-03-21 绝对速度
                if (Vel[i].VX <= 80.0 && Vel[i].VY <= 80.0 && Vel[i].VZ <= 80.0)
                {
                    Vel[i].VX += Bv.VX;  //JZH 2012-03-21 获取绝对速度
                    Vel[i].VY += Bv.VY;
                    Vel[i].VZ += Bv.VZ;
                }
            }

            //LPJ 2013-5-29 艏向采用外部罗经的heading时 --start //LPJ 2013-7-31 cancel
            //if ("External" == defCfg.DefCfgInf.HeadingRef)
            //if (Resource1.String231 == labelHeadingRef.Text)
            //{
            //    Velocity Bv_instrument;
            //    Bv_instrument.VX = Arr.B_Instrument[0];
            //    Bv_instrument.VY = Arr.B_Instrument[1];
            //    Bv_instrument.VZ = Arr.B_Instrument[2];
            //    GPS_HDTdecode(GPS_HDTbuffer);
            //    Bv = CalXYZ2ENU(Bv_instrument, float.Parse(GPS_HDT), Arr.B_Pitch, Arr.B_Roll);

            //    for (int i = 0; i < n; i++) //艏向采用仪器heading
            //    {
            //        Velocity Vinstrument;
            //        Vinstrument.VX = Arr.Instrument[0, i];
            //        Vinstrument.VY = Arr.Instrument[1, i];
            //        Vinstrument.VZ = Arr.Instrument[2, i];
            //        Vel[i] = CalXYZ2ENU(Vinstrument, float.Parse(GPS_HDT), Arr.A_Pitch, Arr.A_Roll);
               
            //        //JZH 2012-03-21 绝对速度
            //        if (Vel[i].VX <= 80.0 && Vel[i].VY <= 80.0 && Vel[i].VZ <= 80.0)
            //        {
            //            Vel[i].VX += Bv.VX;  //JZH 2012-03-21 获取绝对速度
            //            Vel[i].VY += Bv.VY;
            //            Vel[i].VZ += Bv.VZ;
            //        }
            //    }
            //}
            //LPJ 2013-5-29 艏向采用GPS的heading时 --end

            //JZH 2011-12-29 不要清除
            //if (restoreNum == EnsemblesInfoToStore.WaterVelocity.Count)
            //{
            //    EnsemblesInfoToStore.WaterVelocity.RemoveAt(0);
            //}
            EnsemblesInfoToStore.WaterVelocity.Add(Vel);//添加

            EnsemblesInfoToStore.RangeOfFirstBin.Add(Arr.A_FirstCellDepth);   //JZH 2012-01-10 加入第一个起始单元位置
            //SM>
            EnsemblesInfoToStore.BinSize.Add(Arr.A_CellSize);
            //SM<

            if (bStartMeasQ)
            {
                SaveEnsemblesInfo.WaterVelocity.Add(Vel);  //LPJ 2012-5-4
                SaveEnsemblesInfo.RangeOfFirstBin.Add(Arr.A_FirstCellDepth);
            }
        }
        
        
        private void GetVelocityToColor()//ArrayClass Arr)
        {
            try
            {
                WaterSpeedTransToColor((Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1]);
            }
            catch  {   }
            //WaterVelocityTransToColor((Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1]);

            //if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
            try
            {
                WaterSpeedTransToColor_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[EnsemblesInfoToStore.WaterV_GPS.Count - 1]);
                //WaterVelocityTransToColor_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[EnsemblesInfoToStore.WaterV_GPS.Count - 1]);
            }
            catch
            { }

            //else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
            try
            {
                WaterSpeedTransToColor_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[EnsemblesInfoToStore.WaterV_GPGGA.Count - 1]);
                //WaterVelocityTransToColor_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[EnsemblesInfoToStore.WaterV_GPGGA.Count - 1]);
            }
            catch { }
            //else if (Resource1.String233 == labelVesselRef.Text)
            try
            {
                WaterSpeedTransToColor_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[EnsemblesInfoToStore.WaterV_Null.Count - 1]);
                //WaterVelocityTransToColor_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[EnsemblesInfoToStore.WaterV_Null.Count - 1]);
            }
            catch { }
        }
        
        
        private Color GetNewRGB(Color c, float ColorMultiple)
        {
            Color clr;

            {
                //SM>
                if (c.R == 0 && c.G == 0 && c.B == 0)
                {
                    clr = Color.FromArgb(0, 0, 0);
                }
                else
                //SM<
                { 
                    if (c.R == 0 && c.B == 255)
                    {
                        int num = (int)(c.G * ColorMultiple);
                        if (num <= 255)
                            clr = Color.FromArgb(0, num, 255);//(0,0,255)-(0,255,255)
                        else if (num > 255 && num <= 510)
                            clr = Color.FromArgb(0, 255, 255 - (num - 255));//(0,255,254)-(0,255,0)
                        else if (num > 510 && num <= 765)
                            clr = Color.FromArgb(num - 510, 255, 0);//(1,255,0)-(255,255,0)
                        else if (num > 765 && num <= 1020)
                            clr = Color.FromArgb(255, 255 - (num - 765), 0);//(255,254,0)-(255,0,0)
                        else
                        {
                            int cB = num - 1020;
                            if (cB > 255) cB = 255;
                            clr = Color.FromArgb(255, 0, cB);//(255,254,0)-(255,0,0)
                        }
                    }
                    else if (c.R == 0 && c.G == 255)
                    {
                        int num = (int)((510 - c.B) * ColorMultiple);
                        if (num <= 510)
                            clr = Color.FromArgb(0, 255, 255 - (num - 255));//(0,255,254)-(0,255,0)
                        else if (num > 510 && num <= 765)
                            clr = Color.FromArgb(num - 510, 255, 0);//(1,255,0)-(255,255,0)
                        else if (num > 765 && num <= 1020)
                            clr = Color.FromArgb(255, 255 - (num - 765), 0);//(255,254,0)-(255,0,0)
                        else
                        {
                            int cB = num - 1020;
                            if (cB > 255) cB = 255;
                            clr = Color.FromArgb(255, 0, cB);//(255,254,0)-(255,0,0)
                        }
                    }
                    else if (c.G == 255 && c.B == 0)
                    {
                        int num = (int)((510 + c.R) * ColorMultiple);
                        if (num <= 765)
                            clr = Color.FromArgb(num - 510, 255, 0);//(1,255,0)-(255,255,0)
                        else if (num > 765 && num <= 1020)
                            clr = Color.FromArgb(255, 255 - (num - 765), 0);//(255,254,0)-(255,0,0)
                        else
                        {
                            int cB = num - 1020;
                            if (cB > 255) cB = 255;
                            clr = Color.FromArgb(255, 0, cB);//(255,254,0)-(255,0,0)
                        }
                    }
                    else if (c.R == 255 && c.B == 0)
                    {
                        int num = (int)((1020 - c.G) * ColorMultiple);
                        if (num <= 1020)
                            clr = Color.FromArgb(255, 255 - (num - 765), 0);//(255,254,0)-(255,0,0)
                        else
                        {
                            int cB = num - 1020;
                            if (cB > 255) cB = 255;
                            clr = Color.FromArgb(255, 0, cB);//(255,254,0)-(255,0,0)
                        }
                    }
                    else
                    {
                        int num = (int)((1020 + c.B) * ColorMultiple);
                        int cB = num - 1020;
                        if (cB > 255) cB = 255;
                        clr = Color.FromArgb(255, 0, cB);//(255,254,0)-(255,0,0)
                    }
                }
            }
            
            return clr;
        }

        private Color NumToColor(float Num, int type, bool DirectionFlag)
        {
            int c;
            Color cl = new Color();
            switch (type)
            {
                case 1:
                    {
                        if (Num <= LimiteVelocity)//灰度
                        {
                            c = (int)(255 * (Num / LimiteVelocity));
                        }
                        else
                        {
                            c = 255;
                        }
                        cl = Color.FromArgb(c, c, c);
                        break;
                    }
                case 2:
                    {//SM>
                        if (Num < 125)
                        {
                            if (Num <= LimiteVelocity)
                            {
                                c = (int)(1275 * (Num / LimiteVelocity));
                            }
                            else
                            {
                                c = 1275;
                            }
                            if (c <= 255)
                                cl = Color.FromArgb(0, c, 255);//(0,0,255)-(0,255,255)
                            else if (c > 255 && c <= 510)
                                cl = Color.FromArgb(0, 255, 255 - (c - 255));//(0,255,254)-(0,255,0)
                            else if (c > 510 && c <= 765)
                                cl = Color.FromArgb(c - 510, 255, 0);//(1,255,0)-(255,255,0)
                            else if (c > 765 && c <= 1020)
                                cl = Color.FromArgb(255, 255 - (c - 765), 0);//(255,254,0)-(255,0,0)
                            else //if (c > 1020)
                                cl = Color.FromArgb(255, 0, c - 1020);//(255,0,1)-(255,0,255)
                            
                        }
                        else
                        {
                            cl = Color.FromArgb(0, 0, 0);
                        }//SM<
                        break;
                    }
                case 3:
                    {
                        if (!DirectionFlag)//向外：蓝->绿/黑-蓝-青（511阶颜色）    VX<0
                        {
                            if (Num <= LimiteVelocity)
                            {
                                c = (int)(510 * (Num / LimiteVelocity));
                            }
                            else
                            {
                                c = 510;
                            }
                            if (c <= 255)
                            {
                                cl = Color.FromArgb(0, c, 255);//(0,0,255)-(0,255,255)
                            }
                            else //if ((c > 255) && (c <= 255 * 2))
                            {
                                cl = Color.FromArgb(0, 255, 255 - (c - 255));//(0,255,254)-(0,255,0)
                            }
                        }
                        else //向内：蓝->红/黑-红-黄（510阶颜色）
                        {
                            if (Num <= LimiteVelocity)
                            {
                                c = (int)(510 * (Num / LimiteVelocity));
                            }
                            else
                            {
                                c = 510;
                            }
                            if (c <= 255)
                            {
                                cl = Color.FromArgb(c, 0, 255);//(1,0,255)-(255,0,255)
                            }
                            else //if ((c > 255) && (c <= 255 * 2))
                            {
                                cl = Color.FromArgb(255, 0, 510 - c);//(255,0,254)-(255,0,0) 
                            }
                        }
                        break;
                    }
                case 4:
                    {
                        if (!DirectionFlag)//向外：蓝->绿/黑-蓝-青（511阶颜色）    VX<0
                        {
                            if (Num <= LimiteVelocity)
                            {
                                c = (int)(510 * (Num / LimiteVelocity));
                            }
                            else
                            {
                                c = 510;
                            }
                            if (c <= 255)
                            {
                                cl = Color.FromArgb(0, 0, c);//(0,0,0)-(0,0,255)
                            }
                            else //if ((c > 255) && (c <= 255 * 2))
                            {
                                cl = Color.FromArgb(0, c - 255, 255);//(0,1,255)-(0,255,255)
                            }
                        }
                        else //向内：蓝->红/黑-红-黄（510阶颜色）
                        {
                            if (Num <= LimiteVelocity)
                            {
                                c = (int)(510 * (Num / LimiteVelocity));
                            }
                            else
                            {
                                c = 510;
                            }
                            if (c <= 255)
                            {
                                cl = Color.FromArgb(c, 0, 0);//(0,0,0)-(255,0,0)
                            }
                            else //if ((c > 255) && (c <= 255 * 2))
                            {
                                cl = Color.FromArgb(255, c - 255, 0);//(255,1,0)-(255,255,0)}
                            }
                        }
                        break;
                    }
                default:
                    break;
            }
            return cl;
        }

     
        private void WaterSpeedTransToColor(Velocity[] WaterVel)
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.WaterSpeedToBlackWhite.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan.Add(VelColor4);

            if (bStartMeasQ)  //LPJ 2012-5-4
            {
                //SaveEnsemblesInfo.WaterSpeedToBlackWhite.Add(VelColor1);
                SaveEnsemblesInfo.WaterSpeedToSixColor.Add(VelColor2);
                //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen.Add(VelColor3);
                //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan.Add(VelColor4);
            }
        }

        //JZH 2011-12-25 取消转换时500个数据组数限制 注意无效数据未剔除？
        private void WaterSpeedTransToColor2(Velocity[] WaterVel)
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan.Add(VelColor4);

            if (bStartMeasQ) //LPJ　2012-5-4
            {
                //SaveEnsemblesInfo.WaterSpeedToBlackWhite.Add(VelColor1);
                SaveEnsemblesInfo.WaterSpeedToSixColor.Add(VelColor2);
                //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen.Add(VelColor3);
                //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan.Add(VelColor4);
            }
        }

        //JZH 2011-12-25 取消转换时500个数据组数限制  注意无效数据未剔除？
        /*
        private void WaterVelocityTransToColor2(Velocity[] WaterVel)
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan.Add(VelColorE4);

            //if (bStartMeasQ) //LPJ 2012-5-4
            //{
            //    SaveEnsemblesInfo.NorthVelocityToBlackWhite.Add(VelColorN1);
            //    SaveEnsemblesInfo.NorthVelocityToSixColor.Add(VelColorN2);
            //    SaveEnsemblesInfo.NorthVelocityToRedBlueGreen.Add(VelColorN3);
            //    SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan.Add(VelColorN4);
            //    SaveEnsemblesInfo.EastVelocityToBlackWhite.Add(VelColorE1);
            //    SaveEnsemblesInfo.EastVelocityToSixColor.Add(VelColorE2);
            //    SaveEnsemblesInfo.EastVelocityToRedBlueGreen.Add(VelColorE3);
            //    SaveEnsemblesInfo.EastVelocityToYellowBlackCyan.Add(VelColorE4);
            //}
        }
        */
        /*
        private void WaterVelocityTransToColor(Velocity[] WaterVel)
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.NorthVelocityToBlackWhite.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan.Add(VelColorN4);

            //EnsemblesInfoToStore.EastVelocityToBlackWhite.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan.Add(VelColorE4);

            //if (bStartMeasQ) //LPJ 2012-5-4
            //{
            //    SaveEnsemblesInfo.NorthVelocityToBlackWhite.Add(VelColorN1);
            //    SaveEnsemblesInfo.NorthVelocityToSixColor.Add(VelColorN2);
            //    SaveEnsemblesInfo.NorthVelocityToRedBlueGreen.Add(VelColorN3);
            //    SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan.Add(VelColorN4);
            //    SaveEnsemblesInfo.EastVelocityToBlackWhite.Add(VelColorE1);
            //    SaveEnsemblesInfo.EastVelocityToSixColor.Add(VelColorE2);
            //    SaveEnsemblesInfo.EastVelocityToRedBlueGreen.Add(VelColorE3);
            //    SaveEnsemblesInfo.EastVelocityToYellowBlackCyan.Add(VelColorE4);
            //}
        }
        */
        private void WaterSpeedTransToColor_GPS(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPS.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPS.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPS.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPS.Add(VelColor4);

            if (bStartMeasQ)  //LPJ 2012-5-4
            {
                //SaveEnsemblesInfo.WaterSpeedToBlackWhite_GPS.Add(VelColor1);
                SaveEnsemblesInfo.WaterSpeedToSixColor_GPS.Add(VelColor2);
                //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen_GPS.Add(VelColor3);
                //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan_GPS.Add(VelColor4);
            }
        }

        private void WaterSpeedTransToColor_GPGGA(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPGGA.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPGGA.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPGGA.Add(VelColor4);

            if (bStartMeasQ)  //LPJ 2012-5-4
            {
                //SaveEnsemblesInfo.WaterSpeedToBlackWhite_GPGGA.Add(VelColor1);
                SaveEnsemblesInfo.WaterSpeedToSixColor_GPGGA.Add(VelColor2);
                //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen_GPGGA.Add(VelColor3);
                //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan_GPGGA.Add(VelColor4);
            }
        }

        private void WaterSpeedTransToColor_Null(Velocity[] WaterVel) //LPJ 2016-8-15
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_Null.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_Null.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_Null.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_Null.Add(VelColor4);

            if (bStartMeasQ)  //LPJ 2012-5-4
            {
                //SaveEnsemblesInfo.WaterSpeedToBlackWhite_Null.Add(VelColor1);
                SaveEnsemblesInfo.WaterSpeedToSixColor_Null.Add(VelColor2);
                //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen_Null.Add(VelColor3);
                //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan_Null.Add(VelColor4);
            }
        }
        /*
        private void WaterVelocityTransToColor_GPS(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPS.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPS.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPS.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPS.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPS.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPS.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPS.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPS.Add(VelColorE4);

            if (bStartMeasQ) //LPJ 2013-7-31
            {
                //SaveEnsemblesInfo.NorthVelocityToBlackWhite_GPS.Add(VelColorN1);
                //SaveEnsemblesInfo.NorthVelocityToSixColor_GPS.Add(VelColorN2);
                //SaveEnsemblesInfo.NorthVelocityToRedBlueGreen_GPS.Add(VelColorN3);
                //SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan_GPS.Add(VelColorN4);
                //SaveEnsemblesInfo.EastVelocityToBlackWhite_GPS.Add(VelColorE1);
                //SaveEnsemblesInfo.EastVelocityToSixColor_GPS.Add(VelColorE2);
                //SaveEnsemblesInfo.EastVelocityToRedBlueGreen_GPS.Add(VelColorE3);
                //SaveEnsemblesInfo.EastVelocityToYellowBlackCyan_GPS.Add(VelColorE4);
            }
        }
        */
        /*
        private void WaterVelocityTransToColor_GPGGA(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPGGA.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPGGA.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPGGA.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPGGA.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPGGA.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPGGA.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPGGA.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPGGA.Add(VelColorE4);

            if (bStartMeasQ) //LPJ 2013-7-31
            {
                //SaveEnsemblesInfo.NorthVelocityToBlackWhite_GPGGA.Add(VelColorN1);
                //SaveEnsemblesInfo.NorthVelocityToSixColor_GPGGA.Add(VelColorN2);
                //SaveEnsemblesInfo.NorthVelocityToRedBlueGreen_GPGGA.Add(VelColorN3);
                //SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan_GPGGA.Add(VelColorN4);
                //SaveEnsemblesInfo.EastVelocityToBlackWhite_GPGGA.Add(VelColorE1);
                //SaveEnsemblesInfo.EastVelocityToSixColor_GPGGA.Add(VelColorE2);
                //SaveEnsemblesInfo.EastVelocityToRedBlueGreen_GPGGA.Add(VelColorE3);
                //SaveEnsemblesInfo.EastVelocityToYellowBlackCyan_GPGGA.Add(VelColorE4);
            }
        }
        */
        /*
        private void WaterVelocityTransToColor_Null(Velocity[] WaterVel) //LPJ 2016-8-15
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_Null.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_Null.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_Null.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_Null.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_Null.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_Null.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_Null.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_Null.Add(VelColorE4);

            //if (bStartMeasQ) //LPJ 2013-7-31
            //{
            //    SaveEnsemblesInfo.NorthVelocityToBlackWhite_Null.Add(VelColorN1);
            //    SaveEnsemblesInfo.NorthVelocityToSixColor_Null.Add(VelColorN2);
            //    SaveEnsemblesInfo.NorthVelocityToRedBlueGreen_Null.Add(VelColorN3);
            //    SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan_Null.Add(VelColorN4);
            //    SaveEnsemblesInfo.EastVelocityToBlackWhite_Null.Add(VelColorE1);
            //    SaveEnsemblesInfo.EastVelocityToSixColor_Null.Add(VelColorE2);
            //    SaveEnsemblesInfo.EastVelocityToRedBlueGreen_Null.Add(VelColorE3);
            //    SaveEnsemblesInfo.EastVelocityToYellowBlackCyan_Null.Add(VelColorE4);
            //}
        }
        */
        private bool BytesEquals(byte[] b1, byte[] b2)
        {
            if (b1.Length != b2.Length) return false;
            if (b1 == null || b2 == null) return false;
            for (int i = 0; i < b1.Length; i++)
            {
                if (b1[i] != b2[i])
                    return false;
            }
            return true;
        }

        public static byte[] CRC16Chksum(byte[] DataPacket)
        {
            byte[] bytes = new byte[4];
            ushort crc = 0;//seed = 0
            for (int i = 0; i < DataPacket.Length; i++)
            {

                crc = (ushort)((byte)(crc >> 8) | (crc << 8));
                crc ^= DataPacket[i];
                crc ^= (byte)((crc & 0xff) >> 4);
                crc ^= (ushort)((crc << 8) << 4);
                crc ^= (ushort)(((crc & 0xff) << 4) << 1);
            }

            ushort csum = crc;
            BitConverter.GetBytes(csum).CopyTo(bytes, 0);
            return bytes;
        }
        /*
        private void ArrayClassWriteToFile(ArrayClass m)
        {
            string MatString = string.Empty;
            for (int i = 0; i < m.nArray; i++)
            {
                MatString += m.Name[i];

                MatString += "\r\n";
                switch (m.Name[i])
                {
                    case "E000001\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.Velocity[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000002\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.Instrument[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000003\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.Earth[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000004\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.Amplitude[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000005\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.Correlation[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000006\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.BeamN[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }

                    case "E000007\0":
                        {
                            for (int bin = 0; bin < m.Bins[i]; bin++)
                            {
                                for (int beam = 0; beam < m.Beams[i]; beam++)
                                {
                                    MatString += m.XfrmN[beam, bin].ToString("0.0000").PadLeft(12, ' ');
                                }
                                MatString += "\r\n";
                            }
                            break;
                        }
                    case "E000008\0":
                        {
                            MatString += m.E_EnsembleNumber.ToString().PadLeft(12, ' ');
                            MatString += m.E_Cells.ToString().PadLeft(12, ' ');
                            MatString += m.E_Beams.ToString().PadLeft(12, ' ');
                            MatString += m.E_PingsInEnsemble.ToString().PadLeft(12, ' ') + "\r\n";
                            MatString += m.E_PingCount.ToString().PadLeft(12, ' ');
                            MatString += m.E_Status.ToString().PadLeft(12, ' ');
                            //////////////////2010-01-14添加的改动//////////////////
                            //if (radioButtonInsTime.Checked)  //LPJ 2013-6-21 待修改？？？？？？？？？？
                            //{
                            //    MatString += m.YYYY.ToString().PadLeft(12, ' ');
                            //    MatString += m.MM.ToString().PadLeft(12, ' ') + "\r\n";
                            //    MatString += m.DD.ToString().PadLeft(12, ' ');
                            //    MatString += m.HH.ToString().PadLeft(12, ' ');
                            //    MatString += m.mm.ToString().PadLeft(12, ' ');
                            //    MatString += m.SS.ToString().PadLeft(12, ' ') + "\r\n";
                            //    MatString += m.hsec.ToString().PadLeft(12, ' ') + "\r\n";
                            //}
                            //else if (radioButtonGPSTime.Checked)
                            //{
                            //    MatString += m.YYYY.ToString().PadLeft(12, ' ');
                            //    MatString += m.MM.ToString().PadLeft(12, ' ') + "\r\n";
                            //    MatString += m.DD.ToString().PadLeft(12, ' ');
                            //    MatString += gpsTime.Substring(0, 2).PadLeft(12, ' ');
                            //    MatString += gpsTime.Substring(2, 2).PadLeft(12, ' ');
                            //    MatString += gpsTime.Substring(4, 2).PadLeft(12, ' ') + "\r\n";
                            //    MatString += m.hsec.ToString().PadLeft(12, ' ') + "\r\n";
                            //}
                            //else
                            if (bUsePCTime) //LPJ 2013-6-25 当用户设置使用PC时间
                            {
                                DateTime DT = System.DateTime.Now;

                                MatString += DT.Year.ToString().PadLeft(12, ' ');
                                MatString += DT.Month.ToString().PadLeft(12, ' ') + "\r\n";
                                MatString += DT.Day.ToString().PadLeft(12, ' ');
                                MatString += DT.Hour.ToString().PadLeft(12, ' ');
                                MatString += DT.Minute.ToString().PadLeft(12, ' ');
                                MatString += DT.Second.ToString().PadLeft(12, ' ') + "\r\n";
                                MatString += (DT.Millisecond / 10).ToString().PadLeft(12, ' ') + "\r\n";
                            }
                            else //LPJ 2013-6-25
                            {
                                MatString += m.YYYY.ToString().PadLeft(12, ' ');
                                MatString += m.MM.ToString().PadLeft(12, ' ') + "\r\n";
                                MatString += m.DD.ToString().PadLeft(12, ' ');
                                MatString += m.HH.ToString().PadLeft(12, ' ');
                                MatString += m.mm.ToString().PadLeft(12, ' ');
                                MatString += m.SS.ToString().PadLeft(12, ' ') + "\r\n";
                                MatString += m.hsec.ToString().PadLeft(12, ' ') + "\r\n";
                            }
                            ///////////////////////////////////////////////////////
                            break;
                        }
                    case "E000009\0":
                        {
                            MatString += m.A_FirstCellDepth.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_CellSize.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_FirstPingSeconds.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_LastPingSeconds.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.A_Heading.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_Pitch.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_Roll.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_WaterTemperature.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.A_BoardTemperature.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_Salinity.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_Pressure.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.A_Depth.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.A_SpeedOfSound.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            break;
                        }
                    case "E000010\0":
                        {
                            MatString += m.B_FirstPingSeconds.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_LastPingSeconds.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_Heading.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_Pitch.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.B_Roll.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_WaterTemperature.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_BoardTemperature.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_Salinity.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.B_Pressure.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_Depth.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_SpeedOfSound.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_Status.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            MatString += m.B_Beams.ToString("0.0000").PadLeft(12, ' ');
                            MatString += m.B_PingCount.ToString("0.0000").PadLeft(12, ' ') + "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Range[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_SNR[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Amplitude[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Correlation[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Velocity[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_BeamN[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Instrument[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_XfrmN[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_Earth[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            for (int j = 0; j < m.B_Beams; j++)
                            {
                                MatString += m.B_EarthN[j].ToString("0.0000").PadLeft(12, ' ');
                            }
                            MatString += "\r\n";
                            break;
                        }
                    case "E000011\0": //LPJ 2014-4-23
                        {
                            MatString += System.Text.Encoding.Default.GetString(m.NMEA_Buffer) + "\r\n";
                            break;
                        }
                }
            }
            //int textFileNum = EnsembleNumber++ / EsnNum;  
            int textFileNum = EnsembleNumber / EsnNum;  //LPJ 2012-5-7
            File.AppendAllText(newPath + "\\EnsemblesSet" + "\\MatString" + textFileNum.ToString("0000000") + ".txt", "Ensemble Numble " + EnsembleNumber.ToString("0000000") + "\r\n" + GPS_dataToEnsemble);
            File.AppendAllText(newPath + "\\EnsemblesSet" + "\\MatString" + textFileNum.ToString("0000000") + ".txt", MatString + "\r\n");
            EnsembleNumber++;
        }
        */
        /*
        private void WriteAllSettingsToFiles()
        {
           // if (MaxWaterVel.Text != null)
            {
                MaxVelocityByCostommer = 3.0f;//读取输入
                if (MaxVelocityByCostommer <= 0)
                {
                    MaxVelocityByCostommer = 10;
                }
                else if (MaxVelocityByCostommer > 10)
                {
                    MaxVelocityByCostommer = 10;
                }
            }

            string str = MaxVelocityByCostommer.ToString() + "\r\n";
            //MessageBox.Show(str);  Modified 2011-11-3, number of 3
            EsnNum = 50;

            //File.WriteAllText(newPath + "\\PlaybackData\\" + "info.infm", str); //Modified 2011-11-3 changed to write it every ping

            writeAllSettingsToCfg();
            try //Modified 2011-7-28 found exception, using try-catch
            {
                File.Copy(newPath + "\\SysCfg\\" + "Config.cfg",
                    Directory.GetCurrentDirectory() + "\\dp300Data" + "\\LastTimeCfg" + "\\Config.cfg",
                    true);
            }
            catch
            {
                string sourceFile = newPath + "\\SysCfg\\" + "Config.cfg";
                string destinationFile = Directory.GetCurrentDirectory() + "\\dp300Data" + "\\LastTimeCfg" + "\\Config.cfg";
                // MessageBox.Show("找不到文件" + sourceFile + "or create destinationFile"+"\r\n请重新启动.");
                //LPJ 2012-4-20
                MessageBox.Show(Resource1.String6 + sourceFile + "or create destinationFile\r\n" + Resource1.String7);
            }
        }
        */
        /*
        private void writeAllSettingsToCfg()
        {
            WriteProjectInfoToCfg();
          
            //wirteQParaToCfg();    //JZH 2012-04-18 将流量测量参数写入到配置文件
            WriteNewProjectInfoToCfg(); //LPJ 2013-5-31 将新修改的工程配置写入文件
        }
        */
        /*
        private void WriteNewProjectInfoToCfg()//LPJ 2013-5-31 将新修改的工程配置写入文件
        {
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "Language " + defCfg.DefCfgInf.Language + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "ProjectName " + defCfg.DefCfgInf.FileName + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "EnsembleNum " + defCfg.DefCfgInf.EnsembleNum + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "Unit " + defCfg.DefCfgInf.Unit + "\r\n");

            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "ShowProfiler " + defCfg.DefCfgInf.ShowProfiler + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "WaterSpeedRef " + defCfg.DefCfgInf.WaterSpeedRef + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "BoatSpeedRef " + defCfg.DefCfgInf.BoatSpeedRef + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "HeadingRef " + defCfg.DefCfgInf.HeadingRef + "\r\n");

            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "ADCP_PortName " + defCfg.DefCfgInf.ADCP_SerialPort + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "ADCP_BaudRate " + defCfg.DefCfgInf.ADCP_Baudrate + "\r\n");

            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "Mode " + defCfg.DefCfgInf.Mode + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "DepthInWater " + defCfg.DefCfgInf.DepthInWater + "\r\n");
        }
        */
        //JZH 2012-04-18 流量测量参数写入到配置文件
    /*
        private void WriteProjectInfoToCfg()
        {
            //File.WriteAllText(newPath + "\\SysCfg\\" + "Config.cfg", "ProjectName " + ProjectName + "\r\n");//WriteAllText创建新文件，存在，则覆盖
            //File.WriteAllText(newPath + "\\SysCfg\\" + "Config.cfg", "MaxVelocity " + MaxWaterVel.Text + "\r\n");
            //File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "EnsembleNum " + EsnNumPerFile.Text + "\r\n");

            //if (sourceE02.Checked == true)
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "sourceE02" + "\r\n");
            //else
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "sourceE03" + "\r\n");

            //if (sourceBtmTrck.Checked == true)
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "sourceBtmTrck" + "\r\n");
            //else
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "sourceGPSCompass" + "\r\n");

            //if (radioButtonInsTime.Checked == true)
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "radioButtonInsTime" + "\r\n");
            //else if (radioButtonGPSTime.Checked == true)
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "radioButtonGPSTime" + "\r\n");
            //else
            //    File.AppendAllText(newPath + "\\SysCfg\\" + "Config.cfg", "radioButtonPCTime" + "\r\n");
        }
        */
        private void buttonProjectSet_Click(object sender, EventArgs e)
        {
            if (playBackMode == false)
            {
                //LPJ 2012-5-24 增加，提示
                //ConfigChangedFlag = true;
                //maintabpage = -1;
                //try   //LPJ 2012-5-25 cancle
                //{
                //    if (float.Parse(MaxWaterVel.Text) == 0)
                //    {
                //        ShowTip(MaxWaterVel, Resource1.String9);
                //        ConfigChangedFlag = false;
                //    }
                //    if (int.Parse(EsnNumPerFile.Text) == 0)
                //    {
                //        ShowTip(EsnNumPerFile, Resource1.String78);
                //        ConfigChangedFlag = false;
                //    }
                //}
                //catch
                //{
                //    MessageBox.Show(Resource1.String8);
                //    ConfigChangedFlag = false;
                //}

                if (!CheckProjectSettext())
                {
                    MessageBox.Show(Resource1.String8);
                    //ConfigChangedFlag = false;
                }

                //LPJ 2012-5-24 cancle
                /* if (String.IsNullOrEmpty(MaxWaterVel.Text) || !IsNumber(MaxWaterVel.Text) || String.IsNullOrEmpty(EsnNumPerFile.Text) || !IsNumber(EsnNumPerFile.Text))
                 {
                     //MessageBox.Show("参数输入不正确！");//LPJ 2012-4-20
                    
                     MessageBox.Show(Resource1.String8);
                 }
                 else if ((float.Parse(MaxWaterVel.Text) == 0) || (float.Parse(MaxWaterVel.Text) == 0))
                 {
                     //MessageBox.Show("最大流速不能为0！");//LPJ 2012-4-20
                     MessageBox.Show(Resource1.String9);
                 }
                 else
                 {
                     ConfigChangedFlag = true;
                 }*/
            }
        }

        //LPJ 2012-5-25 添加
        private bool CheckProjectSettext()
        {
            try
            {
                //if (float.Parse(MaxWaterVel.Text) <= 0.0)
                //{
                //    ShowTip(MaxWaterVel, Resource1.String9);
                //    //ConfigChangedFlag = false;
                //    return false;
                //}
               
            }
            catch
            {
                return false;
            }
            return true;
        }

        //private void connectComm() //JZH 2012-06-13
        /*
        private bool connectComm()  //JZH 2012-06-13 更改函数返回类型
        {
            try
            {
                sp.Open();
            }
            catch (System.Exception ex)//如有异常，捕捉并显示
            {
                MessageBox.Show(ex.Message);
                return false;  //JZH 2012-06-13 添加返回值 
            }
            return true;  //JZH 2012-06-13 添加返回值
        }
        */
        private void closeComm()
        {
            if (sp.IsOpen)
            {
                sp.Write("STOP" + "\r");
              
                sp.Close();

                if (bGPSConnect)
                {
                    GPS_sp.Close();
                }
              
            }
        }

        private void buttonCommOK_Click(object sender, EventArgs e)
        {
            if (playBackMode == false)
            {
                if (!sp.IsOpen)
                {
                   
                }
            }
            else
            {
                // MessageBox.Show("目前处于回放模式，请先切换至跟踪显示模式，再配置！");//LPJ 2012-4-20
                MessageBox.Show(Resource1.String15);
            }
        }
        /*
        private bool IsNumber(String str)
        {
            int j = 0;
            for (int i = 0; i < str.Length; i++)
            {
                if (((str[i] < '0' || str[i] > '9' || str[i] == ' ') && str[i] != '.')
                    || str[0] == '.' || str[str.Length - 1] == '.')
                {
                    return false;
                }
                else
                {
                    if ('.' == str[i])
                    { j++; }
                }
            }
            if (j > 1)//多于两个‘.’
            {
                return false;
            }
            return true;

        }
        */
        //LPJ 2012-5-23 判断小数，若不是则不显示
        /*
        private string IsDecimalFraction(string str)
        {
            bool isMatch1 = System.Text.RegularExpressions.Regex.IsMatch(str, @"^([0-9]+|[0-9]+\.{0,1}[0-9]*)$"); //正则表达式判断小数
            if (isMatch1 == false)
            {
                if (str.Length != 0)
                    str = str.Remove(str.Length - 1);  //如若不是小数则删除该字符
            }
            return str;
        }
        */
        //LPJ 2012-5-23 判断整数
        /*
        private string IsNumber2(string str)
        {
            bool isMatch1 = System.Text.RegularExpressions.Regex.IsMatch(str, @"^[0-9]*$"); //正则表达式判断整数
            if (isMatch1 == false)
            {
                if (str.Length != 0)
                    str = str.Remove(str.Length - 1);
            }
            return str;
        }
        */
    
        private bool MainPanelMaxDisPlayer = false;
        private void MainPanel_MouseDoubleClick(object sender, MouseEventArgs e)//双击切换最大化
        {
            if (!MainPanelMaxDisPlayer)
            {
                this.MainPanel.Dock = DockStyle.Fill;
             
                this.InfoPanel.Visible = false;
                this.HPRDisplayerPanel.Visible = false;
            }
            else
            {
                this.MainPanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
                this.MainPanel.Dock = DockStyle.None;
                this.MainPanel.Location = new System.Drawing.Point(InfoPanel.Width + 1, 0);
                this.MainPanel.Size = new System.Drawing.Size(DP300Displayer.DisplayRectangle.Width - InfoPanel.Width  + 4, DP300Displayer.DisplayRectangle.Height -  panel1.Height + 4);
               
             
                this.InfoPanel.Visible = true;
                this.HPRDisplayerPanel.Visible = true;
            }
            MainPanelMaxDisPlayer = !MainPanelMaxDisPlayer;
        }

        private void TrackDisplayerPanel_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            if (!TrackDisplayerPanelMaxDisPlayer)
            {
                this.HPRDisplayerPanel.Dock = DockStyle.Fill;
              
              
                this.InfoPanel.Visible = false;
                this.MainPanel.Visible = false;
            }
            else
            {
                this.HPRDisplayerPanel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
                this.HPRDisplayerPanel.Dock = DockStyle.None;
                this.HPRDisplayerPanel.Location = new System.Drawing.Point(0, MainPanel.Height + 1);
                this.HPRDisplayerPanel.Size = new System.Drawing.Size(DP300Displayer.DisplayRectangle.Width - MainPanel.Width  + 5, DP300Displayer.DisplayRectangle.Height - MainPanel.Height - panel1.Height + 4);
            
                this.InfoPanel.Visible = true;
                this.MainPanel.Visible = true;
            }
            TrackDisplayerPanelMaxDisPlayer = !TrackDisplayerPanelMaxDisPlayer;
        }


        private float MaxDisplayHeight;
        //private float MaxDisplayWidth;
        private float CurrentDisplayUnit;
        private float CurrentDisplayTop;
        private float CurrentDisplayLeft;
        private float scaleMultiple = 1; //Modified 2011-11-15 cancel
        private float PreviousMultiple = 1;//上一次刷新后客户区所处于的倍数//Modified 2011-11-15 cancel
        private float DragLengthX = 0;
        private float DragLengthY = 0;
        private float MouseWheelScale = 1;//滚轮缩小率的初始值
        //private float MouseWheelScale = 0.1f;//滚轮缩小率的初始值 //LPJ 2013-8-2
        private PointF DragEndPoint;
        //Rectangle DisplayRec;
        float MainGPSWidth = 0;
        float MainGPSHeight = 0;
        //int AverageScale = 80;
        int AverageScale = 1000;


        private bool bDragMainPanel = false; //LPJ 2013-7-5 用于标记拖动mainpanel中的图示图例
        private PointF DragStartPntMainPanel; //LPJ 2013-7-5
        //private PointF pntPanelTrackLabel; //用于记录mainpanel中的图示图例的位置
        private void MainPanel_MouseDown(object sender, MouseEventArgs e)
        {
          
        }
        private void MainPanel_MouseUp(object sender, MouseEventArgs e)
        {
           
        }
        private void MainPanel_MouseMove(object sender, MouseEventArgs e)
        {
            try
            {
                if ((e.Location.Y >= 0 && e.Location.Y <= MainPanel.Height) && (e.Location.X >= 35))  //LPJ 2013-5-17
                //if ((e.Location.Y >= 5 && e.Location.Y <= 305) && (e.Location.X >= MainPanel.ClientRectangle.Width - (MainPanel.Width - 68 + 5)))
                
                {
                    if (MouseDownFlag == false && EnsemblesInfoToStore.WaterVelocity.Count > 0)
                    {
                        lock (locker)
                        {
                            if (EnsemblesInfoToStore.WaterVelocity.Count > 1)
                            {

                                //JZH 2011-12-26 新版本获取当前数据组序号   ----------开始
                                float PixelRectangleWidth;
                                int i = 0;   //当前数据组序号
                                PixelRectangleWidth = (MainPanel.Width - 35) / (float)BinDataEnsembleNum;  //获取当前每个数据组单元绘制的宽度   //JZH 2011-12-27 Adjust
                                i = (int)((e.Location.X - 35) / PixelRectangleWidth) + 1;   //根据当前X坐标获取数据组号   //JZH 2011-12-27 Adjust

                                //SM>
                                cellSize = (float)EnsemblesInfoToStore.BinSize[i]; //RTIdata[i].A_CellSize;
                                upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[i] - cellSize / 2.0f;
                                //SM<

                                //JZH 2011-12-26 新版本获取当前数据组序号   ----------结束
                                //JZH 2011-12-30 防止在数据组索引以外,强制判断
                                if (i <= 0)
                                    i = 1;
                                else if (i > BinDataEnsembleNum)
                                    i = BinDataEnsembleNum;

                                CurrentIndexOfEnsemblesInfoToStore = i - 1;
                                CurrentNumXFromMousePosion = i;
                                int ArrayLength = ((Velocity[])EnsemblesInfoToStore.WaterVelocity[CurrentIndexOfEnsemblesInfoToStore]).Length;
                                //SM>
                                //i = 0;
                                //SM<

                                float h = 0;
                                float dep;
                                dep = cells * cellSize;

                                //LPJ 2013-5-25 添加自动缩放功能，动态设置最大深度 --start
                                float maxDep = dep;
                                if (BinDataEnsembleNum > 0)
                                {
                                    maxDep = (float)EnsemblesInfoToStore.bottomDepth[0];
                                    for (int iflag = 0; iflag < BinDataEnsembleNum; iflag++)
                                    {
                                        if (maxDep < (float)EnsemblesInfoToStore.bottomDepth[iflag])
                                            maxDep = (float)EnsemblesInfoToStore.bottomDepth[iflag];
                                    }
                                }
                                dep = maxDep;
                                //LPJ 2013-5-25 添加自动缩放功能，动态设置最大深度 --end

                                float uplen = upBlank + insDep;

                                //float seafaceLenToScreen;
                                //seafaceLenToScreen = 0;

                                //SM>
                                //float PixelRectangleHeight;
                                //PixelRectangleHeight = (MainPanel.Height - seafaceLenToScreen) / (dep / cellSize);  //LPJ 2013-6-8
                                float PixelRectangleHeight = 0;

                                float FirstPixel = 0;
                                float PixelsPerMeter = 0;
                                if (EnsemblesInfoToStore.RangeOfFirstBin.Count > 0)
                                {
                                    //seafaceLenToScreen = 0;
                                    cellSize = (float)EnsemblesInfoToStore.BinSize[i];
                                    upBlank = (float)EnsemblesInfoToStore.RangeOfFirstBin[i] - cellSize / 2.0f;
                                    uplen = upBlank + insDep;

                                    if (dep > 0)
                                    {
                                        PixelsPerMeter = MainPanel.Height / (dep + insDep);
                                        FirstPixel = (uplen - cellSize / 2) * PixelsPerMeter;
                                        PixelRectangleHeight = cellSize * PixelsPerMeter;
                                    }
                                }
                                //SM< 

                                //SM>
                                i = 0;
                                //if (e.Location.Y >= 5 + seafaceLenToScreen)
                                //{
                                //while (h + 5 + seafaceLenToScreen <= e.Location.Y)
                                if (e.Location.Y >= FirstPixel)
                                {
                                    while (h + FirstPixel <= e.Location.Y)
                                    //SM<
                                    {
                                        i++;
                                        h += PixelRectangleHeight;
                                        if (i == ArrayLength)
                                            break;
                                    }
                                    CurrentNumYFromMousePosion = i - 1;

                                    if (CurrentNumYFromMousePosion <= (int)EnsemblesInfoToStore.iGoodBin[CurrentIndexOfEnsemblesInfoToStore]) ////LPJ 2013-5-17 只显示有效层数的流速信息 //LPJ 2016-12-15 多显示一层
                                    {
                                        //if (CurrentIndexOfEnsemblesInfoToStore > 0)  //JZH 第一个数据也要显示
                                        if (CurrentIndexOfEnsemblesInfoToStore >= 0)
                                        {
                                            //LPJ 2013-5-17
                                            Point pnt = new Point(Cursor.Position.X, Cursor.Position.Y); //LPJ 2013-5-17

                                            //double fwaterVx, fwaterVy; //LPJ 2013-7-31
                                            //fwaterVx = ((Velocity[])EnsemblesInfoToStore.WaterVelocity[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VX;
                                            //fwaterVy = ((Velocity[])EnsemblesInfoToStore.WaterVelocity[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VY;
                                            //if(true)
                                            //{
                                            //      fwaterVx = ((Velocity[])EnsemblesInfoToStore.WaterV_GPS[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VX;
                                            //      fwaterVy = ((Velocity[])EnsemblesInfoToStore.WaterV_GPS[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VY;
                                            //}

                                            double fWaterDir = System.Math.Atan2(((Velocity[])EnsemblesInfoToStore.WaterVelocity[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VX,
                                                                                 ((Velocity[])EnsemblesInfoToStore.WaterVelocity[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion].VY);
                                            if (fWaterDir < 0)
                                                fWaterDir = fWaterDir / Math.PI * 180 + 360;
                                            else
                                                fWaterDir = fWaterDir / Math.PI * 180;

                                            string strTime = (string)EnsemblesInfoToStore.RecivedDataTime[CurrentIndexOfEnsemblesInfoToStore];
                                            string strBinNumber = (CurrentNumYFromMousePosion + 1).ToString();
                                            string strFlowSpeed;
                                            double dFlowSpeed = ((double[])EnsemblesInfoToStore.WaterSpeed[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion];
                                            if ("GPS VTG" == labelVesselRef.Text)
                                                dFlowSpeed = ((double[])EnsemblesInfoToStore.WaterSpeed_GPS[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion]; //LPJ 2013-7-31
                                            else if ("GPS GGA" == labelVesselRef.Text)
                                                dFlowSpeed = ((double[])EnsemblesInfoToStore.WaterSpeed_GPGGA[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion];
                                            else if (Resource1.String233 == labelVesselRef.Text)
                                                dFlowSpeed = ((double[])EnsemblesInfoToStore.WaterSpeed_Null[CurrentIndexOfEnsemblesInfoToStore])[CurrentNumYFromMousePosion];

                                            if (dFlowSpeed > 20)
                                                strFlowSpeed = "bad";
                                            else
                                            {
                                                strFlowSpeed = dFlowSpeed.ToString("0.00") + "(m/s)";
                                                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                                                if (!bEnglish2Metric)
                                                    strFlowSpeed = (projectUnit.MeterToFeet(dFlowSpeed, 1)).ToString("0.00") + "(ft/s)";

                                            }

                                            string strDepth = ((float)EnsemblesInfoToStore.RangeOfFirstBin[CurrentIndexOfEnsemblesInfoToStore] + CurrentNumYFromMousePosion * cellSize).ToString("0.00") + "(m)";

                                            //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                                            if (!bEnglish2Metric)
                                                strDepth = (projectUnit.MeterToFeet((float)EnsemblesInfoToStore.RangeOfFirstBin[CurrentIndexOfEnsemblesInfoToStore] + CurrentNumYFromMousePosion * cellSize, 1)).ToString("0.00") + "(ft)";

                                            //string str = Resource1.String112 + ": " + strTime + "\r\n"
                                            //    + Resource1.String268 + ":" + (CurrentIndexOfEnsemblesInfoToStore + 1).ToString() + "\r\n" //LPJ 2013-9-13 add
                                            //    + Resource1.String129 + ": " + strBinNumber + "\r\n"
                                            //    + Resource1.String102 + ": " + strFlowSpeed + "\r\n"
                                            //    + Resource1.String103 + ": " + fWaterDir.ToString("00.00") + "(Deg)" + "\r\n"
                                            //    + Resource1.String115 + ": " + strDepth;
                                           
                                            string str = Resource1.String268 + ":" + (CurrentIndexOfEnsemblesInfoToStore + 1).ToString() + ", " //LPJ 2013-9-13 add
                                                + Resource1.String129 + ":" + strBinNumber + ", "
                                                + Resource1.String102 + ":" + strFlowSpeed + ", "
                                                + Resource1.String103 + ":" + fWaterDir.ToString("00.00") + "(Deg)" + ", "
                                                + Resource1.String115 + ":" + strDepth; 

                                            //if (pnt.X < 500) //LPJ 2013-8-6
                                            //{
                                            //    int dis = 500 - pnt.X;
                                            //    ShowTip3(m_tip,pnt, dis, str);
                                            //}
                                            //else
                                            //{
                                            //    ShowTip2(m_tip,pnt, str); //LPJ 2013-5-17
                                            //}

                                            //if (str != strLast)
                                            //{
                                            //    iMainPanelStayTime = 0; //LPJ 2013-11-20 
                                            //    strLast = str;
                                            //    MainPanelStayTimer.Start();
                                            //}
                                            //if (str == strLast) //LPJ 2013-11-18 当鼠标位置改变时才显示
                                            //{
                                            //    if (iMainPanelStayTime >1)
                                            //    {
                                            //        MainTooltip.Show(str, MainPanel, e.Location.X, e.Location.Y, 5000);
                                            //        //MainPanelStayTimer.Stop();
                                            //        iMainPanelStayTime = 0;
                                            //    }
                                            //    //iMainPanelStayTime++;

                                            //}

                                            if (str != strLast)
                                            {
                                                MainTooltip.Show(str, MainPanel, e.Location.X, e.Location.Y, 5000);
                                            }
                                            strLast = str;
                                         
                                        }
                                        else
                                        {

                                        }
                                    }

                                }
                            }
                        }
                    }
                }
                else
                {
                    //this.m_tip.Visible = false; //LPJ 2013-9-16
                    MainTooltip.RemoveAll();
                }
             
            }
            catch
            {
                return;
            }

        }

        //LPJ 2013-11-20 当鼠标停在位置上后开始计时
        //private System.Timers.Timer MainPanelStayTimer = new System.Timers.Timer(250);
        //private void MainPanelStayTimer_Elapsed(object sender,System.Timers.ElapsedEventArgs e)
        //{ 
        //    iMainPanelStayTime++;  
        //    if (iMainPanelStayTime == 2)
        //        MainPanelStayTimer.Stop();
        //}
       

        private string strLast = ""; //LPJ 2013-11-18 由于鼠标放在图上时，闪烁太频繁了，所以进行一个判断，如果位置没变，则不再重复显示
        //private int iMainPanelStayTime = 0; //LPJ 2013-11-20 当鼠标放在MainPanel中某一个色块的时刻超过1秒钟，才显示提示

        private ToolTip MainTooltip = new ToolTip(); //LPJ 2013-9-25 设置一个提示框，用于提示鼠标滑动的位置
        private void ProcessBar_Paint(object sender, PaintEventArgs e)
        {
            using (Graphics g = e.Graphics)
            {
                if (DrawRecFlag)
                {
                    g.DrawRectangle(Pens.DimGray, 0, 0, ProcessBar.Width - 1, ProcessBar.Height - 1);
                    g.DrawLine(Pens.White, 0, ProcessBar.Height / 2, ProcessBar.Width - 1, ProcessBar.Height / 2);
                }
                else
                {
                    g.DrawRectangle(Pens.Black, 0, 0, ProcessBar.Width - 1, ProcessBar.Height - 1);
                    g.DrawLine(Pens.DimGray, 0, ProcessBar.Height / 2, ProcessBar.Width - 1, ProcessBar.Height / 2);
                }
                g.DrawLine(Pens.LawnGreen, 0, ProcessBar.Height / 2, ClickPzn, ProcessBar.Height / 2);
                g.FillRectangle(Brushes.LightSteelBlue, ClickPzn - 2, 4, 5, ProcessBar.Height - 8);
                g.DrawLine(Pens.Red, ClickPzn, 4, ClickPzn, ProcessBar.Height - 5);
            }
        }

        private void ProcessBar_MouseEnter(object sender, EventArgs e)
        {
            if (playBackMode == true)
            {
                DrawRecFlag = true;
                ProcessBar.Refresh();
            }
        }

        private void ProcessBar_MouseLeave(object sender, EventArgs e)
        {
            if (playBackMode == true)
            {
                DrawRecFlag = false;
                ProcessBar.Refresh();
            }
        }

        bool TrackOverPlay = false;
        private void ProcessBar_MouseDown(object sender, MouseEventArgs e)
        {
            //MessageBox.Show("here");
            if (playBackMode == true)
            {
                MouseDownFlag = true;
                ClickPzn = e.X;
                if (ClickPzn <= 0)
                {
                    ClickPzn = 1;
                }
                else if (ClickPzn > ProcessBar.Width)
                {
                    ClickPzn = ProcessBar.Width;
                }
                BinDataEnsembleNum = (int)(EnsembleNumOfAllFiles * ClickPzn / ProcessBar.Width) - 1;
                //MessageBox.Show ( ClickPzn.ToString());
                //InsInfotextBox.Text = ClickPzn.ToString();
                /////////找到LinesPosition > LinesNumOfAllFiles - 1的原因后可以删除
                if (BinDataEnsembleNum > EnsembleNumOfAllFiles - 1)
                {
                    BinDataEnsembleNum = EnsembleNumOfAllFiles - 1;
                }
                else if (BinDataEnsembleNum < 1)
                {
                    BinDataEnsembleNum = 0;
                    //MouseWheelScale = 0.1f; //LPJ 2013-9-24 每次新开始一个测回，令航迹图的比例尺归为最小
                    MouseWheelScale = 1;
                }

                /////////Modified 2011-10-28 $$
                //JZH 2012-01-04  取消TrackOverPlay的判断 回放数据已经全部载入
                //if (BinDataEnsembleNum > restoreNum - 1)
                //{
                //    TrackOverPlay = true;
                //}
                //else
                //{
                //    TrackOverPlay = false;
                //}

                if (CurrentIndexOfEnsemblesInfoToStore >= BinDataEnsembleNum) //Modified 2011-10-27, never get here
                {
                    CurrentNumXFromMousePosion = BinDataEnsembleNum - 1;
                    CurrentIndexOfEnsemblesInfoToStore = CurrentNumXFromMousePosion;
                }
                //timeKnot = (float)BinDataEnsembleNum * 1000;
                //TimeLable.Text = NumToTime(timeKnot * (float)2.25) + "/" + DisPlayTimeLenth; //Modified 2011-7-13, 
                TimeLable.Text = BinDataEnsembleNum + " / " + EnsembleNumOfAllFiles; //Modified 2011-10-26
                //Modified 2011-9-13
                //ArraySizeCounter = BinDataEnsembleNum;
                //InsInfotextBox.Text =  CurrentIndexOfEnsemblesInfoToStore.ToString();

                //MainPanel.Refresh();
                //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                this.BeginInvoke(TrackPanel_Refresh);
                //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16  //JZH 2012-01-12
             
                ProcessBar.Refresh();
                HPRpictureBox.Refresh();

                //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                //panelSerialTime.Refresh(); //LPJ 2013-9-22

                this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

                GGAsaveCount = BinDataEnsembleNum; //Modified 2011-10-26
                GPSdisplayPanel.Refresh();  //Modified 2011-10-26

                PlayBackTimer.Stop();
              
            }
        }

        private void ProcessBar_MouseMove(object sender, MouseEventArgs e)
        {
            if (playBackMode == true)
            {
                if (MouseDownFlag == true && e.Button == MouseButtons.Left)
                {
                    ClickPzn = e.X;
                    if (ClickPzn <= 0)
                    {
                        ClickPzn = 1;
                    }
                    else if (ClickPzn > ProcessBar.Width)
                    {
                        ClickPzn = ProcessBar.Width;
                    }
                    BinDataEnsembleNum = (int)(EnsembleNumOfAllFiles * ClickPzn / ProcessBar.Width) - 1;

                    /////////找到LinesPosition > LinesNumOfAllFiles - 1的原因后可以删除
                    if (BinDataEnsembleNum > EnsembleNumOfAllFiles - 1)
                    {
                        BinDataEnsembleNum = EnsembleNumOfAllFiles - 1;
                    }
                    else if (BinDataEnsembleNum < 1)
                    {
                        BinDataEnsembleNum = 1;
                    }
                    /////////

                    if (CurrentIndexOfEnsemblesInfoToStore >= BinDataEnsembleNum)
                    {
                        CurrentNumXFromMousePosion = BinDataEnsembleNum - 1;
                        CurrentIndexOfEnsemblesInfoToStore = CurrentNumXFromMousePosion;
                    }
                    //timeKnot = (float)BinDataEnsembleNum * 1000;
                    //TimeLable.Text = NumToTime(timeKnot) + "/" + DisPlayTimeLenth;
                    TimeLable.Text = BinDataEnsembleNum + " / " + EnsembleNumOfAllFiles; //Modified 2011-10-26

                    //MainPanel.Refresh();
                    //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                    this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    this.BeginInvoke(TrackPanel_Refresh);
                    //if(RiverAuthority == true)  RiverPanel.Refresh();   //Modified 2011-10-16  //JZH 2012-01-12
                 
                    ProcessBar.Refresh();
                    HPRpictureBox.Refresh();

                    //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                    //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                    //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                    //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                    //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                    //panelSerialTime.Refresh(); //LPJ 2013-9-22

                    this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11
                }
            }
        }

        private string NumToTime(float mt)//毫秒->h:m:s
        {
            int hour = 0;
            int minute = 0;
            int second = 0;
            if (mt >= 3600000)
            {
                hour = (int)mt / 3600000;
                mt -= hour * 3600000;
            }
            if (mt >= 60000)
            {
                minute = (int)mt / 60000;
                mt -= minute * 60000;
            }
            if (mt >= 1000)
            {
                second = (int)mt / 1000;
                mt -= second * 1000;
            }
            string time = hour.ToString("00").PadLeft(2) + ":" + minute.ToString("00").PadLeft(2) + ":" + second.ToString("00").PadLeft(2);
            return time;
        }

        private void ProcessBar_MouseUp(object sender, MouseEventArgs e)
        {
            if (playBackMode == true)
            {
                MouseDownFlag = false;
                if (!PlayBackPauseFlag)
                {
                    if(!bPlaybackStop) //LPJ 2013-11-19
                    PlayBackTimer.Start();
                    bPlaybackStop = false; //LPJ 2013-11-19
                }
            }
        }

        //CAdvancedCfg.AdvancedConfiguration advancedConf = new CAdvancedCfg.AdvancedConfiguration(); //LPJ 2013-8-5 该变量用于保存提取的高级配置

        //LPJ 2013-9-23 打开下一个可读数据
        public void btnOpenNext(string strNextPath)
        {
            try
            {
                closeComm();
                InitialAllParam();

                //linkLabelSystemSetting.Visible = false; //LPJ 2013-6-24 当回放模式时，系统设置不可修改 //LPJ 2013-11-20
                linkLabelCompassCalibration.Visible = false; //LPJ 2013-6-28
                linkLabelGPSConf.Visible = false;
                linkLabelSettingTime.Visible = false;
                linkLabelSystemTest.Visible = false;
                linkLabelUpdateFirmware.Visible = false;
                linkLabelBeamCheck.Visible = false; //LPJ 2014-6-20
                linkLabelDownload.Visible = false;

                linkLabelHeadingOffset.Visible = false; //LPJ 2013-11-18
                //btnGPSCalibration.Visible = false; //LPJ 2013-11-15

                trackBarMaxV.Value = 50; //LPJ 2013-6-7

                if (!bEnglish2Metric)
                {
                    labelMavV.Text = (projectUnit.MeterToFeet(5.0, 1)).ToString("0.00") + " ft/s";
                }
                else
                {
                    labelMavV.Text = "5.0 m/s"; //LPJ 2013-6-7
                }

                #region new load data
                string strFile = strNextPath.Substring(0, strNextPath.LastIndexOf(".")); //strFile="C:\\E000001"
                PathStr = strFile;

                playBackMode = true;

                //读取配置文件
                try
                {
                    GetFileToSmartPage(strFile + ".cfg"); //LPJ 2013-6-21 读取配置文件到smartPage
                    //CAdvancedCfg cAdcfg = new CAdvancedCfg(); //LPJ 2014-2-19 读取回放文件中的高级配置
                    //cAdcfg.GetFileToAdvancedMode(strFile + ".cfg", ref advancedConf);
                }
                catch (System.Exception eee)
                {
                    MessageBox.Show(eee.Message);
                }
                //读取原始数据
                RTIdata.AddRange(Calcflow.RiverDischargeCalculate.ReadEnsembleRawData(strNextPath));
                EnsembleNumOfAllFiles = RTIdata.Count();

                //读取GPS数据
                GetFileToGPS(strFile + ".gps");

               
                labelStep1.Visible = false; //LPJ 2013-6-24
                labelStep2.Visible = false;
                labelStep3.Visible = false;
                labelStep4.Visible = false;
                labelStep5.Visible = false;
                labelStep6.Visible = false;

                textBoxHelpTips.Text = Resource1.String19 + "\r\n\r\n" + Resource1.String219;

                if (!bEnglish2Metric)
                {
                    try
                    {
                        insDep = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                    }
                    catch
                    {
                        insDep = (float)(projectUnit.FeetToMeter(0.1, 1));
                    }
                    cellSize = (float)(projectUnit.FeetToMeter(cellSize, 1));
                    cells = (long)(projectUnit.FeetToMeter(cells, 1));
                }
                else
                {
                    try
                    {
                        insDep = float.Parse(labelTransducerDepth.Text);
                    }
                    catch
                    {
                        insDep = 0.1f;
                    }
                }

                //int i = str.LastIndexOf("\\");
                //string pjtName = str.Substring(i + 1);

                tabControl4.SelectedIndex = 1; //LPJ 2013-8-5 回放数据时自动切换到测流页
                //    ResizeControls(); //LPJ 2013-8-5 
                ////创建并启动回放线程
                //MessageBox.Show(EnsembleNumOfAllFiles.ToString());
                //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000);
                //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000 * (float)2.25); //Modified 2011-7-12 Try to display total time
                PlayBackTimer = new System.Timers.Timer();
                PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
                PlayBackTimeLenth = 1000; //Modified 2011-7-14

                PlayBackTimer.Interval = PlayBackTimeLenth;
                PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数

                LoadAllData(); //LPJ 2013-7-2 一次载入所有回放数据

                ProcessBar.Refresh();
                //PlayBackTimer.Start();   //LPJ 2013-9-18 回放时先显示整个测量结果，然后点击“回放”按钮开始回放 --start

                BinDataEnsembleNum = EnsembleNumOfAllFiles;
                current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - ((float)EnsemblesInfoToStore.RecivedTime[0])) * 1000)).ToString();
                current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[BinDataEnsembleNum - 1];  //JZH 2012-02-18 显示当前数据组时间
                current_EsambleTotaleNum = BinDataEnsembleNum.ToString();

                //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
                arrAmplitude = RTIdata[BinDataEnsembleNum - 1].Amplitude;
                arrCorrelation = RTIdata[BinDataEnsembleNum - 1].Correlation;
                pictureBox_W_A.Refresh();
                pictureBox_W_C.Refresh();

                this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 
                this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
                this.BeginInvoke(RefreshNavigation);
                this.BeginInvoke(RefreshOthers);
                MainPanelPaint();
                TrackPanelPaint();

                #endregion
            }
            catch
            {
            }
        }

        public void PalyBackBtn_Click(object sender, EventArgs e)
        {
            if (playBackMode == false)
            {
                bool AllowPlayBackFlag = false;
                if (projectHasStarted == false)
                {
                    AllowPlayBackFlag = true;
                }
                else
                {
                    //DialogResult r = MessageBox.Show("系统正在进行工程测量，是否要保存工程文件？", "提示",
                    //   MessageBoxButtons.YesNoCancel, MessageBoxIcon.Asterisk); //LPJ 2012-4-20
                    //DialogResult r = MessageBox.Show(Resource1.String18, Resource1.String19,   //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                    //  MessageBoxButtons.YesNoCancel, MessageBoxIcon.Asterisk);   

                    //if (r != DialogResult.Cancel)    //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                    {
                        AllowPlayBackFlag = true;

                        //if (DialogResult.Yes == r)   //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                        {

                            //if (EnsemblesInfoToStore.ChangeNumSum <= restoreNum && EnsemblesInfoToStore.ChangeNumSum > 0/*&& bStartMeasQ == true*/)
                            //{
                            //    fileNum++;
                            //    SaveAsBinaryFormat(EnsemblesInfoToStore, fileNum); //保存playback数据
                            //}

                            //LPJ 2012-05-04 开始测量后才可以保存数据
                            //if (SaveEnsemblesInfo.ChangeNumSum <= restoreNum && SaveEnsemblesInfo.ChangeNumSum > 0)
                            //{
                            //    fileNum++;
                            //    SaveAsBinaryFormat(SaveEnsemblesInfo, fileNum); //保存playback数据
                            //}
                        }
                        //else    //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                        //{
                        //    try
                        //    {
                        //        Directory.Delete(newPath, true);
                        //    }
                        //    catch (System.Exception ee)
                        //    {
                        //        MessageBox.Show(ee.Message);
                        //    }
                        //}   //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                    }
                    //else     //LPJ 2013-4-15 取消提示“是否要保存工程文件？”，默认保存
                    //    AllowPlayBackFlag = false;
                }
                if (AllowPlayBackFlag == true)
                {
                    closeComm();

                    InitialAllParam();
                    //MainPanel.Refresh();
                    //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                   /* this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16 //JZH 2012-01-12
                 
                    HPRpictureBox.Refresh();

                    tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                    tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                    tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                    tabPage_Roll.Refresh();  //LPJ 2013-5-18
                    tabPage_BoatWater.Refresh();  //LPJ 2013-5-18*/
                    //linkLabelSystemSetting.Visible = false; //LPJ 2013-6-24 当回放模式时，系统设置不可修改
                    linkLabelCompassCalibration.Visible = false; //LPJ 2013-6-28
                    linkLabelGPSConf.Visible = false;
                    linkLabelSettingTime.Visible = false;
                    linkLabelSystemTest.Visible = false;
                    linkLabelUpdateFirmware.Visible = false;
                    //btnGPSCalibration.Visible = false; //LPJ 2013-11-15
                    linkLabelHeadingOffset.Visible = false; //LPJ 2013-11-18
                    linkLabelBeamCheck.Visible = false; //LPJ 2014-6-20
                    linkLabelDownload.Visible = false;

                    //this.hScrollBarPlaybackSpeed.Show(); //Modified 2011-7-13, record mode, show playback speed srollbar
                    //this.labelPlaybackSpeed.Show();      //Modified 2011-7-13, record mode, dhow playback speed srollbar lable
                 

                    trackBarMaxV.Value = 50; //LPJ 2013-6-7

                    //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                    if (!bEnglish2Metric)
                    {
                        labelMavV.Text = (projectUnit.MeterToFeet(5.0, 1)).ToString("0.00") + " ft/s";
                    }
                    else
                    {
                        labelMavV.Text = "5.0 m/s"; //LPJ 2013-6-7
                    }

                    #region load playback data from rawData

                    OpenFileDialog openFile = new OpenFileDialog();
                    openFile.InitialDirectory = PathStr;
                    openFile.Filter = "BIN(*.bin)|*.bin|ENS(*.ENS)|*.ENS|All Document(*.*)|*.*";
                    openFile.Title = "Open File";
                    if (openFile.ShowDialog() == DialogResult.OK)
                    {
                        string strFile = openFile.FileName.Substring(0, openFile.FileName.LastIndexOf(".")); //strFile="C:\\E000001"
                        PathStr = strFile;

                        playBackMode = true;

                        //读取配置文件
                        try
                        {
                            GetFileToSmartPage(strFile + ".cfg"); //LPJ 2013-6-21 读取配置文件到smartPage
                            //CAdvancedCfg cAdcfg = new CAdvancedCfg(); //LPJ 2014-2-19 读取回放文件中的高级配置
                            //cAdcfg.GetFileToAdvancedMode(strFile + ".cfg", ref advancedConf);
                        }
                        catch (System.Exception eee)
                        {
                            MessageBox.Show(eee.Message);
                        }
                        //读取原始数据
                        RTIdata.AddRange(Calcflow.RiverDischargeCalculate.ReadEnsembleRawData(openFile.FileName));
                        EnsembleNumOfAllFiles = RTIdata.Count();

                        //-RMa 11/23/2020
                        #region Backscatter
                        openFileBackScatter(openFile.FileName);
                        #endregion

                        //读取GPS数据
                        GetFileToGPS(strFile + ".gps");
                      
                     
                        labelStep1.Visible = false; //LPJ 2013-6-24
                        labelStep2.Visible = false;
                        labelStep3.Visible = false;
                        labelStep4.Visible = false;
                        labelStep5.Visible = false;
                        labelStep6.Visible = false;

                        textBoxHelpTips.Text = Resource1.String19 + "\r\n\r\n" + Resource1.String219;

                        if (!bEnglish2Metric)
                        {
                            try
                            {
                                insDep = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                            }
                            catch
                            {
                                insDep = (float)(projectUnit.FeetToMeter(0.1, 1));
                            }
                            cellSize = (float)(projectUnit.FeetToMeter(cellSize, 1));
                            cells = (long)(projectUnit.FeetToMeter(cells, 1));
                        }
                        else
                        {
                            try
                            {
                                insDep = float.Parse(labelTransducerDepth.Text);
                            }
                            catch
                            {
                                insDep = 0.1f;
                            }
                        }

                        //int i = str.LastIndexOf("\\");
                        //string pjtName = str.Substring(i + 1);

                        tabControl4.SelectedIndex = 1; //LPJ 2013-8-5 回放数据时自动切换到测流页
                        //    ResizeControls(); //LPJ 2013-8-5 
                        ////创建并启动回放线程
                        //MessageBox.Show(EnsembleNumOfAllFiles.ToString());
                        //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000);
                        //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000 * (float)2.25); //Modified 2011-7-12 Try to display total time
                        PlayBackTimer = new System.Timers.Timer();
                        PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
                        PlayBackTimeLenth = 1000; //Modified 2011-7-14

                        PlayBackTimer.Interval = PlayBackTimeLenth;
                        PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
                        /*
                        {
                            ////Modified 2011-8-3 try to read the length of GSP file HHHHHHHHHHHHHHHH
                            string str1 = PathStr.Substring(0, x);
                            string strGPS = str1;
                            StreamReader srr;
                            strGPS += "\\GPS";       //Modified  add for open GPSdata file

                            strGPS += ("\\" + Version_2_CurrentGPSFileName);
                            srr = new StreamReader(strGPS);

                            int MaxCount = 2000000;
                            char[] buffer1 = new char[MaxCount];
                            int count = srr.Read(buffer1, 0, MaxCount);
                            GPSFileCount = count / 173; //GPS one ping length 

                            if (count > MaxCount)
                            {
                                MaxCount *= 10;
                                StreamReader srr2 = new StreamReader(strGPS);
                                count = srr.Read(buffer1, 0, MaxCount);
                                GPSFileCount = count / 173; //GPS one ping length 
                            }
                            //MessageBox.Show("Count" + GPSFileCount.ToString());
                        }*/

                        LoadAllData(); //LPJ 2013-7-2 一次载入所有回放数据

                        ProcessBar.Refresh();
                        //PlayBackTimer.Start();   //LPJ 2013-9-18 回放时先显示整个测量结果，然后点击“回放”按钮开始回放 --start

                        //LPJ 2015-9-22 当用户选择获取艏向偏差
                        if (checkBoxGetHeadingOffset.Checked)
                        {
                            GetGPSHeadingOffset();
                        }


                        BinDataEnsembleNum = EnsembleNumOfAllFiles;
                        current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - ((float)EnsemblesInfoToStore.RecivedTime[0])) * 1000)).ToString();
                        current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[BinDataEnsembleNum - 1];  //JZH 2012-02-18 显示当前数据组时间
                        current_EsambleTotaleNum = BinDataEnsembleNum.ToString();

                        //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                        this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
                        arrAmplitude = RTIdata[BinDataEnsembleNum - 1].Amplitude;
                        arrCorrelation = RTIdata[BinDataEnsembleNum - 1].Correlation;
                        pictureBox_W_A.Refresh();
                        pictureBox_W_C.Refresh();

                        this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 
                        this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
                        this.BeginInvoke(RefreshNavigation);
                        this.BeginInvoke(RefreshOthers);

                        TrackPanelPaint();
                        MainPanelPaint();
                        
                        //btnScaleIncrease_Click(sender, e);
                        //btnScaleDecrease_Click(sender, e);
                    }
 
                    #endregion

                    #region 取消旧的载入回放文件的方式
                    /*
                    //MessageBox.Show("回放时请注意在《工程设置》栏中选定回放数据的版本。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
                    folderBrowserDialog1.RootFolder = Environment.SpecialFolder.Desktop;//创建选择文件夹窗口
                    if (PathStr != null) //LPJ 2013-1-15
                    {
                        folderBrowserDialog1.SelectedPath = PathStr;
                    }
                    else
                    {
                        folderBrowserDialog1.SelectedPath = Environment.CurrentDirectory; //LPJ 2013-1-14
                    }
                    if (folderBrowserDialog1.ShowDialog() == DialogResult.OK)//选取路径后。。。
                    {
                        //获取数据路径及信息文件名
                        PathStr = folderBrowserDialog1.SelectedPath;
                        //newPath = PathStr; //Modified 2011-12-10
                        CurrentPlaybackDirectory = PathStr;
                        int x = PathStr.LastIndexOf("\\");
                        string str = PathStr.Substring(0, x);

                        //LPJ 2012-06-13 显示文件路径
                        this.Text = PathStr;
                        
                        if (!File.Exists(PathStr + "\\info.infm"))//寻找回放信息文件，如果失败。。。
                        {
                            // MessageBox.Show("操作失败，回放所必需的文件丢失！"); //LPJ 2012-4-20
                            MessageBox.Show(Resource1.String20);
                        }
                        else//如果成功。。。
                        {
                            //改变显示模式（由实时转变为回放），改变按钮颜色
                            playBackMode = true;

                            labelStep1.Visible = false; //LPJ 2013-6-24
                            labelStep2.Visible = false;
                            labelStep3.Visible = false;
                            labelStep4.Visible = false;
                            labelStep5.Visible = false;
                            labelStep6.Visible = false;

                            textBoxHelpTips.Text = Resource1.String19 + "\r\n\r\n" + Resource1.String219;

                            //PalyBackBtn.ForeColor = Color.Blue;
                            //RealDisPlay.ForeColor = Color.White;
                            //Modified2011-12-10
                            string newPath = CurrentPlaybackDirectory;   //defined at playback_clicked, Modified 2011-8-2
                            //RiverPlaybackPath = newPath;
                            int xx = newPath.LastIndexOf("\\");
                            //Modified 2011-8-29 Try to see if the playback GPS file exits
                            string newPath1 = newPath.Substring(0, xx);
                            string playbackGPSdataPath_1 = "", playbackGPSdataPath_2 = "";
                            playbackGPSdataPath_1 = newPath1 + "\\GPS" + "\\" + Version_1_CurrentGPSFileName;
                            playbackGPSdataPath_2 = newPath1 + "\\GPS" + "\\" + Version_2_CurrentGPSFileName;

                            playbackGPSdataPath = playbackGPSdataPath_2; // = newPath1 + "\\GPS" + "\\" + Version_2_CurrentGPSFileName;
                            Version_2_CurrentGPSFileName = "GPSdata" + CurrentGPSFileNumber.ToString("000000") + ".txt";

                            if (!File.Exists(playbackGPSdataPath))//寻找回放信息文件，如果失败。。。
                            {
                                playbackGPSdataPath = playbackGPSdataPath_2;
                            }

                            //读取信息文件的参数设置
                            Dinfo = new DirectoryInfo(PathStr);
                            BinDataFileNum = (Dinfo.GetFiles("*.dat")).Length;
                            StreamReader sr = new StreamReader(PathStr + "\\info.infm");
                            try
                            {
                                MaxVelocityByCostommer = float.Parse(sr.ReadLine());
                                EnsembleNumOfAllFiles = int.Parse(sr.ReadLine());
                                //EnsembleNumOfAllFiles Modified 2011-8-3, use this number to stop playback  HHHHHHHHHHH
                                TimeLable.Text = EnsembleNumOfAllFiles.ToString(); //Modified 2011-11-3
                            }
                            catch (System.Exception ee)
                            {
                                MessageBox.Show(ee.Message);
                            }
                            try  //JZH 2012-06-17 测试发现当左右岸距离输入小数时程序出错！！！！！！
                            {
                              //  readCfg(str + "\\SysCfg"); //LPJ 2013-6-21
                                GetFileToSmartPage(str + "\\SysCfg\\Config.cfg"); //LPJ 2013-6-21 读取配置文件到smartPage

                                //LPJ 2014-2-19 读取回放文件中的高级配置
                                CAdvancedCfg cAdcfg = new CAdvancedCfg();
                                cAdcfg.GetFileToAdvancedMode(str + "\\SysCfg\\Config.cfg", ref advancedConf);

                            }
                            catch (System.Exception eee)
                            {
                                MessageBox.Show(eee.Message);
                            }
                            if (labelMeasMode.Text != Resource1.String235 && labelMeasMode.Text != "") //LPJ 2013-6-22
                            {
                                WaterAvgNum = 2;
                            }

                            //cellSize = float.Parse(textBinSize.Text);
                            //cells = float.Parse(textBinNum.Text);
                            //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1
                            if (!bEnglish2Metric)
                            {
                                try
                                {
                                    insDep = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                                }
                                catch
                                {
                                    insDep = (float)(projectUnit.FeetToMeter(0.1, 1));
                                }
                                cellSize=(float)(projectUnit.FeetToMeter(cellSize,1));
                                cells = (long)(projectUnit.FeetToMeter(cells, 1));
                            }
                            else
                            {
                                try
                                {
                                    insDep = float.Parse(labelTransducerDepth.Text);
                                }
                                catch
                                {
                                    insDep = 0.1f;
                                }
                            }
                            
                            int i = str.LastIndexOf("\\");
                            string pjtName = str.Substring(i + 1);

                            tabControl4.SelectedIndex = 1; //LPJ 2013-8-5 回放数据时自动切换到测流页
                        //    ResizeControls(); //LPJ 2013-8-5 
                            ////创建并启动回放线程
                            //MessageBox.Show(EnsembleNumOfAllFiles.ToString());
                            //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000);
                            DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000 * (float)2.25); //Modified 2011-7-12 Try to display total time
                            PlayBackTimer = new System.Timers.Timer();
                            PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
                            PlayBackTimeLenth = 1000; //Modified 2011-7-14
                         
                            PlayBackTimer.Interval = PlayBackTimeLenth;
                            PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数

                            {
                                ////Modified 2011-8-3 try to read the length of GSP file HHHHHHHHHHHHHHHH
                                string str1 = PathStr.Substring(0, x);
                                string strGPS = str1;
                                StreamReader srr;
                                strGPS += "\\GPS";       //Modified  add for open GPSdata file

                                strGPS += ("\\" + Version_2_CurrentGPSFileName);
                                srr = new StreamReader(strGPS);
                              
                                int MaxCount = 2000000;
                                char[] buffer1 = new char[MaxCount];

                                int count = srr.Read(buffer1, 0, MaxCount);

                                GPSFileCount = count / 173; //GPS one ping length 

                                if (count > MaxCount)
                                {
                                    MaxCount *= 10;
                                    StreamReader srr2 = new StreamReader(strGPS);
                                    count = srr.Read(buffer1, 0, MaxCount);
                                    GPSFileCount = count / 173; //GPS one ping length 

                                }
                                //MessageBox.Show("Count" + GPSFileCount.ToString());
                            }

                            LoadAllData(); //LPJ 2013-7-2 一次载入所有回放数据

                            ProcessBar.Refresh();
                            //PlayBackTimer.Start();   //LPJ 2013-9-18 回放时先显示整个测量结果，然后点击“回放”按钮开始回放 --start
                           
                            BinDataEnsembleNum = EnsembleNumOfAllFiles;
                            current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - ((float)EnsemblesInfoToStore.RecivedTime[0])) * 1000)).ToString();
                            current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[BinDataEnsembleNum - 1];  //JZH 2012-02-18 显示当前数据组时间
                            current_EsambleTotaleNum = BinDataEnsembleNum.ToString();

                            //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                            this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
                            arrAmplitude = RTIdata[BinDataEnsembleNum - 1].Amplitude;  
                            arrCorrelation = RTIdata[BinDataEnsembleNum - 1].Correlation; 
                            pictureBox_W_A.Refresh(); 
                            pictureBox_W_C.Refresh(); 

                            this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 
                            this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
                            this.BeginInvoke(RefreshNavigation); 
                            this.BeginInvoke(RefreshOthers); 
                            MainPanelPaint();

                            //LPJ 2013-9-18 回放时先显示整个测量结果，然后点击“回放”按钮开始回放 --end
                        }
                    }
                    else
                    {
                        //PalyBackBtn.ForeColor = Color.White;
                        //RealDisPlay.ForeColor = Color.Blue;
                    }
                     * */
                    #endregion

                }
            }
            else
            {
                //if (DialogResult.Yes ==
                //MessageBox.Show("是否放弃当前回放，开始新的项目回放？", "提示", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk)) //LPJ 2012-4-20
                if (DialogResult.Yes ==
               MessageBox.Show(Resource1.String24, Resource1.String19, MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk))
                {
                    PlayBackTimer.Stop();
                    bPlaybackStop = true;
                    PlayBackTimer.Close();
                    //PalyBackBtn.ForeColor = Color.White;
                    //RealDisPlay.ForeColor = Color.White;
                    InitialAllParam();
                    //MainPanel.Refresh();
                    //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                    this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    this.BeginInvoke(TrackPanel_Refresh);
                    //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16 //JZH 2012-01-12
                 
                    HPRpictureBox.Refresh();

                    //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                    //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                    //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                    //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                    //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                    //panelSerialTime.Refresh(); //LPJ 2013-9-22

                    this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

                    //linkLabelSystemSetting.Visible = false; //LPJ 2013-6-24 当回放模式时，系统设置不可修改
                    linkLabelCompassCalibration.Visible = false; //LPJ 2013-6-28
                    linkLabelGPSConf.Visible = false;
                    linkLabelSettingTime.Visible = false;
                    linkLabelSystemTest.Visible = false;
                    linkLabelUpdateFirmware.Visible = false;
                    linkLabelBeamCheck.Visible = false; //LPJ 2014-6-20
                    linkLabelDownload.Visible = false;

                    //btnGPSCalibration.Visible = false; //LPJ 2013-11-15
                    linkLabelHeadingOffset.Visible = false; //LPJ 2013-11-18

                    #region load playback data from rawData

                    OpenFileDialog openFile = new OpenFileDialog();
                    openFile.InitialDirectory = PathStr;
                    openFile.Filter = "BIN(*.bin)|*.bin|ENS(*.ENS)|*.ENS|All Document(*.*)|*.*";
                    openFile.Title = "Open File";
                    if (openFile.ShowDialog() == DialogResult.OK)
                    {
                        string strFile = openFile.FileName.Substring(0, openFile.FileName.LastIndexOf(".")); //strFile="C:\\E000001"
                        PathStr = strFile;

                        playBackMode = true;

                        //读取配置文件
                        try
                        {
                            GetFileToSmartPage(strFile + ".cfg"); //LPJ 2013-6-21 读取配置文件到smartPage
                            //CAdvancedCfg cAdcfg = new CAdvancedCfg(); //LPJ 2014-2-19 读取回放文件中的高级配置
                            //cAdcfg.GetFileToAdvancedMode(strFile + ".cfg", ref advancedConf);
                        }
                        catch (System.Exception eee)
                        {
                            MessageBox.Show(eee.Message);
                        }
                        //读取原始数据
                        RTIdata.AddRange(Calcflow.RiverDischargeCalculate.ReadEnsembleRawData(openFile.FileName));
                        EnsembleNumOfAllFiles = RTIdata.Count();

                        //-RMa 11/23/2020
                        #region Backscatter
                        openFileBackScatter(openFile.FileName);
                        #endregion

                        //读取GPS数据
                        GetFileToGPS(strFile + ".gps");

                       
                        labelStep1.Visible = false; //LPJ 2013-6-24
                        labelStep2.Visible = false;
                        labelStep3.Visible = false;
                        labelStep4.Visible = false;
                        labelStep5.Visible = false;
                        labelStep6.Visible = false;

                        textBoxHelpTips.Text = Resource1.String19 + "\r\n\r\n" + Resource1.String219;

                        if (!bEnglish2Metric)
                        {
                            try
                            {
                                insDep = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                            }
                            catch
                            {
                                insDep = (float)(projectUnit.FeetToMeter(0.1, 1));
                            }
                            cellSize = (float)(projectUnit.FeetToMeter(cellSize, 1));
                            cells = (long)(projectUnit.FeetToMeter(cells, 1));
                        }
                        else
                        {
                            try
                            {
                                insDep = float.Parse(labelTransducerDepth.Text);
                            }
                            catch
                            {
                                insDep = 0.1f;
                            }
                        }

                        //int i = str.LastIndexOf("\\");
                        //string pjtName = str.Substring(i + 1);

                        tabControl4.SelectedIndex = 1; //LPJ 2013-8-5 回放数据时自动切换到测流页
                        //    ResizeControls(); //LPJ 2013-8-5 
                        ////创建并启动回放线程
                        //MessageBox.Show(EnsembleNumOfAllFiles.ToString());
                        //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000);
                        //DisPlayTimeLenth = NumToTime(EnsembleNumOfAllFiles * 1000 * (float)2.25); //Modified 2011-7-12 Try to display total time
                        PlayBackTimer = new System.Timers.Timer();
                        PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
                        PlayBackTimeLenth = 1000; //Modified 2011-7-14

                        PlayBackTimer.Interval = PlayBackTimeLenth;
                        PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
                       
                        LoadAllData(); //LPJ 2013-7-2 一次载入所有回放数据

                        //LPJ 2015-9-22 当用户选择获取艏向偏差
                        if (checkBoxGetHeadingOffset.Checked)
                        {
                            GetGPSHeadingOffset();
                        }


                        ProcessBar.Refresh();
                        //PlayBackTimer.Start();   //LPJ 2013-9-18 回放时先显示整个测量结果，然后点击“回放”按钮开始回放 --start

                        BinDataEnsembleNum = EnsembleNumOfAllFiles;
                        current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - ((float)EnsemblesInfoToStore.RecivedTime[0])) * 1000)).ToString();
                        current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[BinDataEnsembleNum - 1];  //JZH 2012-02-18 显示当前数据组时间
                        current_EsambleTotaleNum = BinDataEnsembleNum.ToString();

                        //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                        this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
                        arrAmplitude = RTIdata[BinDataEnsembleNum - 1].Amplitude;
                        arrCorrelation = RTIdata[BinDataEnsembleNum - 1].Correlation;
                        pictureBox_W_A.Refresh();
                        pictureBox_W_C.Refresh();

                        this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 
                        this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
                        this.BeginInvoke(RefreshNavigation);
                        this.BeginInvoke(RefreshOthers);
                        MainPanelPaint();
                        TrackPanelPaint();
                    }

                    #endregion
                    
                }
            }
            if (playBackMode)
            {
                GPSdisplayLength = 5000;
            }
            else
            {
                GPSdisplayLength = 500;
            }
        }

        #region Backscatter open file
        //-RMa 11/23/2020
        private void openFileBackScatter(string filePath)
        {
            //read from file
            #region method 2
            iStartEnsemble = 0; //-RMa 11/25/2020
            iEndEnsemble = 1;
            hScrollBar_BS.Value = 0;
            hScrollBar_BS.LargeChange = 1;

            long nBytesRead;
            //long nBytes;
            string exceptionmessage;

            //DecodeState = 0;
            //DataBuffReadIndex = 0;
            DataBuffWriteIndex = 0;

            BackScatter.DataBuffWriteIndex = 0;
            BackScatter.DataBuffReadIndex = 0;
            using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    //nBytes = stream.Length;
                    txtUserCommand.Text = filePath;
                    nBytesRead = stream.Read(bBuff, 0, 10000);
                    while (nBytesRead > 0)
                    {
                        for (int i = 0; i < nBytesRead; i++)
                        {
                            DataBuff[DataBuffWriteIndex] = bBuff[i];
                            DataBuffWriteIndex++;
                            if (DataBuffWriteIndex > MaxDataBuff)
                                DataBuffWriteIndex = 0;
                            BackScatter.DataBuffWriteIndex = DataBuffWriteIndex;
                        }

                        #region test
                        int DBRI = DataBuffWriteIndex;
                        while (DBRI != DataBuffReadIndex)
                        {
                            DBRI = DataBuffReadIndex;
                            if (BackScatter.FindEnsemble(EnsBuf, DataBuff))
                            {
                                DecodeBackScatterEnsemble(TheBSbeam, BackScatter.Ensemble);
                                BackScatter.EnsembleClass m = new BackScatter.EnsembleClass();
                                m = Clone(BackScatter.Ensemble);
                                ensembles.Add(m);
                            }
                        }
                        #endregion
                        nBytesRead = stream.Read(bBuff, 0, 10000);
                    }

                    if (ensembles.Count > 0)
                    {
                        iEndEnsemble = ensembles.Count; //ensembles.Count - 1;
                        hScrollBar_BS.Maximum = ensembles.Count; //ensembles.Count - 1;
                        textBox_EnsN.Text = iEndEnsemble.ToString();

                        BackScatter.EnsembleClass m1 = ensembles[iEndEnsemble - 1];
                        label_DateTime.Text = m1.System_Year.ToString("D4") + "/" + m1.System_Month.ToString("D2") + "/" + m1.System_Day.ToString("D2") + ",";
                        label_DateTime.Text += m1.System_Hour.ToString("D2") + ":" + m1.System_Minute.ToString("D2") + ":" + m1.System_Second.ToString("D2") + "." + m1.System_Hsec.ToString("D2");
                    }
                    else return;
                }
                catch { }
            }
            #endregion
        }

        private BackScatter.EnsembleClass Clone(BackScatter.EnsembleClass E)  
        {
            BackScatter.EnsembleClass _E = new BackScatter.EnsembleClass();

            _E.System_EnsembleNumber = E.System_EnsembleNumber;
            _E.System_Year = E.System_Year;
            _E.System_Month = E.System_Month;
            _E.System_Day = E.System_Day;
            _E.System_Hour = E.System_Hour;
            _E.System_Minute = E.System_Minute;
            _E.System_Second = E.System_Second;
            _E.System_Hsec = E.System_Hsec;
            for (int i = 0; i < BackScatter.MaxBSbeams; i++)
            {
                _E.BS_Bins[i] = E.BS_Bins[i];
                _E.BS_BinSize[i] = E.BS_BinSize[i];
                _E.BS_FirstBin[i] = E.BS_FirstBin[i];
                _E.BS_Frequency[i] = E.BS_Frequency[i];
                for (int bin = 0; bin < E.BS_Bins[i]; bin++)
                {
                    _E.BS_Amplitude[i, bin] = E.BS_Amplitude[i, bin];
                    _E.BS_BackScatter[i, bin] = E.BS_BackScatter[i, bin];
                }
            }

            return _E;
        }
        #endregion



        //Modified 2011-9-20 rewrite get GPS from playback file to Ensembles
        //int lastBlock = -1;
        //int currentBlock; //for debug
        //int totalBlock;
        //int residuNum;

        //Modified 2011-9-20 rewrite get GPS from playback file to Ensembles
        private void ClearEnsemblesGPSInfo()
        {
            EnsemblesInfoToStore.GPS_latitude.Clear();         //Modified 2011-8-22
            EnsemblesInfoToStore.GPS_longitude.Clear();
            EnsemblesInfoToStore.gpsShipSpeed.Clear();
            EnsemblesInfoToStore.GPS_HDT.Clear();
            EnsemblesInfoToStore.VXstore.Clear();
            EnsemblesInfoToStore.VYstore.Clear();
            EnsemblesInfoToStore.GPS_GGAbuffer.Clear();     //Modified 2011-8-30 add next 4 lines
            EnsemblesInfoToStore.GPS_VTGbuffer.Clear();
            EnsemblesInfoToStore.GPS_HDTbuffer.Clear();
            EnsemblesInfoToStore.GPS_ROTbuffer.Clear();
            EnsemblesInfoToStore.UTMpoint.Clear();
        }

        private void ClearSaveEnsemblesGPSInfo()//LPJ 2012-5-4
        {
            SaveEnsemblesInfo.GPS_latitude.Clear();
            SaveEnsemblesInfo.GPS_longitude.Clear();
            SaveEnsemblesInfo.gpsShipSpeed.Clear();
            SaveEnsemblesInfo.GPS_HDT.Clear();
            SaveEnsemblesInfo.VXstore.Clear();
            SaveEnsemblesInfo.VYstore.Clear();
            SaveEnsemblesInfo.GPS_GGAbuffer.Clear();
            SaveEnsemblesInfo.GPS_VTGbuffer.Clear();
            SaveEnsemblesInfo.GPS_HDTbuffer.Clear();
            SaveEnsemblesInfo.GPS_ROTbuffer.Clear();
            SaveEnsemblesInfo.UTMpoint.Clear();
        }

        //Modified 2011-11-29, add comments: the following veriables are for playback
        static int TrackSaveMaxCount = 50000;
        int GGAsaveCount = 0;
        //int UTMsaveCount = 0;
        String[] GGAsave = new String[TrackSaveMaxCount];
        float[] AverageVXsave = new float[TrackSaveMaxCount];
        float[] AverageVYsave = new float[TrackSaveMaxCount];

        float[] AverageVXsave_GPS = new float[TrackSaveMaxCount]; //LPJ 2016-8-25
        float[] AverageVYsave_GPS = new float[TrackSaveMaxCount];

        float[] AverageVXsave_GPGGA = new float[TrackSaveMaxCount];
        float[] AverageVYsave_GPGGA = new float[TrackSaveMaxCount];

        float[] AverageVXsave_Null = new float[TrackSaveMaxCount];
        float[] AverageVYsave_Null = new float[TrackSaveMaxCount];

        float[] LatitudeSave = new float[TrackSaveMaxCount];
        float[] LongitudeSave = new float[TrackSaveMaxCount];
        Point[] UTMpointSave = new Point[TrackSaveMaxCount];

        //int fileBlockNum;   //Modified 2011-9-20 test
        //int BlockReadNum = 0; //Modified 2011-12-1
        //int EnsemblesInfoStoredBlocks = 0;   //保存当前存储的数据块号   JZH 2011-12-23
      
        private List<ArrayClass> RTIdata = new List<ArrayClass>();   //JZH 2012-01-12    供回放流量数据用
        private void PlayBackCenter(object sender, System.Timers.ElapsedEventArgs e)
        {
            //JZH 2012-03-21 添加数据载入错误处理
            try
            {
                if (BinDataEnsembleNum < EnsembleNumOfAllFiles)
                {
                    //lock (locker)
                    {
                        //BinDataEnsembleNum++; //LPJ 2013-6-8 
                        
                        BinDataEnsembleNum = BinDataEnsembleNum + dFlagRefreshTime + 1; //LPJ 2013-6-8
                        if (BinDataEnsembleNum > EnsembleNumOfAllFiles)  //LPJ 2013-6-8
                            BinDataEnsembleNum = EnsembleNumOfAllFiles;   //LPJ 2013-6-8

                        totalNum = BinDataEnsembleNum;
                        ClickPzn = ProcessBar.Width * BinDataEnsembleNum / EnsembleNumOfAllFiles;
                        //timeKnot = BinDataEnsembleNum * 1000;
                        //fileBlockNum = BinDataEnsembleNum / restoreNum; //Modified 2011-9-20 test

                        int totalBlocks = (EnsembleNumOfAllFiles / restoreNum);
                        int littleNum = BinDataEnsembleNum % restoreNum;
                        int residu = EnsembleNumOfAllFiles - (totalBlocks * restoreNum);

                        totalBlocks += 1;
                        //BlockReadNum = 0;
                         //{
                            
                            //BlockReadNum++; //Modified 2011-12-1
                        //}
                        
                    }

                    this.BeginInvoke(PlayBack);

                    //this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 //LPJ 2013-7-2
                    //this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
                    //this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
                    //this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18
                   
                }
            }
            catch (System.Exception error)   //JZH 2012-03-21 数据载入错误处理
            {
                PlayBackTimer.Stop();
                bPlaybackStop = true; //LPJ 2013-11-19
                PlayBackTimer.Close();
                //InitialParam = new InitialParamDelegate(InitialAllParam);
                //this.BeginInvoke(InitialParam);   //LPJ  2012-6-27 bug //LPJ 2013-7-1 cancel
                InitialAllParam(); //LPJ 2013-7-1
                // MessageBox.Show("载入回放数据错误，请检查文件格式是否正确！ " + error.Message); //LPJ 2012-4-20
                MessageBox.Show(Resource1.String26 + error.Message);
            }
        }
        //int flagstartGPS = 0;
        float currentInstrumentTime = 0;
        float lastInstrumentTime = 0;
        float InstrumentTimeElapse = 0;
        //ArrayList bytesArray;
        private void RefreshPanels()  //Modified 2011-8-1 playback 的 真正函数！！！ GGGGGGGGGGGG
        {
            #region cancel
            /*
            int x = PathStr.LastIndexOf("\\");
            string str = PathStr.Substring(0, x);
            string strGPS = str;
            int fileBlockNum1 = BinDataEnsembleNum / restoreNum;
           
            int C4 = (BinDataEnsembleNum % restoreNum);
            if (C4 == 0 && totalNum > 2)
            {
                CurrentGPSFileNumber++;
            }
            RiverPlaybackPath = str; //Modified 2011-12-10, find the right path name for playback path
            str += "\\rawData";
            strGPS += "\\GPS";       //Modified  add for open GPSdata file

            strGPS += "\\GPSdata" + fileBlockNum1.ToString("000000") + ".txt";
            Version_2_CurrentGPSFileName = "GPSdata" + CurrentGPSFileNumber.ToString("000000") + ".txt";
            */
            #endregion

            if (tabControl4.SelectedIndex == 1)
            {
                #region 
                this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-6-9
                this.BeginInvoke(TrackPanel_Refresh);
                this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成 //LPJ 2013-7-2
                this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
            
                #endregion
            }

            //bNewEnsemble = true; //JZH 2012-03-26 

            current_EsambleTotaleNum = BinDataEnsembleNum.ToString();

            if (EnsemblesInfoToStore.RecivedTime.Count > 0) //LPJ 2013-8-2
            {
                current_TotalTimelabel = (NumToTime(((float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1]-((float)EnsemblesInfoToStore.RecivedTime[0])) * 1000)).ToString();
                //labelDataTime.Text = (string)EnsemblesInfoToStore.RecivedDataTime[EnsemblesInfoToStore.RecivedDataTime.Count - 1];  
                current_DataTime = (string)EnsemblesInfoToStore.RecivedDataTime[BinDataEnsembleNum - 1];  //JZH 2012-02-18 显示当前数据组时间

                //Modified 2011-12-16, find time
                currentInstrumentTime = (float)(EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1]);
                InstrumentTimeElapse = currentInstrumentTime - lastInstrumentTime;
                if (InstrumentTimeElapse == 0)
                {
                    InstrumentTimeElapse = 1;
                }
                lastInstrumentTime = currentInstrumentTime;

                //LPJ 2013-6-22 将计算船速、水流速放在这里 -start
                double fWaterSpeed = (double)(EnsemblesInfoToStore.WaterSpeedSum[BinDataEnsembleNum-1]); //LPJ 2013-7-3
                double fWaterDir = (double)(EnsemblesInfoToStore.WaterDir[BinDataEnsembleNum - 1]);

                if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                {
                    fWaterSpeed = (double)EnsemblesInfoToStore.WaterSpeedSum_GPS[BinDataEnsembleNum - 1];
                    fWaterDir = (double)(EnsemblesInfoToStore.WaterDir_GPS[BinDataEnsembleNum - 1]);
                }
                else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                {
                    fWaterSpeed = (double)EnsemblesInfoToStore.WaterSpeedSum_GPGGA[BinDataEnsembleNum - 1];
                    fWaterDir = (double)(EnsemblesInfoToStore.WaterDir_GPGGA[BinDataEnsembleNum - 1]);
                }
                else if (Resource1.String233 == labelVesselRef.Text)
                {
                    fWaterSpeed = (double)EnsemblesInfoToStore.WaterSpeedSum_Null[BinDataEnsembleNum - 1];
                    fWaterDir = (double)(EnsemblesInfoToStore.WaterDir_Null[BinDataEnsembleNum - 1]);
                }

               float fAveDepth = (float)(EnsemblesInfoToStore.bottomDepth[BinDataEnsembleNum - 1]); 

                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                if (!bEnglish2Metric)
                {
                    //labelWaterSpeed.Text = projectUnit.MeterToFeet(fWaterSpeed,1).ToString("0.000");
                    current_Depth = projectUnit.MeterToFeet(fAveDepth, 1).ToString("0.00");
                    current_WaterSpeed = projectUnit.MeterToFeet(fWaterSpeed, 1).ToString("0.000");
                }
                else
                {
                    //labelWaterSpeed.Text = fWaterSpeed.ToString("0.000");
                    current_Depth = fAveDepth.ToString("0.00");
                    current_WaterSpeed = fWaterSpeed.ToString("0.000");
                }

                //labelWaterDirection.Text = fWaterDir.ToString("000.0");

                //JZH 2012-03-23 更新导航面板数据

                current_WaterDirection = fWaterDir.ToString("0.0");

                double fBoatSpeed = 0;
                float fBoatVelX = 0;
                float fBoatVelY = 0;

                fBoatSpeed = (double)(EnsemblesInfoToStore.BoatSpeed[BinDataEnsembleNum - 1]);


                fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[BinDataEnsembleNum - 1]).VX;
                fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[BinDataEnsembleNum - 1]).VY;
                if (fBoatVelX <= 20 && fBoatVelY <= 20)
                {
                    double fBoatDir = (double)(EnsemblesInfoToStore.BoatDir[BinDataEnsembleNum - 1]);
                    current_BoatDirection = fBoatDir.ToString("0.0");

                    //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                    if (!bEnglish2Metric)
                        current_BoatSpeed = projectUnit.MeterToFeet(fBoatSpeed, 1).ToString("0.000");
                    else
                        current_BoatSpeed = fBoatSpeed.ToString("0.000");
                }
                else
                {
                    current_BoatDirection = "Bad";
                    current_BoatSpeed = "Bad";
                }

                if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                {
                    current_BoatDirection = ((double)EnsemblesInfoToStore.BoatDir_GPS[BinDataEnsembleNum - 1]).ToString("0.00");
                    current_BoatSpeed = ((double)EnsemblesInfoToStore.BoatSpeed_GPS[BinDataEnsembleNum - 1]).ToString("0.000");
                }
                else if ("GPS GGA" == labelVesselRef.Text)
                {
                    current_BoatDirection = ((double)EnsemblesInfoToStore.BoatDir_GPGGA[BinDataEnsembleNum - 1]).ToString("0.00");
                    current_BoatSpeed = ((double)EnsemblesInfoToStore.BoatSpeed_GPGGA[BinDataEnsembleNum - 1]).ToString("0.000");
                }
                else if (Resource1.String233 == labelVesselRef.Text)
                {
                    current_BoatDirection = "0";
                    current_BoatSpeed = "0";
                }
                //LPJ 2013-6-22 将计算船速、水流速放在这里 -end
            }
            currentTotalNum = BinDataEnsembleNum;     //HHHHHHHHHHH Modified 2011-8-2, when playback, play position can change by user

            {
                if (BinDataEnsembleNum > 1)
                {
                    currentTotalNum++;              //currentTotalNum defined somewhere else. init to 0. Modified 2011-8-2

                    string cmp = "#" + currentTotalNum.ToString("000000");
                
                    //JZH 2011-12-29 找到GPS数据了，由于EnsemblesInfoToStore取消了500个数据的循环限制，改写数据提取
                    try
                    {
                        try
                        {
                            GPS_GGAbuffer = EnsemblesInfoToStore.GPS_GGAbuffer[BinDataEnsembleNum - 1].ToString();
                        }
                        catch
                        { }
                        try
                        {
                            GPS_VTGbuffer = EnsemblesInfoToStore.GPS_VTGbuffer[BinDataEnsembleNum - 1].ToString();
                        }
                        catch
                        { }
                        try
                        {
                            GPS_HDTbuffer = EnsemblesInfoToStore.GPS_HDTbuffer[BinDataEnsembleNum - 1].ToString();
                        }
                        catch
                        { }
                        try
                        {
                            GPS_ROTbuffer = EnsemblesInfoToStore.GPS_ROTbuffer[BinDataEnsembleNum - 1].ToString();
                        }
                        catch
                        { }

                        #region Decode GPGGA //LPJ 2014-7-10
                        CDecodeGPS decodeGPS = new CDecodeGPS();
                        decodeGPS.GPS_GGAdecode(GPS_GGAbuffer, ref gpsTime, ref GPS_longitude, ref GPS_latitude, ref NorthSouth, ref EastWest);
                        defaultGPGGA = GPS_GGAbuffer;
                        GPS_FloatLatitude = float.Parse(GPS_latitude);
                        if (NorthSouth == "S")
                            GPS_FloatLatitude *= -1.0f;
                        GPS_latitude = GPS_latitude.Insert(2, "º") + NorthSouth;
                        GPS_FloatLongitude = float.Parse(GPS_longitude);
                        if (EastWest == "W")
                        {
                            GPS_FloatLongitude *= -1.0f;
                        }
                        GPS_longitude = GPS_longitude.Insert(3, "º") + EastWest;
                        #endregion

                        int iLat_D = (int)(GPS_FloatLatitude / 100);
                        int iLat_M = (int)(GPS_FloatLatitude - iLat_D * 100);
                        float fLat_S = (GPS_FloatLatitude - iLat_D * 100 - iLat_M) * 60;
                        current_LatitudeText = iLat_D.ToString() + "º" + iLat_M.ToString() + "'" + fLat_S.ToString("0.00"); //LPJ 2015-9-23

                        int iLong_D = (int)(GPS_FloatLongitude / 100);
                        int iLong_M = (int)(GPS_FloatLongitude - iLong_D * 100);
                        float fLong_S = (GPS_FloatLongitude - iLong_D * 100 - iLong_M) * 60;
                        current_LongitudeText = iLong_D.ToString() + "º" + iLong_M.ToString() + "'" + fLong_S.ToString("0.00"); ;

                        //GPS_GGAdecode(GPS_GGAbuffer);
                        GPS_VTGdecode(GPS_VTGbuffer);
                        GPS_HDTdecode(GPS_HDTbuffer);
                        GPS_ROTdecode(GPS_ROTbuffer);

                        //current_LatitudeText = GPS_latitude; // +" " + NorthSouth; //Modified 2011-9-9  //LPJ 2013-11-21
                        //current_LongitudeText = GPS_longitude; // +" " + EastWest;             //LPJ 2013-11-21
                        //InsInfotextBox.Text = littleNum2.ToString();

                        //if (!bGPSConnect) //LPJ 2013-9-17 //LPJ 2013-11-21
                        {
                            //current_LatitudeText = EnsemblesInfoToStore.Latitude[BinDataEnsembleNum - 1].ToString();  //LPJ 2015-9-23 cancel
                            //current_LongitudeText = EnsemblesInfoToStore.Longitude[BinDataEnsembleNum - 1].ToString();
                        } //LPJ 2013-9-17



                        labelShipSpeedText.Text = gpsShipSpeed;
                     
                        current_TrueNorthText = GPS_HDT;

                        if (totalNum < StartPoint)
                        //if (totalNum < StartPoint || System.Math.Abs(StartUTMpnt.X - ((Point)EnsemblesInfoToStore.UTMpoint[BinDataEnsembleNum - 1]).X) > 1.0e5 || System.Math.Abs(StartUTMpnt.Y - ((Point)EnsemblesInfoToStore.UTMpoint[BinDataEnsembleNum - 1]).Y) > 1.0e5)//LPJ 2012-7-2 修改判断，当初始UTM坐标与当前UTM坐标相差过大时，则重新定义初始的UTM坐标  //LPJ 2012-8-2 取消
                        {
                            ComputeXYposition(GPS_GGAbuffer); //playback mode   //LPJ 不明白该函数放在此处的目的是什么？在观测的时候，UTM坐标已经保存过，这里还需要坐标转换吗？
                            //StartUTMpnt = (Point)EnsemblesInfoToStore.UTMpoint[BinDataEnsembleNum - 1];   //LPJ 2012-7-3 增加  //LPJ 2012-8-2 取消
                        }
                    }
                    catch
                    {
                    }
                    totalNum = currentTotalNum; //Modified 2011-9-8

                    try //Modified 2011-11-28
                    {
                        GGAsave[GGAsaveCount] = (string)(EnsemblesInfoToStore.GPS_GGAbuffer[BinDataEnsembleNum - 1]);
                        AverageVXsave[GGAsaveCount] = (float)EnsemblesInfoToStore.VXstore[BinDataEnsembleNum - 1];
                        AverageVYsave[GGAsaveCount] = (float)EnsemblesInfoToStore.VYstore[BinDataEnsembleNum - 1];
                        LatitudeSave[GGAsaveCount] = (float)EnsemblesInfoToStore.GPS_latitude[BinDataEnsembleNum - 1];
                        LongitudeSave[GGAsaveCount] = (float)EnsemblesInfoToStore.GPS_longitude[BinDataEnsembleNum - 1];
                        UTMpointSave[GGAsaveCount] = (Point)EnsemblesInfoToStore.UTMpoint[BinDataEnsembleNum - 1];
                        GGAsaveCount++; //playback mode
                    }
                    catch
                    {
                    }

                    GPScontrolPanel.Refresh(); //Modified 2011-9-8 for playback
                    GPSdisplayPanel.Refresh(); //Modified 2011-9-8
                }
            }
            //Modified 2011-11-11, initialize starting position of Lat Long in playback mode
            //if (totalNum < 10) //Modified 2011-11-8   //LPJ 2012-6-27 取消
            //{
            //    StartLatitude = GPS_FloatLatitude;
            //    StartLongitude = GPS_FloatLongitude;
            //    ComputeLatLongGridText(StartLatitude, StartLongitude);
            //}

            ////LPJ 2012-6-28 修改，可能存在这种情况：开始记录GPS数据后的前10秒都没有数据,因此将接收到的当前时刻GPS坐标与起始坐标比较，若大于10'，则将当前时刻坐标作为一个新的起始坐标
            if (System.Math.Abs(GPS_FloatLatitude - StartLatitude) > 10.0 || System.Math.Abs(GPS_FloatLongitude - StartLongitude) > 10.0)
            {
                StartLatitude = GPS_FloatLatitude;
                StartLongitude = GPS_FloatLongitude;
                ComputeLatLongGridText(StartLatitude, StartLongitude);
            }

            TimeLable.Text = BinDataEnsembleNum.ToString() + "/" + EnsembleNumOfAllFiles;

            ////LPJ 2013-6-8
            //this.BeginInvoke(CalDischargeRefresh); //将流量计算在单独的线程中完成
            //this.BeginInvoke(RefreshDishargePanel); //刷新流量计算的显示
            //this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
            //this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18

            if (BinDataEnsembleNum == 1)
                //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                  this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
            else
            {
                if (tabControl4.SelectedIndex == 3) //LPJ 2013-7-3 当当前的页面为数据页时，显示数据
                    WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]); //LPJ 2013-7-2 
            }

            arrAmplitude = RTIdata[BinDataEnsembleNum - 1].Amplitude;  //LPJ 2013-7-10
            arrCorrelation = RTIdata[BinDataEnsembleNum - 1].Correlation; //LPJ 2013-7-10
            pictureBox_W_A.Refresh(); //LPJ 2013-7-10
            pictureBox_W_C.Refresh(); //LPJ 2013-7-10

            //panelSerialTime.Refresh(); //LPJ 2013-9-22

            this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

            if (tabControl4.SelectedIndex == 1)
            {
                ProcessBar.Refresh();
                HPRpictureBox.Refresh();
                //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
                this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18
            }

            //LPJ 2015-9-22 当用户选择获取艏向偏差
            if (checkBoxGetHeadingOffset.Checked)
            {
                GetGPSHeadingOffset();
            }

            //JZH 2012-06-13 将开始的判断函数移到最后再做判断
            if (BinDataEnsembleNum == EnsembleNumOfAllFiles) //HHHHHHHHHHHHH Modified 2011-8-3 , To prevent while() loop below to make error
            {
                //MessageBox.Show("回放文件终端，请退出或改变回放起点。");//LPJ 2012-4-20

                if (tabControl4.SelectedIndex != 3) //LPJ 2013-7-3 当回放结束时，当前页不是数据页
                    //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]);
                this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11

                MessageBox.Show(Resource1.String27); //LPJ 2013-6-7 MoveToPlaybackCenter

                PlayBackPauseFlag = !PlayBackPauseFlag;  //LPJ 2013-9-24 当回放结束时，暂停按钮自动修改
                buttonPause.Text = PlayBackPauseFlag ? "▶" : "||";  //LPJ 2013-9-24 当回放结束时，暂停按钮自动修改

                //Modified 2011-12-1
                PlayBackTimer.Stop();
                bPlaybackStop = true; //LPJ 2013-11-19
                PlayBackTimer.Close();

                return;
            }
        }
        private int dFlagRefreshTime = 0; //LPJ 2013-6-8设置一个变量用于记录每秒刷新的次数

        private void LoadAllData()
        {
            //JZH 2011-12-23 一次载入所有的回放数据
           
            //string sDatFilePath;    //dat文件路径
            //int iTotalBlocks = (EnsembleNumOfAllFiles / restoreNum) + 1;  //数据文件块总数
            //int iEnsembleNumberPos = 0;        //当前数据块中读取的数据组序号
            //int iCurrentFileBlocks = 0;        //当前文件块号
            //int iCurrentEnsNum = 0;            //LPJ 2012-5-7 在当前文件中的当前ensemble序号
            float time;
            double boatSpeed;

            FrmProgressBar frmProgressBar = new FrmProgressBar(0, EnsembleNumOfAllFiles); //LPJ 2013-5-31
            frmProgressBar.Show();//LPJ 2013-5-31

            //JZH 2012-01-12 载入回放流量原始数据   ----开始
            //int x = PathStr.LastIndexOf("\\");
            //string str = PathStr.Substring(0, x);
            //string[] files = Directory.GetFiles(str + "\\rawData", "*.Bin");
            //Array.Sort(files);

            //int j = 0;
            //foreach (string path in files)
            //{
            //    frmProgressBar.setPos(j++); //LPJ 2013-5-31
            //    RTIdata.AddRange(Calcflow.RiverDischargeCalculate.ReadEnsembleRawData(path));
            //}
            //JZH 2012-01-12 载入回放流量原始数据   ----结束
            //SM>
            /*
            if (RTIdata.Count > 0)
            {
                cells = RTIdata[0].E_Cells; //LPJ 2013-7-30 从原始数据中读取层数
                cellSize = RTIdata[0].A_CellSize;  //LPJ 2013-7-30 从原始数据中读取单元尺寸
                WaterAvgNum = (int)(RTIdata[0].E_PingsInEnsemble);  //LPJ 2013-7-30 从原始数据中读取呯数
            }
            */
            //SM<
            

            MaxWaterSpeed = 0; //LPJ 2013-8-6 

            //int iResidu = EnsembleNumOfAllFiles - (iTotalBlocks - 1) * restoreNum; //最后一个文件块的数据组数
            for (int i = 0; i < EnsembleNumOfAllFiles; i++) //读取原始数据文件            
            {
                //SM>
                if (RTIdata.Count > 0)
                {
                    cells = RTIdata[i].E_Cells;
                    cellSize = RTIdata[i].A_CellSize;
                    WaterAvgNum = (int)(RTIdata[i].E_PingsInEnsemble);
                }
                //SM<
                frmProgressBar.setPos(i); //LPJ 2013-5-31

                #region LPJ 2016-8-10 艏向参考外接罗盘
                if (labelHeadingRef.Text == Resource1.String231)
                {
                    float fGPS_HDT = RTIdata[i].A_Heading;
                    try
                    {
                        if (bGPSConnect)
                        {
                            fGPS_HDT = float.Parse((string)EnsemblesInfoToStore.GPS_HDT[i]);
                        }
                        else
                        {
                            string NMEA_buffer = "";
                            string GPHDTbuffer = "";
                            NMEA_buffer = Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);

                            CDecodeGPS decodeGPS = new CDecodeGPS();
                            decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPHDT", ref GPHDTbuffer);
                            decodeGPS.GPS_HDTdecode(GPHDTbuffer, ref fGPS_HDT);
                        }

                        for (int j = 0; j < RTIdata[i].E_Cells; j++)
                        {
                            float fEarth = 0;
                            float fNorth = 0;
                            CalXYZ2ENU(RTIdata[i].Instrument[0, j], RTIdata[i].Instrument[1, j], RTIdata[i].Instrument[2, j], fGPS_HDT + (float)fHeadingOffset, RTIdata[i].A_Pitch, RTIdata[i].A_Roll, ref fEarth, ref fNorth);
                            RTIdata[i].Earth[0, j] = fEarth;
                            RTIdata[i].Earth[1, j] = fNorth;
                        }

                        #region 更新底跟踪速度 //LPJ 2017-5-10
                        float fEarth_BT = 0;
                        float fNorth_BT = 0;
                        CalXYZ2ENU(RTIdata[i].B_Instrument[0], RTIdata[i].B_Instrument[1], RTIdata[i].B_Instrument[2], fGPS_HDT + (float)fHeadingOffset, RTIdata[i].B_Pitch, RTIdata[i].B_Roll, ref fEarth_BT, ref fNorth_BT);
                        RTIdata[i].B_Earth[0] = fEarth_BT;
                        RTIdata[i].B_Earth[1] = fNorth_BT;
                        #endregion
                    }
                    catch
                    {
                    }
                }
                #endregion
                #region  内接罗经 //LPJ 2017-5-12
                else
                {
                    if (Math.Abs(fHeadingOffset) > 0.0000001)   //LPJ 2017-5-16 当磁偏角不为0时，改正该值
                    {
                        for (int j = 0; j < RTIdata[i].E_Cells; j++)
                        {
                            float fEarth = 0;
                            float fNorth = 0;
                            CalXYZ2ENU(RTIdata[i].Instrument[0, j], RTIdata[i].Instrument[1, j], RTIdata[i].Instrument[2, j], RTIdata[i].A_Heading + (float)fHeadingOffset, RTIdata[i].A_Pitch, RTIdata[i].A_Roll, ref fEarth, ref fNorth);
                            RTIdata[i].Earth[0, j] = fEarth;
                            RTIdata[i].Earth[1, j] = fNorth;
                        }

                        #region 更新底跟踪速度 //LPJ 2017-5-10
                        float fEarth_BT = 0;
                        float fNorth_BT = 0;
                        CalXYZ2ENU(RTIdata[i].B_Instrument[0], RTIdata[i].B_Instrument[1], RTIdata[i].B_Instrument[2], RTIdata[i].B_Heading + (float)fHeadingOffset, RTIdata[i].B_Pitch, RTIdata[i].B_Roll, ref fEarth_BT, ref fNorth_BT);
                        RTIdata[i].B_Earth[0] = fEarth_BT;
                        RTIdata[i].B_Earth[1] = fNorth_BT;
                        #endregion
                    }
                }
                #endregion

                //LPJ 2014-6-4 船速由原始数据获取
                Velocity Bv = new Velocity();

                Bv.VX = RTIdata[i].B_Earth[0];
                Bv.VY = RTIdata[i].B_Earth[1];
                Bv.VZ = RTIdata[i].B_Earth[2];
                #region 计算船速 cancel
                /*
                if (labelVesselRef.Text == Resource1.String232)//当船速采用底跟踪时
                {
                    Bv.VX = RTIdata[i].B_Earth[0];
                    Bv.VY = RTIdata[i].B_Earth[1];
                    Bv.VZ = RTIdata[i].B_Earth[2];
                }
                else if (labelVesselRef.Text == "GPS VTG") //当船速采用外接GPS时
                {
                    string strNMEA = System.Text.Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);
                    float VTG_Vx = 0, VTG_Vy = 0;
                    string[] strSplit = new string[100];
                    strSplit = strNMEA.Split('$');

                    float vtg_vx = 0;
                    float vtg_vy = 0;
                    int iVTGNum = 0;
                    foreach (string strData in strSplit)
                    {
                        if (strData.Contains("GPVTG")) //解析VTG数据，将vtg流速做平均后，作为可用数据
                        {
                            try
                            {
                                string[] tokens = new string[10];
                                tokens = strData.Split(',');

                                double gpsAngle = float.Parse(tokens[1]) * Math.PI / 180.0f;
                                double gpsShipSpeed = float.Parse(tokens[5]) * 1.852f * 1000.0f / 3600.0f;

                                vtg_vx += (float)(gpsShipSpeed * Math.Sin(gpsAngle));
                                vtg_vy += (float)(gpsShipSpeed * Math.Cos(gpsAngle));

                                iVTGNum++;
                            }
                            catch
                            {
                            }
                        }
                    }
                    if (iVTGNum > 0)
                    {
                        VTG_Vx = vtg_vx / iVTGNum;
                        VTG_Vy = vtg_vy / iVTGNum;
                    }
                    Bv.VX = VTG_Vx;
                    Bv.VY = VTG_Vy;
                }
                else if (labelVesselRef.Text == "GPS GGA") //当船速采用外接GPS时
                {
                    string strNMEA = System.Text.Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);
                   
                    CDecodeGPS decodeGPS = new CDecodeGPS();
                    string UTCtime = "", GPS_Long = "", GPS_Lat = "", GPS_NS = "", GPS_EW = "";
                    decodeGPS.GPSNMEA_decode(strNMEA, "GPGGA", ref GPS_GGAbuffer);
                    decodeGPS.GPS_GGAdecode(GPS_GGAbuffer, ref UTCtime, ref GPS_Long, ref GPS_Lat, ref GPS_NS, ref GPS_EW);

                    //将DDMM.mmmm转为DD.dddd的经纬度
                    int degreeE1 = 0, minuteE1 = 0, degreeN1 = 0, minuteN1 = 0;
                    float secondE1 = 0, secondN1 = 0;
                    decodeGPS.TransferEarthCoordinate(float.Parse(GPS_Long), ref degreeE1, ref minuteE1, ref secondE1);
                    decodeGPS.TransferEarthCoordinate(float.Parse(GPS_Lat), ref degreeN1, ref minuteN1, ref secondN1);
                    double Longitude1 = degreeE1 + minuteE1 / 60.0 + secondE1 / 3600.0;
                    double Latitude1 = degreeN1 + minuteN1 / 60.0 + secondN1 / 3600.0;

                    double Longitude2 = GPGGA_Longitude[GPGGA_Longitude.Count() - 1];
                    double Latitude2 = GPGGA_Latitude[GPGGA_Latitude.Count() - 1];

                    EnsemblesInfoToStore.Latitude.Add(degreeN1.ToString() + "°" + minuteN1.ToString() + "'" + secondN1.ToString() + GPS_NS);
                    EnsemblesInfoToStore.Longitude.Add(degreeE1.ToString() + "°" + minuteE1.ToString() + "'" + secondE1.ToString() + GPS_EW);
                  
                    double gpgga_ve, gpgga_vn;
                    float detT = 0;

                    detT = GPS_UTCTime[GPS_UTCTime.Count - 1] - float.Parse(UTCtime);
                    if (detT < 0.00000001)
                    {
                        Bv.VX = 0;
                        Bv.VY = 0;
                    }
                    else
                    {
                        gpgga_ve = TransferGPS2Distance.GetDistance(Latitude1, Longitude1, Latitude1, Longitude2) / detT;
                        gpgga_vn = TransferGPS2Distance.GetDistance(Latitude1, Longitude2, Latitude2, Longitude2) / detT;

                        if (Latitude1 > Latitude2)
                            gpgga_vn = -1 * gpgga_vn;
                        if (Longitude1 > Longitude2)
                            gpgga_ve = -1 * gpgga_ve;

                        double Ve = TransferGPS2Distance.RotateX(gpgga_ve, gpgga_vn, fHeadingOffset);
                        double Vn = TransferGPS2Distance.RotateY(gpgga_ve, gpgga_vn, fHeadingOffset);

                        Bv.VX = (float)Ve;
                        Bv.VY = (float)Vn;
                    }
                   
                }
                else
                {
                    Bv.VX = 0;
                    Bv.VY = 0;
                    Bv.VZ = 0;
                }
                */
                #endregion
                EnsemblesInfoToStore.BoatVelocity.Add(Bv);

                //LPJ 2014-6-4 流速由原始数据获取
                Velocity[] VEarth = new Velocity[cells];
                for (int n = 0; n < cells; n++)
                {
                    VEarth[n].VX = RTIdata[i].Earth[0, n];
                    VEarth[n].VY = RTIdata[i].Earth[1, n];
                    VEarth[n].VZ = RTIdata[i].Earth[2, n];
                    //绝对速度
                    if (VEarth[n].VX <= 80.0 && VEarth[n].VY <= 80.0 && VEarth[n].VZ <= 80.0)
                    {
                        VEarth[n].VX += Bv.VX;
                        VEarth[n].VY += Bv.VY;
                        VEarth[n].VZ += Bv.VZ;
                    }
                    else
                    {
                        //n = n;
                    }
                }
                EnsemblesInfoToStore.WaterVelocity.Add(VEarth);

                //由原始数据获得
                EnsemblesInfoToStore.RecivedTime.Add(RTIdata[i].A_FirstPingSeconds);
                EnsemblesInfoToStore.RecivedDataTime.Add(
                           RTIdata[i].YYYY.ToString() + "-" + RTIdata[i].MM.ToString("00") + "-" + RTIdata[i].DD.ToString("00") + " "
                           + RTIdata[i].HH.ToString("00") + ":" + RTIdata[i].mm.ToString("00") + ":" + RTIdata[i].SS.ToString("00"));
                EnsemblesInfoToStore.bottomDepth.Add(getAverageB_depth(RTIdata[i]));
                EnsemblesInfoToStore.RangeOfFirstBin.Add(RTIdata[i].A_FirstCellDepth);
                //SM>
                EnsemblesInfoToStore.BinSize.Add(RTIdata[i].A_CellSize);
                //SM<

                //载入原始数据中的GPS数据
                //try
                //{
                //    EnsemblesInfoToStore.GPS_latitude.Add(dat.GPS_latitude[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_longitude.Add(dat.GPS_longitude[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.gpsShipSpeed.Add(dat.gpsShipSpeed[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_HDT.Add(dat.GPS_HDT[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.VXstore.Add(dat.VXstore[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.VYstore.Add(dat.VYstore[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_GGAbuffer.Add(dat.GPS_GGAbuffer[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_VTGbuffer.Add(dat.GPS_VTGbuffer[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_HDTbuffer.Add(dat.GPS_HDTbuffer[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.GPS_ROTbuffer.Add(dat.GPS_ROTbuffer[iEnsembleNumberPos]);
                //    EnsemblesInfoToStore.UTMpoint.Add(dat.UTMpoint[iEnsembleNumberPos]);
                //}
                //catch
                //{

                //}

                //GetOtherMembers(); 载入需要计算的数据
                if (1 == i) //第一个样本的时间间隔无法确定，尽是认为与第二个样本的时间差相同
                {
                    time = (float)EnsemblesInfoToStore.RecivedTime[1] - (float)EnsemblesInfoToStore.RecivedTime[0]; //时间差的绝对值
                    EnsemblesInfoToStore.t.Add(time);
                    EnsemblesInfoToStore.t.Add(time);
                }
                else if (i > 1)
                {
                    time = (float)EnsemblesInfoToStore.RecivedTime[i] - (float)EnsemblesInfoToStore.RecivedTime[i - 1];
                    EnsemblesInfoToStore.t.Add(time);
                }
                boatSpeed = Math.Sqrt(Math.Pow
                            (((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX, 2)
                            + Math.Pow(((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY, 2));
                EnsemblesInfoToStore.BoatSpeed.Add(boatSpeed);
               
                float  fBoatVelX = ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX; //LPJ 2013-7-3 计算船方向
                float  fBoatVelY = ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY;
                    double fBoatDir = System.Math.Atan2(fBoatVelX, fBoatVelY);
                    if (fBoatDir < 0)
                        fBoatDir = fBoatDir / Math.PI * 180 + 360;
                    else
                        fBoatDir = fBoatDir / Math.PI * 180;
                EnsemblesInfoToStore.BoatDir.Add(fBoatDir); //LPJ 2013-7-3

                Velocity[] Vel = (Velocity[])EnsemblesInfoToStore.WaterVelocity[i];  //Modified HERE 2011-7-28 get velocity here!!!

                //boat speed
                //for (int n = 0; n < Vel.Count(); n++)
                //{
                //    Vel[0].VX -= fBoatVelX;
                //    Vel[0].VY -= fBoatVelY;
                //}

                double[] waterSpeed = new double[Vel.Length];
                int k = 0;
                foreach (Velocity v in Vel)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }
                EnsemblesInfoToStore.WaterSpeed.Add(waterSpeed);
  
                float fVx = 0, fVy = 0;
                int iGoodBinNum = GetAverageWaterSpeed(i, ref fVx, ref fVy);

                //LPJ 2013-5-16 计算有效单元层数
                 //int iGoodBinNum = CalGoodBinNumber(i);
                EnsemblesInfoToStore.iGoodBin.Add(iGoodBinNum);
                //boat speed
                //fVx -= fBoatVelX;
                //fVy -= fBoatVelY;

                fAverageX.Add(fVx); //LPJ 2013-7-3
                fAverageY.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start
                double fWaterDir;

                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;

                EnsemblesInfoToStore.WaterDir.Add(fWaterDir);
                
                double fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum.Add(fWaterSpeed); //LPJ 2013-7-3

                //LPJ 2013-8-6  计算航迹图中的流速比例
                if (MaxWaterSpeed < fWaterSpeed)
                {
                    MaxWaterSpeed = fWaterSpeed;
                    AverageScale = (int)(this.panelGPSTrack.Width / 8 / MaxWaterSpeed);
                }

                double fBoatWater = 0;
                if (fWaterSpeed > 0.0001)
                    fBoatWater= boatSpeed / fWaterSpeed;
                EnsemblesInfoToStore.BoatWater.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end
                
                WaterSpeedTransToColor2((Velocity[])EnsemblesInfoToStore.WaterVelocity[i]);   //JZH 2011-12-25 调用新的色彩转换函数
                //WaterVelocityTransToColor2((Velocity[])EnsemblesInfoToStore.WaterVelocity[i]);  //JZH 2011-12-25 调用新的色彩转换函数
            } 
            frmProgressBar.Close(); //LPJ 2013-5-31

            RefreshGPSBoatSpeed(RTIdata.Count); //LPJ 2013-7-31
            RefreshNullBoatSpeed(RTIdata.Count); //LPJ 2013-12-3 当船速无参考时
            ChangeToNewRGB(); //修改颜色

            //GetDischarge(ref report); //LPJ 2013-5-30 一次计算全部流量信息
            this.BeginInvoke(RefreshSummaryList); //LPJ 2013-6-19 更新流量列表

        }

        private void RefreshGPSBoatSpeed(int iEnsemblesNo) //LPJ 2013-7-31 
        {
            try
            {
                //LPJ 2013-7-8 当船速采用GPS数据时，将E000011中的NEMA数据进行解析

                EnsemblesInfoToStore.WaterV_GPS.Clear();
                EnsemblesInfoToStore.BoatV_GPS.Clear();
                EnsemblesInfoToStore.WaterSpeed_GPS.Clear();
                EnsemblesInfoToStore.BoatSpeed_GPS.Clear();
                EnsemblesInfoToStore.BoatDir_GPS.Clear();
                EnsemblesInfoToStore.WaterDir_GPS.Clear();
                EnsemblesInfoToStore.WaterSpeedSum_GPS.Clear();
                EnsemblesInfoToStore.BoatWater_GPS.Clear();
                EnsemblesInfoToStore.WaterSpeedToSixColor_GPS.Clear();
                fAverageX_GPS.Clear();
                fAverageY_GPS.Clear();

                EnsemblesInfoToStore.WaterV_GPGGA.Clear();
                EnsemblesInfoToStore.BoatV_GPGGA.Clear();
                EnsemblesInfoToStore.WaterSpeed_GPGGA.Clear();
                EnsemblesInfoToStore.BoatSpeed_GPGGA.Clear();
                EnsemblesInfoToStore.BoatDir_GPGGA.Clear();
                EnsemblesInfoToStore.WaterDir_GPGGA.Clear();
                EnsemblesInfoToStore.WaterSpeedSum_GPGGA.Clear();
                EnsemblesInfoToStore.BoatWater_GPGGA.Clear();
                EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA.Clear();
                fAverageX_GPGGA.Clear();
                fAverageY_GPGGA.Clear();

                EnsemblesInfoToStore.Latitude.Clear(); //LPJ 2013-9-17
                EnsemblesInfoToStore.Longitude.Clear(); //LPJ 2013-9-17

                string NMEA_buffer = "";
                Velocity vGPS = new Velocity();
                float ve = 0, vn = 0;
                //length = RTIdata[0].Velocity.Length;
                int length = (int)RTIdata[0].E_Cells;

                //Velocity[] WaterVel = new Velocity[length];
                //SM>
                //double[] waterSpeed = new double[length];
                //SM<
                double boatSpeed;
                double fBoatDir;

                FrmProgressBar frmProgressBar = new FrmProgressBar(0, iEnsemblesNo);
                frmProgressBar.Show();

                //GPS_UTCTime.Clear();
                //GPGGA_Longitude.Clear();
                //GPGGA_Latitude.Clear();

                float fLastUTCtime = 0;
                double dLastGGA_Lng = 0;
                double dLastGGA_Lat = 0;

                for (int i = 0; i < iEnsemblesNo; i++)
                {
                    frmProgressBar.setPos(i);
                    //NMEA_buffer = ByteArrayToString(RTIdata[i].NMEA_Buffer, RTIdata[i].NMEA_Buffer.Length);

                    if (bGPSConnect) //LPJ 2016-8-10 从外接GPS读取,
                    {
                        NMEA_buffer = (string)EnsemblesInfoToStore.GPS_VTGbuffer[i] + "\r\n$" + (string)EnsemblesInfoToStore.GPS_GGAbuffer[i];
                    }
                    else
                    {
                        NMEA_buffer = Encoding.Default.GetString(RTIdata[i].NMEA_Buffer); //从内接GPS读取
                    }

                    string GPVTGbuffer = "";
                    string GPGGAbuffer = "";
                    string GPS_Latitude = "", GPS_Longitude = "";
                    ve = 0;
                    vn = 0;

                    //getDataFromNMEA_Buffer(NMEA_buffer, ref GPGGAbuffer,ref GPVTGbuffer);
                    ////LPJ 2013-9-17 提取GGA数据 --start
                    //GPS_GGAdecode(GPGGAbuffer,ref GPS_Latitude,ref GPS_Longitude);
                    //EnsemblesInfoToStore.Latitude.Add(GPS_Latitude);
                    //EnsemblesInfoToStore.Longitude.Add(GPS_Longitude);
                    ////LPJ 2013-9-17 提取GGA数据 --end

                    ////ve = RTIdata[i].B_Earth[0];
                    ////vn = RTIdata[i].B_Earth[1];

                    //if (GPVTGbuffer != "")
                    //    getGPSBoatSpeed(GPVTGbuffer, ref ve, ref vn); //LPJ 2013-5-21
                    //LPJ 2013-7-9 从外接GPS数据中读取VTG
                    //else if (checkBoxExternalGPSTest.Checked) //LPJ 2013-7-29 该功能是当采用外置GPS计算船速
                    //    getGPSBoatSpeed((string)EnsemblesInfoToStore.GPS_VTGbuffer[i], ref ve, ref vn);

                    CDecodeGPS decodeGPS = new CDecodeGPS();
                    string GPS_Time = "", GPS_NS = "", GPS_EW = "";
                    int Lat_Degree = 0, Lat_Min = 0, Long_Degree = 0, Long_Min = 0;
                    double Lat_Sec = 0, Long_Sec = 0;
                    float fUTCtime = 0;
                    try
                    {
                        decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPVTG", ref GPVTGbuffer);
                        decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPGGA", ref GPGGAbuffer);


                        decodeGPS.GPS_GGAdecode(GPGGAbuffer, ref GPS_Time, ref GPS_Longitude, ref GPS_Latitude, ref GPS_NS, ref GPS_EW);
                        fUTCtime = decodeGPS.GPS_Timedecode(GPS_Time); //LPJ 2017-5-27 将GPS格式的hhmmss.ss时间转换为以s为单位的时间

                        decodeGPS.TransferEarthCoordinate(double.Parse(GPS_Longitude), ref Long_Degree, ref Long_Min, ref Long_Sec);
                        decodeGPS.TransferEarthCoordinate(double.Parse(GPS_Latitude), ref Lat_Degree, ref Lat_Min, ref Lat_Sec);
                        EnsemblesInfoToStore.Latitude.Add(Lat_Degree.ToString() + "°" + Lat_Min.ToString() + "'" + Lat_Sec.ToString() + GPS_NS);
                        EnsemblesInfoToStore.Longitude.Add(Long_Degree.ToString() + "°" + Long_Min.ToString() + "'" + Long_Sec.ToString() + GPS_EW);
                    }
                    catch
                    {
                    }
                    #region GPS VTG

                    float GPS_boatspeed = 0;
                    double GPS_angle = 0;
                    try
                    {
                        decodeGPS.GPS_VTGdecode(GPVTGbuffer, ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn);
                        //decodeGPS.GPS_VTGdecode(GPVTGbuffer, ref ve, ref vn);

                        vGPS.VX = ve;
                        vGPS.VY = vn;
                        EnsemblesInfoToStore.BoatV_GPS.Add(vGPS);

                        boatSpeed = Math.Sqrt(Math.Pow(vGPS.VX, 2) + Math.Pow(vGPS.VY, 2));
                        EnsemblesInfoToStore.BoatSpeed_GPS.Add(boatSpeed);

                        fBoatDir = System.Math.Atan2(vGPS.VX, vGPS.VY); //LPJ 2013-8-1 计算船方向
                        if (fBoatDir < 0)
                            fBoatDir = fBoatDir / Math.PI * 180 + 360;
                        else
                            fBoatDir = fBoatDir / Math.PI * 180;

                        EnsemblesInfoToStore.BoatDir_GPS.Add(fBoatDir);

                        Velocity[] WaterVel = new Velocity[length];
                        
                        GetWaterVelocityToBottom(RTIdata[i], vGPS, ref WaterVel); //计算绝对水流速 //LPJ 2013-7-31 
                        EnsemblesInfoToStore.WaterV_GPS.Add(WaterVel);
                        //SM>
                        double[] waterSpeed = new double[length];
                        //SM<
                        int k = 0;
                        foreach (Velocity v in WaterVel)
                        {
                            waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                            k++;
                        }
                        EnsemblesInfoToStore.WaterSpeed_GPS.Add(waterSpeed);

                        float fVx = 0, fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                        GetAverageWaterSpeed_GPS(i, ref fVx, ref fVy);
                        fAverageX_GPS.Add(fVx); //LPJ 2013-7-3
                        fAverageY_GPS.Add(fVy); //LPJ 2013-7-3 

                        //LPJ  2013-5-18 计算水流方向和船速流速比--start
                        double fWaterDir;
                        fWaterDir = System.Math.Atan2(fVx, fVy);
                        if (fWaterDir < 0)
                            fWaterDir = fWaterDir / Math.PI * 180 + 360;
                        else
                            fWaterDir = fWaterDir / Math.PI * 180;
                        EnsemblesInfoToStore.WaterDir_GPS.Add(fWaterDir);

                        double fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                        EnsemblesInfoToStore.WaterSpeedSum_GPS.Add(fWaterSpeed); //LPJ 2013-7-3

                        double fBoatWater = boatSpeed / fWaterSpeed;
                        EnsemblesInfoToStore.BoatWater_GPS.Add(fBoatWater);
                        //LPJ  2013-5-18 计算水流方向和船速流速比---end

                        WaterSpeedTransToColor2_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[i]);   //
                        //WaterVelocityTransToColor2_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[i]);  //调用新的色彩转换函数
                    }
                    catch
                    {
                    }
                    #endregion

                    #region GPS GGA

                    try
                    {
                        //double gpgga_ve, gpgga_vn;
                        float detT = 0;

                        double Longitude1 = Long_Degree + Long_Min / 60.0 + Long_Sec / 3600.0;
                        double Latitude1 = Lat_Degree + Lat_Min / 60.0 + Lat_Sec / 3600.0;

                        if ("S" == GPS_NS)
                            Latitude1 = -1 * Latitude1;
                        if ("W" == GPS_EW)
                            Longitude1 = -1 * Longitude1;

                        //double Longitude2 = GPGGA_Longitude[GPGGA_Longitude.Count() - 1];
                        //double Latitude2 = GPGGA_Latitude[GPGGA_Latitude.Count() - 1];
                        double Longitude2, Latitude2;
                        //try
                        //{
                        //    Longitude2 = GPGGA_Longitude[GPGGA_Longitude.Count() - 1];
                        //    Latitude2 = GPGGA_Latitude[GPGGA_Latitude.Count() - 1];
                        //}
                        //catch
                        //{
                        //    Longitude2 = Longitude1;
                        //    Latitude2 = Latitude1;
                        //}

                        if (i == 0)
                        {
                            Latitude2 = Latitude1;
                            Longitude2 = Longitude1;
                            detT = 0;
                        }
                        else
                        {
                            Longitude2 = dLastGGA_Lng;
                            Latitude2 = dLastGGA_Lat;
                            detT = fUTCtime - fLastUTCtime;

                            if (detT < 0) //LPJ 2017-5-27 当UTC时间跨天时，时间+86400
                                detT += 86400;
                        }

                        //try
                        //{

                        //    detT = float.Parse(GPS_Time) - GPS_UTCTime[GPS_UTCTime.Count - 1];
                        //}
                        //catch
                        //{
                        //    detT = 0;
                        //}

                        if (detT < 0.00000001)
                        {
                            vGPS.VX = 0;
                            vGPS.VY = 0;
                        }
                        else
                        {
                            //LPJ 2016-8-11 GPS运动速度、真北方向运动角度
                            double gps_speed = TransferGPS2Distance.GetDistance(Latitude2, Longitude2, Latitude1, Longitude1) / detT;
                            double gps_angle = TransferGPS2Distance.GetDirection(Latitude1, Longitude1, Latitude2, Longitude2);
                          
                            double Ve = 0, Vn = 0;

                            if (!double.IsNaN(gps_angle) && !double.IsNaN(gps_speed))  //LPJ 2016-12-15
                            {
                                Ve = gps_speed * Math.Sin(gps_angle);
                                Vn = gps_speed * Math.Cos(gps_angle);
                            }

                            //gpgga_ve = TransferGPS2Distance.GetDistance(Latitude1, Longitude1, Latitude1, Longitude2) / detT;
                            //gpgga_vn = TransferGPS2Distance.GetDistance(Latitude1, Longitude2, Latitude2, Longitude2) / detT;

                            //if (Latitude1 > Latitude2)
                            //    gpgga_vn = -1 * gpgga_vn;
                            //if (Longitude1 > Longitude2)
                            //    gpgga_ve = -1 * gpgga_ve;

                            //double Ve = TransferGPS2Distance.RotateX(gpgga_ve, gpgga_vn, fHeadingOffset);
                            //double Vn = TransferGPS2Distance.RotateY(gpgga_ve, gpgga_vn, fHeadingOffset);

                            vGPS.VX = (float)Ve;
                            vGPS.VY = (float)Vn;

                        }

                        EnsemblesInfoToStore.BoatV_GPGGA.Add(vGPS);

                        boatSpeed = Math.Sqrt(Math.Pow(vGPS.VX, 2) + Math.Pow(vGPS.VY, 2));
                        EnsemblesInfoToStore.BoatSpeed_GPGGA.Add(boatSpeed);

                        fBoatDir = System.Math.Atan2(vGPS.VX, vGPS.VY); //LPJ 2013-8-1 计算船方向
                        if (fBoatDir < 0)
                            fBoatDir = fBoatDir / Math.PI * 180 + 360;
                        else
                            fBoatDir = fBoatDir / Math.PI * 180;

                        EnsemblesInfoToStore.BoatDir_GPGGA.Add(fBoatDir);

                        Velocity[] WaterVel = new Velocity[length];
                        GetWaterVelocityToBottom(RTIdata[i], vGPS, ref WaterVel); //计算绝对水流速 //LPJ 2013-7-31 
                        EnsemblesInfoToStore.WaterV_GPGGA.Add(WaterVel);
                        //SM>
                        double[] waterSpeed = new double[length];
                        //SM<
                        int k = 0;
                        foreach (Velocity v in WaterVel)
                        {
                            waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                            k++;
                        }
                        EnsemblesInfoToStore.WaterSpeed_GPGGA.Add(waterSpeed);

                        float fVx = 0, fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                        GetAverageWaterSpeed_GPGGA(i, ref fVx, ref fVy);
                        fAverageX_GPGGA.Add(fVx); //LPJ 2013-7-3
                        fAverageY_GPGGA.Add(fVy); //LPJ 2013-7-3 

                        //LPJ  2013-5-18 计算水流方向和船速流速比--start
                        double fWaterDir = System.Math.Atan2(fVx, fVy);
                        if (fWaterDir < 0)
                            fWaterDir = fWaterDir / Math.PI * 180 + 360;
                        else
                            fWaterDir = fWaterDir / Math.PI * 180;
                        EnsemblesInfoToStore.WaterDir_GPGGA.Add(fWaterDir);

                        double fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                        EnsemblesInfoToStore.WaterSpeedSum_GPGGA.Add(fWaterSpeed); //LPJ 2013-7-3

                        double fBoatWater = boatSpeed / fWaterSpeed;
                        EnsemblesInfoToStore.BoatWater_GPGGA.Add(fBoatWater);
                        //LPJ  2013-5-18 计算水流方向和船速流速比---end

                        WaterSpeedTransToColor2_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[i]);   //
                        //WaterVelocityTransToColor2_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[i]);  //调用新的色彩转换函数

                        //GPS_UTCTime.Add(float.Parse(GPS_Time));
                        //GPGGA_Latitude.Add(Latitude1);
                        //GPGGA_Longitude.Add(Longitude1);

                        fLastUTCtime = fUTCtime;
                        dLastGGA_Lat = Latitude1;
                        dLastGGA_Lng = Longitude1;
                    }
                    catch
                    {
                    }
                    #endregion
                }
                frmProgressBar.Close();
            }
            catch
            {
            }
        }

        private void RefreshNullBoatSpeed(int iEnsemblesNo) //LPJ 2013-11-22
        {
            //LPJ 2013-7-8 当船速采用GPS数据时，将E000011中的NEMA数据进行解析

            EnsemblesInfoToStore.WaterV_Null.Clear();
            EnsemblesInfoToStore.WaterSpeed_Null.Clear();
            EnsemblesInfoToStore.WaterDir_Null.Clear();
            EnsemblesInfoToStore.WaterSpeedSum_Null.Clear();
       
            Velocity vNull = new Velocity();
         
            int length = (int)RTIdata[0].E_Cells;

            //SM>
            //double[] waterSpeed = new double[length];
            //SM<
            double boatSpeed = 0;

            for (int i = 0; i < iEnsemblesNo; i++)
            {
                vNull.VX = 0;
                vNull.VY = 0;
                //SM>
                double[] waterSpeed = new double[length];
                //SM<
                Velocity[] WaterVel = new Velocity[length];

                GetWaterVelocityToBottom(RTIdata[i], vNull, ref WaterVel); //计算绝对水流速 //LPJ 2013-7-31 
                EnsemblesInfoToStore.WaterV_Null.Add(WaterVel);
                int k = 0;
                foreach (Velocity v in WaterVel)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }

                EnsemblesInfoToStore.WaterSpeed_Null.Add(waterSpeed);

                if (i > 49)
                {
                    //i = i;
                }

                float fVx = 0, fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                GetAverageWaterSpeed_Null(i, ref fVx, ref fVy);
                fAverageX_Null.Add(fVx); //LPJ 2013-7-3
                fAverageY_Null.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start
                double fWaterDir;
                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;
                EnsemblesInfoToStore.WaterDir_Null.Add(fWaterDir);

                double fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum_Null.Add(fWaterSpeed); //LPJ 2013-7-3

                double fBoatWater = boatSpeed / fWaterSpeed;
                EnsemblesInfoToStore.BoatWater_Null.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end

                WaterSpeedTransToColor2_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[i]);   //
                //WaterVelocityTransToColor2_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[i]);  //调用新的色彩转换函数

                if (i > 49)
                {
                    //i = i;
                }
                if (i == 99)
                {
                    //i = i;
                }
            }

        }

        private void RefreshHDT() //LPJ 2016-8-16 当更改艏向参考后，更新所有相关数据
        {
            #region clear
            EnsemblesInfoToStore.WaterVelocity.Clear();
            EnsemblesInfoToStore.WaterSpeed.Clear();
            EnsemblesInfoToStore.BoatVelocity.Clear(); //LPJ 2017-5-17 底跟踪速度更新
            fAverageX.Clear();
            fAverageY.Clear();
            EnsemblesInfoToStore.WaterDir.Clear();
            EnsemblesInfoToStore.WaterSpeedSum.Clear();
            EnsemblesInfoToStore.BoatWater.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor.Clear();

            EnsemblesInfoToStore.WaterV_GPS.Clear();
            EnsemblesInfoToStore.WaterSpeed_GPS.Clear();
            fAverageX_GPS.Clear();
            fAverageY_GPS.Clear();
            EnsemblesInfoToStore.WaterDir_GPS.Clear();
            EnsemblesInfoToStore.WaterSpeedSum_GPS.Clear();
            EnsemblesInfoToStore.BoatWater_GPS.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPS.Clear();

            EnsemblesInfoToStore.WaterV_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeed_GPGGA.Clear();
            fAverageX_GPGGA.Clear();
            fAverageY_GPGGA.Clear();
            EnsemblesInfoToStore.WaterDir_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeedSum_GPGGA.Clear();
            EnsemblesInfoToStore.BoatWater_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA.Clear();

            EnsemblesInfoToStore.WaterV_Null.Clear();
            EnsemblesInfoToStore.WaterSpeed_Null.Clear();
            fAverageX_Null.Clear();
            fAverageY_Null.Clear();
            EnsemblesInfoToStore.WaterDir_Null.Clear();
            EnsemblesInfoToStore.WaterSpeedSum_Null.Clear();
            EnsemblesInfoToStore.BoatWater_Null.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor_Null.Clear();
            #endregion

            for (int i = 0; i < EnsembleNumOfAllFiles; i++) //读取原始数据文件            
            {
               
                #region LPJ 2016-8-10 艏向参考外接罗盘
                if (labelHeadingRef.Text == Resource1.String231)
                {
                    float fGPS_HDT = RTIdata[i].A_Heading;
                    try
                    {
                        if (bGPSConnect)
                        {
                            fGPS_HDT = float.Parse((string)EnsemblesInfoToStore.GPS_HDT[i]);
                        }
                        else
                        {
                            string NMEA_buffer = "";
                            string GPHDTbuffer = "";
                            NMEA_buffer = Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);

                            CDecodeGPS decodeGPS = new CDecodeGPS();
                            decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPHDT", ref GPHDTbuffer);
                            decodeGPS.GPS_HDTdecode(GPHDTbuffer, ref fGPS_HDT);
                        }

                        for (int j = 0; j < RTIdata[i].E_Cells; j++)
                        {
                            float fEarth = 0;
                            float fNorth = 0;
                            CalXYZ2ENU(RTIdata[i].Instrument[0, j], RTIdata[i].Instrument[1, j], RTIdata[i].Instrument[2, j], fGPS_HDT + (float)fHeadingOffset, RTIdata[i].A_Pitch, RTIdata[i].A_Roll, ref fEarth, ref fNorth);
                            RTIdata[i].Earth[0, j] = fEarth;
                            RTIdata[i].Earth[1, j] = fNorth;
                        }

                        float fEarth_BT = 0;
                        float fNorth_BT = 0;
                        CalXYZ2ENU(RTIdata[i].B_Instrument[0], RTIdata[i].B_Instrument[1], RTIdata[i].B_Instrument[2], fGPS_HDT + (float)fHeadingOffset, RTIdata[i].B_Pitch, RTIdata[i].B_Roll, ref fEarth_BT, ref fNorth_BT);
                        RTIdata[i].B_Earth[0] = fEarth_BT;
                        RTIdata[i].B_Earth[1] = fNorth_BT;
                    }
                    catch
                    {
                    }
                }
                else
                {
                    for (int j = 0; j < RTIdata[i].E_Cells; j++)
                    {
                        float fEarth = 0;
                        float fNorth = 0;
                        CalXYZ2ENU(RTIdata[i].Instrument[0, j], RTIdata[i].Instrument[1, j], RTIdata[i].Instrument[2, j], RTIdata[i].A_Heading + (float)fHeadingOffset, RTIdata[i].A_Pitch, RTIdata[i].A_Roll, ref fEarth, ref fNorth);
                        RTIdata[i].Earth[0, j] = fEarth;
                        RTIdata[i].Earth[1, j] = fNorth;
                    }

                    float fEarth_BT = 0;
                    float fNorth_BT = 0;
                    CalXYZ2ENU(RTIdata[i].B_Instrument[0], RTIdata[i].B_Instrument[1], RTIdata[i].B_Instrument[2], RTIdata[i].B_Heading + (float)fHeadingOffset, RTIdata[i].B_Pitch, RTIdata[i].B_Roll, ref fEarth_BT, ref fNorth_BT);
                    RTIdata[i].B_Earth[0] = fEarth_BT;
                    RTIdata[i].B_Earth[1] = fNorth_BT;

                }
                #endregion

                Velocity Bv = new Velocity();

                Bv.VX = RTIdata[i].B_Earth[0];
                Bv.VY = RTIdata[i].B_Earth[1];
                Bv.VZ = RTIdata[i].B_Earth[2];
                EnsemblesInfoToStore.BoatVelocity.Add(Bv); //LPJ 2017-5-17

                #region BT
                //LPJ 2014-6-4 流速由原始数据获取
                Velocity[] VEarth = new Velocity[cells];
                for (int n = 0; n < cells; n++)
                {
                    VEarth[n].VX = RTIdata[i].Earth[0, n];
                    VEarth[n].VY = RTIdata[i].Earth[1, n];
                    VEarth[n].VZ = RTIdata[i].Earth[2, n];
                    //绝对速度
                    if (VEarth[n].VX <= 80.0 && VEarth[n].VY <= 80.0 && VEarth[n].VZ <= 80.0)
                    {
                        VEarth[n].VX += Bv.VX;
                        VEarth[n].VY += Bv.VY;
                        VEarth[n].VZ += Bv.VZ;
                    }
                }
                EnsemblesInfoToStore.WaterVelocity.Add(VEarth);

                Velocity[] Vel = (Velocity[])EnsemblesInfoToStore.WaterVelocity[i];  //Modified HERE 2011-7-28 get velocity here!!!
                double[] waterSpeed = new double[Vel.Length];
                int k = 0;
                foreach (Velocity v in Vel)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }
                EnsemblesInfoToStore.WaterSpeed.Add(waterSpeed);

                float fVx = 0, fVy = 0;
                int iGoodBinNum = GetAverageWaterSpeed(i, ref fVx, ref fVy);

                fAverageX.Add(fVx); //LPJ 2013-7-3
                fAverageY.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start
                double fWaterDir;

                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;
                EnsemblesInfoToStore.WaterDir.Add(fWaterDir);

                double fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum.Add(fWaterSpeed); //LPJ 2013-7-3

                double fBoatWater = 0;
                if (fWaterSpeed > 0.0001)
                    fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed[i] / fWaterSpeed;
                EnsemblesInfoToStore.BoatWater.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end

                WaterSpeedTransToColor2((Velocity[])EnsemblesInfoToStore.WaterVelocity[i]);   //JZH 2011-12-25 调用新的色彩转换函数
                //WaterVelocityTransToColor2((Velocity[])EnsemblesInfoToStore.WaterVelocity[i]);  //JZH 2011-12-25 调用新的色彩转换函数
                #endregion

                #region VTG
                Velocity[] WaterVel = new Velocity[Vel.Length];
                Velocity vGPS = new Velocity();

                vGPS = (Velocity)EnsemblesInfoToStore.BoatV_GPS[i];
                GetWaterVelocityToBottom(RTIdata[i], vGPS, ref WaterVel); //计算绝对水流速 //LPJ 2013-7-31 
                EnsemblesInfoToStore.WaterV_GPS.Add(WaterVel);

                k = 0;
                foreach (Velocity v in WaterVel)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }
                EnsemblesInfoToStore.WaterSpeed_GPS.Add(waterSpeed);

                fVx = 0; fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                GetAverageWaterSpeed_GPS(i, ref fVx, ref fVy);
                fAverageX_GPS.Add(fVx); //LPJ 2013-7-3
                fAverageY_GPS.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start

                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;
                EnsemblesInfoToStore.WaterDir_GPS.Add(fWaterDir);

                fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum_GPS.Add(fWaterSpeed); //LPJ 2013-7-3

                fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed_GPS[i] / fWaterSpeed;
                EnsemblesInfoToStore.BoatWater_GPS.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end

                WaterSpeedTransToColor2_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[i]);   //
                //WaterVelocityTransToColor2_GPS((Velocity[])EnsemblesInfoToStore.WaterV_GPS[i]);  //调用新的色彩转换函数
                #endregion

                #region GGA
                Velocity[] WaterVel_GGA = new Velocity[Vel.Length];
                vGPS = (Velocity)EnsemblesInfoToStore.BoatV_GPGGA[i];
                GetWaterVelocityToBottom(RTIdata[i], vGPS, ref WaterVel_GGA); //计算绝对水流速 //LPJ 2013-7-31 
                EnsemblesInfoToStore.WaterV_GPGGA.Add(WaterVel_GGA);

                k = 0;
                foreach (Velocity v in WaterVel_GGA)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }
                EnsemblesInfoToStore.WaterSpeed_GPGGA.Add(waterSpeed);

                fVx = 0; fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                GetAverageWaterSpeed_GPGGA(i, ref fVx, ref fVy);
                fAverageX_GPGGA.Add(fVx); //LPJ 2013-7-3
                fAverageY_GPGGA.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start
                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;
                EnsemblesInfoToStore.WaterDir_GPGGA.Add(fWaterDir);

                fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum_GPGGA.Add(fWaterSpeed); //LPJ 2013-7-3

                fBoatWater = (double)EnsemblesInfoToStore.BoatSpeed_GPGGA[i] / fWaterSpeed;
                EnsemblesInfoToStore.BoatWater_GPGGA.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end

                WaterSpeedTransToColor2_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[i]);   //
                //WaterVelocityTransToColor2_GPGGA((Velocity[])EnsemblesInfoToStore.WaterV_GPGGA[i]); 
                #endregion

                #region Null

                Velocity vNull = new Velocity();
                vNull.VX = 0;
                vNull.VY = 0;
                Velocity[] WaterVel_NULL = new Velocity[Vel.Length];
                GetWaterVelocityToBottom(RTIdata[i], vNull, ref WaterVel_NULL); //计算绝对水流速 //LPJ 2013-7-31 
                EnsemblesInfoToStore.WaterV_Null.Add(WaterVel_NULL);

                k = 0;
                foreach (Velocity v in WaterVel_NULL)
                {
                    waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                    k++;
                }
                EnsemblesInfoToStore.WaterSpeed_Null.Add(waterSpeed);

                fVx = 0; fVy = 0; //LPJ 2013-5-16 计算有效单元层数
                GetAverageWaterSpeed_Null(i, ref fVx, ref fVy);
                fAverageX_Null.Add(fVx); //LPJ 2013-7-3
                fAverageY_Null.Add(fVy); //LPJ 2013-7-3 

                //LPJ  2013-5-18 计算水流方向和船速流速比--start
                fWaterDir = System.Math.Atan2(fVx, fVy);
                if (fWaterDir < 0)
                    fWaterDir = fWaterDir / Math.PI * 180 + 360;
                else
                    fWaterDir = fWaterDir / Math.PI * 180;
                EnsemblesInfoToStore.WaterDir_Null.Add(fWaterDir);

                fWaterSpeed = Math.Sqrt(Math.Pow(fVx, 2) + Math.Pow(fVy, 2));
                EnsemblesInfoToStore.WaterSpeedSum_Null.Add(fWaterSpeed); //LPJ 2013-7-3

                fBoatWater = 0;
                EnsemblesInfoToStore.BoatWater_Null.Add(fBoatWater);
                //LPJ  2013-5-18 计算水流方向和船速流速比---end

                WaterSpeedTransToColor2_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[i]);   //
                //WaterVelocityTransToColor2_Null((Velocity[])EnsemblesInfoToStore.WaterV_Null[i]);  //调用新的色彩转换函数
                #endregion
            }

            ChangeToNewRGB(); //修改颜色
        }

        private void GetWaterVelocityToBottom(ArrayClass Arr, Velocity Bv, ref Velocity[] Vel) //LPJ 2013-7-31 获取绝对流速
        {
            int n = GetVelocityBins(Arr, 0);//得到水单元层数

            Velocity waterV = new Velocity(); //LPJ 2013-7-15
            //Velocity[] waterVelocity = new Velocity[n];

            for (int i = 0; i < n; i++)
            {
                waterV.VX = Arr.Earth[0, i];
                waterV.VY = Arr.Earth[1, i];
                waterV.VZ = Arr.Earth[2, i];  //注意，以后改写Velocity结构，加入VQ JZH 2012-03-21
                //JZH 2012-03-21 绝对速度

                if (waterV.VX <= 80.0 && waterV.VY <= 80.0)
                {
                    Vel[i].VX = waterV.VX + Bv.VX;  //JZH 2012-03-21 获取绝对速度
                    Vel[i].VY = waterV.VY + Bv.VY;
                }//SM>
                else 
                {
                    Vel[i].VX = waterV.VX;
                    Vel[i].VY = waterV.VY;
                }//SM<
            }
        }

        private void WaterSpeedTransToColor2_GPS(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            //Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            //Color[] VelColor3 = new Color[WaterVel.Length];
            //Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                //VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                //if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                //{
                //    VelColor3[i] = NumToColor(Vxyz, 3, false);
                //    VelColor4[i] = NumToColor(Vxyz, 4, false);
                //}
                //else
                //{
                //    VelColor3[i] = NumToColor(Vxyz, 3, true);
                //    VelColor4[i] = NumToColor(Vxyz, 4, true);
                //}
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPS.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPS.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPS.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPS.Add(VelColor4);

        }
        /*
        private void WaterVelocityTransToColor2_GPS(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPS.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPS.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPS.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPS.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPS.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPS.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPS.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPS.Add(VelColorE4);

        }
        */
        private void WaterSpeedTransToColor2_GPGGA(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPGGA.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPGGA.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPGGA.Add(VelColor4);

        }
        /*
        private void WaterVelocityTransToColor2_GPGGA(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPGGA.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPGGA.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPGGA.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPGGA.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPGGA.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPGGA.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPGGA.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPGGA.Add(VelColorE4);

        }
        */

        private void WaterSpeedTransToColor2_Null(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColor1 = new Color[WaterVel.Length];
            Color[] VelColor2 = new Color[WaterVel.Length];
            Color[] VelColor3 = new Color[WaterVel.Length];
            Color[] VelColor4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vxyz = (float)Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2) + Math.Pow(v.VZ, 2));
                VelColor1[i] = NumToColor(Vxyz, 1, true);
                VelColor2[i] = NumToColor(Vxyz, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, false);
                    VelColor4[i] = NumToColor(Vxyz, 4, false);
                }
                else
                {
                    VelColor3[i] = NumToColor(Vxyz, 3, true);
                    VelColor4[i] = NumToColor(Vxyz, 4, true);
                }
                i++;
            }
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_Null.Add(VelColor1);
            EnsemblesInfoToStore.WaterSpeedToSixColor_Null.Add(VelColor2);
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_Null.Add(VelColor3);
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_Null.Add(VelColor4);

        }
        /*
        private void WaterVelocityTransToColor2_Null(Velocity[] WaterVel) //LPJ 2013-7-31
        {
            Color[] VelColorN1 = new Color[WaterVel.Length];
            Color[] VelColorN2 = new Color[WaterVel.Length];
            Color[] VelColorN3 = new Color[WaterVel.Length];
            Color[] VelColorN4 = new Color[WaterVel.Length];

            Color[] VelColorE1 = new Color[WaterVel.Length];
            Color[] VelColorE2 = new Color[WaterVel.Length];
            Color[] VelColorE3 = new Color[WaterVel.Length];
            Color[] VelColorE4 = new Color[WaterVel.Length];
            int i = 0;
            foreach (Velocity v in WaterVel)
            {
                float Vn = Math.Abs(v.VX);
                VelColorN1[i] = NumToColor(Vn, 1, true);
                VelColorN2[i] = NumToColor(Vn, 2, true);
                if (v.VX <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorN3[i] = NumToColor(Vn, 3, false);
                    VelColorN4[i] = NumToColor(Vn, 4, false);
                }
                else
                {
                    VelColorN3[i] = NumToColor(Vn, 3, true);
                    VelColorN4[i] = NumToColor(Vn, 4, true);
                }

                float Ve = Math.Abs(v.VY);
                VelColorE1[i] = NumToColor(Ve, 1, true);
                VelColorE2[i] = NumToColor(Ve, 2, true);
                if (v.VY <= 0)//向外：蓝->绿/黑-蓝-青（511阶颜色）
                {
                    VelColorE3[i] = NumToColor(Ve, 3, false);
                    VelColorE4[i] = NumToColor(Ve, 4, false);
                }
                else
                {
                    VelColorE3[i] = NumToColor(Ve, 3, true);
                    VelColorE4[i] = NumToColor(Ve, 4, true);
                }
                i++;
            }

            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_Null.Add(VelColorN1);
            //EnsemblesInfoToStore.NorthVelocityToSixColor_Null.Add(VelColorN2);
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_Null.Add(VelColorN3);
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_Null.Add(VelColorN4);
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_Null.Add(VelColorE1);
            //EnsemblesInfoToStore.EastVelocityToSixColor_Null.Add(VelColorE2);
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_Null.Add(VelColorE3);
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_Null.Add(VelColorE4);

        }
        */

        #region 将流量计算模块提取出来 //LPJ 2013-6-8
       
        private void CalDischarge()
        {
            try
            {
                //JZH 2012-01-12 新流量回放计算　　　 ------------开始
                List<ArrayClass> left = new List<ArrayClass>();
                List<ArrayClass> right = new List<ArrayClass>();

                double topFlow = 0;
                double measuredFlow = 0;
                double bottomFlow = 0;
                double rightFlow = 0;
                double leftFlow = 0;
                double dShoreVelDir = 0;  //JZH 2012-04-06 岸边流速方向 用来判断岸边流量正负
                double dShoreCoff = 1.0;  //JZH 2012-04-06 岸边流量系数 用来判断岸边流量正负
                double lastSecond = double.NaN;

                float fAccEast = 0; //JZH 2012-04-08  底跟踪东向累积量
                float fAccNorth = 0; //JZH 2012-04-08 底跟踪北向累积量
                float fAccLength = 0; //JZH 2012-04-08 航迹累积长度
                bool bGetFirstGoodEnsemble = true; //JZH 2012-04-08 采集到第一个有效单元
                int iPrevGoodEnsembleNoOffset = 0;  //JZH 2012-04-08  底跟踪前一个有效单元的偏移
                int iPrevGoodEnsemblePos = 0;
                float fAccMG = 0;   //JZH 2012-04-08 直线距离
                double dCourseMG = 0; //JZH 2012-04-08 直线方向角

                float fRiverWidth = 0;  //JZH 2012-04-15 河宽
                //List<ArrayList> lAccEastLength=new List<ArrayList>();  //JZH 2012-04-15
                //List<ArrayList> lAccNorthLenth = new List<ArrayList>(); //JZH 2012-04-15
                ArrayList lEastLength = new ArrayList();   //JZH 2012-04-15
                ArrayList lNorthLength = new ArrayList();  //JZH 2012-04-15
                ArrayList lBottomDepth = new ArrayList();  //JZH 2012-04-15

                //JZH 2012-04-17 计算平均流向参数
                float fAccVx = 0;
                float fAccVy = 0;
                float fAveDepth = 0;
                float fArea = 0;
                double dRightShoreArea = 0.0;
                double dLeftShoreArea = 0.0;
                double fMeanFlowDir = 0;


                float fTransducerDepth, fLeftDis, fRightDis;
                //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1
                if (!bEnglish2Metric)
                {
                    try
                    {
                        fTransducerDepth = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                    }
                    catch
                    {
                        fTransducerDepth = (float)(projectUnit.FeetToMeter(0.1, 1));
                    }
                    try
                    {
                        fLeftDis = (float)(projectUnit.FeetToMeter(double.Parse(labelLeftDis.Text), 1));
                        fRightDis = (float)(projectUnit.FeetToMeter(double.Parse(labelRightDis.Text), 1));
                    }
                    catch
                    {
                        fLeftDis = 0;
                        fRightDis = 0;
                    }
                }
                else
                {
                    try
                    {
                        fTransducerDepth = float.Parse(labelTransducerDepth.Text);
                    }
                    catch
                    {
                        fTransducerDepth = 0.1f;
                    }
                    try
                    {
                        fLeftDis = float.Parse(labelLeftDis.Text);
                        fRightDis = float.Parse(labelRightDis.Text);
                    }
                    catch
                    {
                        fLeftDis = 0;
                        fRightDis = 0;
                    }
                }

                double fPowerCurveCoeff;
                try
                {
                    fPowerCurveCoeff = double.Parse(labelPowerCurveCoeff.Text); //LPJ 2014-8-28
                }
                catch
                {
                    fPowerCurveCoeff = 0.1667;
                }

                for (int i = 0; i < BinDataEnsembleNum; i++)
                {
                    //2012-04-08 计算导航信息
                    #region 计算导航信息
                    {
                        if (i == 0)
                        {
                            Velocity BoatVelocity = new Velocity(); //LPJ 2013-7-31
                            try
                            {
                                BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatVelocity[i]);  //LPJ 2013-7-31
                            }
                            catch
                            {
                                continue;
                            }

                            if ("GPS VTG" == labelVesselRef.Text)  //LPJ 2013-7-31
                            {
                                try
                                {
                                    BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPS[i]);  //LPJ 2013-7-31
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)  //LPJ 2013-7-31
                            {
                                try
                                {
                                    BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i]);  //LPJ 2013-7-31

                                }
                                catch
                                { continue; }
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                            {
                                BoatVelocity.VX = 0;
                                BoatVelocity.VY = 0;
                            }

                            if (Math.Abs(BoatVelocity.VX) > 20 || Math.Abs(BoatVelocity.VY) > 20)
                            //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                            {
                                //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                                bGetFirstGoodEnsemble = false;
                            }
                            else  //JZH 2012-04-09 初始化流量计算参数
                            {
                                bGetFirstGoodEnsemble = true;
                                lastSecond = RTIdata[0].A_FirstPingSeconds;
                                iPrevGoodEnsemblePos = 0;
                            }
                        }
                        else
                        {
                            //LPJ 2013-9-13 添加船速参考GPS选项，并添加headingOffset修正Discharge
                            Velocity BoatVelocity = new Velocity(); //LPJ 2013-7-31
                            Velocity PrecBoatVelocity = new Velocity();

                            try
                            {
                                BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatVelocity[i]);  //LPJ 2013-7-31
                                PrecBoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatVelocity[iPrevGoodEnsemblePos]);
                            }
                            catch
                            {
                                continue;
                            }

                            if ("GPS VTG" == labelVesselRef.Text)  //LPJ 2013-7-31
                            {
                                try
                                {
                                    BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPS[i]);  //LPJ 2013-7-31
                                    PrecBoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPS[iPrevGoodEnsemblePos]);

                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)  //LPJ 2013-7-31
                            {
                                try
                                {
                                    BoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i]);  //LPJ 2013-7-31
                                    PrecBoatVelocity = (Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[iPrevGoodEnsemblePos]);

                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                            {
                                BoatVelocity.VX = 0;
                                BoatVelocity.VY = 0;
                                PrecBoatVelocity.VX = 0;
                                PrecBoatVelocity.VY = 0;
                            }

                            if (Math.Abs(BoatVelocity.VX) < 20 &&Math.Abs( BoatVelocity.VY )< 20)
                            //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX < 20 && ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY < 20)
                            {
                                if (bGetFirstGoodEnsemble)
                                {
                                    //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[iPrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * (float)EnsemblesInfoToStore.t[i];
                                    //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[iPrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * (float)EnsemblesInfoToStore.t[i];
                                    //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[iPrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * (float)(RTIdata[i].A_FirstPingSeconds - lastSecond);
                                    //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[iPrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * (float)(RTIdata[i].A_FirstPingSeconds - lastSecond);

                                    float LEast = (1.0f) * 0.5f * (float)(PrecBoatVelocity.VX + BoatVelocity.VX) * (float)(RTIdata[i].A_FirstPingSeconds - lastSecond); //LPJ 2013-9-13
                                    float LNorth = (1.0f) * 0.5f * (float)(PrecBoatVelocity.VY + BoatVelocity.VY) * (float)(RTIdata[i].A_FirstPingSeconds - lastSecond);  //LPJ 2013-9-13

                                    fAccEast += LEast;
                                    fAccNorth += LNorth;
                                    fAccLength += (float)System.Math.Sqrt(System.Math.Pow(LEast, 2) + System.Math.Pow(LNorth, 2));
                                    fAccMG = (float)System.Math.Sqrt(System.Math.Pow(fAccEast, 2) + System.Math.Pow(fAccNorth, 2));
                                    dCourseMG = System.Math.Atan2(fAccEast, fAccNorth);
                                    //UTMpoint.X = UTMpoint.X + (int)LEast;
                                    //UTMpoint.Y = UTMpoint.Y + (int)LNorth;
                                    //FirstGoodEnsembleNoOffset = 0;
                                    iPrevGoodEnsembleNoOffset = 0;
                                    iPrevGoodEnsemblePos = i;

                                    //JZH 2012-04-17 计算平均流向
                                    float fVx = 0;
                                    float fVy = 0;
                                    //CalculateAverageWaterSpeed(i, ref fVx, ref fVy, ref fAveDepth);
                                    fAveDepth = (float)EnsemblesInfoToStore.bottomDepth[i];

                                    fVx = fAverageX[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过
                                    fVy = fAverageY[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过

                                    if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        fVx = fAverageX_GPS[i];
                                        fVy = fAverageY_GPS[i];
                                    }
                                    else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        fVx = fAverageX_GPGGA[i];
                                        fVy = fAverageY_GPGGA[i];
                                    }
                                    else if (Resource1.String233 == labelVesselRef.Text)
                                    {
                                        fVx = fAverageX_Null[i];
                                        fVy = fAverageY_Null[i];
                                    }

                                    

                                    fAccVx += fVx;
                                    fAccVy += fVy;

                                    fMeanFlowDir = System.Math.Atan2(fAccVx, fAccVy);

                                    double dProjectionDir = 0; //投影角度
                                    if (!bStartLeftEdge)
                                        dProjectionDir = fMeanFlowDir - Math.PI / 2.0;
                                    else
                                        dProjectionDir = fMeanFlowDir + Math.PI / 2.0;

                                    //JZH 2012-04-15 计算投影长度和面积
                                    lEastLength.Add(LEast);
                                    lNorthLength.Add(LNorth);
                                    lBottomDepth.Add(EnsemblesInfoToStore.bottomDepth[i]);

                                    fRiverWidth = 0;
                                    fArea = 0;
                                    for (int k = 0; k < lEastLength.Count; k++)
                                    {
                                        fArea += ((float)lEastLength[k] * (float)Math.Sin(dProjectionDir) + (float)lNorthLength[k] * (float)Math.Cos(dProjectionDir)) * ((float)lBottomDepth[k] + fTransducerDepth);
                                        fRiverWidth += (float)lEastLength[k] * (float)Math.Sin(dProjectionDir) + (float)lNorthLength[k] * (float)Math.Cos(dProjectionDir);
                                    }

                                    //fArea += (LEast * (float)Math.Sin(dProjectionDir) + LNorth * (float)Math.Cos(dProjectionDir)) * ((float)EnsemblesInfoToStore.bottomDepth[i] + fTransducerDepth); //LPJ 2013-7-3
                                    //fRiverWidth += LEast * (float)Math.Sin(dProjectionDir) + LNorth * (float)Math.Cos(dProjectionDir);

                                    //JZH 2012-04-09 计算中部流量
                                    #region 中部流量
                                    {
                                        CalculateEnsembleFlowParam param = new CalculateEnsembleFlowParam();
                                        param.RiverDischarge_dTime = RTIdata[i].A_FirstPingSeconds - lastSecond;
                                        //param.RiverDischargeBottomMode = comboBoxBottomMode.SelectedIndex == 0 ? BottomFlowMode.PowerFunction : BottomFlowMode.Constants;
                                        //switch (comboBoxTopMode.SelectedIndex)
                                        //{
                                        //    case 0:
                                        //        {
                                        //            param.RiverDischargeTopMode = TopFlowMode.PowerFunction;
                                        //            break;
                                        //        }
                                        //    case 1:
                                        //        {
                                        //            param.RiverDischargeTopMode = TopFlowMode.Constants;
                                        //            break;
                                        //        }
                                        //    case 2:
                                        //        {
                                        //            param.RiverDischargeTopMode = TopFlowMode.Slope;
                                        //            break;
                                        //        }
                                        //    default:
                                        //        break;
                                        //}
                                        if (labelTopEstimate.Text == Resource1.String33) //LPJ 2013-6-22
                                            param.RiverDischargeTopMode = TopFlowMode.PowerFunction;
                                        else if (labelTopEstimate.Text == Resource1.String224)
                                            param.RiverDischargeTopMode = TopFlowMode.Constants;
                                        else
                                            param.RiverDischargeTopMode = TopFlowMode.Slope;

                                        if (labelBottomEstimate.Text == Resource1.String33)
                                            param.RiverDischargeBottomMode = BottomFlowMode.PowerFunction;
                                        else
                                            param.RiverDischargeBottomMode = BottomFlowMode.Constants;

                                        param.RiverDischargeDraft = fTransducerDepth;   //ADCP吃水
                                        //param.RiverDischargeExponent = (double)numericUpDownE.Value;    //指数
                                        //try
                                        //{
                                        //    param.RiverDischargeExponent = double.Parse(labelPowerCurveCoeff.Text); //LPJ 2013-6-22
                                        //}
                                        //catch
                                        //{
                                        //    param.RiverDischargeExponent = 0.1667;
                                        //}
                                        param.RiverDischargeExponent = fPowerCurveCoeff;

                                        param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;
                                        param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;
                                        param.RiverDischargeOrgData = RTIdata[i];

                                        float ve, vn; //LPJ 2013-7-31
                                        ve = RTIdata[i].B_Earth[0]; //LPJ 2013-7-31
                                        vn = RTIdata[i].B_Earth[1]; //LPJ 2013-7-31

                                        double dHeadingOffset = 0; //LPJ 2013-9-13
                                       
                                        if ("GPS VTG" == labelVesselRef.Text)
                                        {
                                            Velocity boatV_GPS = new Velocity();
                                            boatV_GPS = (Velocity)(EnsemblesInfoToStore.BoatV_GPS[i]);
                                            ve = boatV_GPS.VX;
                                            vn = boatV_GPS.VY;

                                            //LPJ 2013-11-14 当采用自动GPS校正功能后，dHeadingOffset值通过计算获得
                                            //try
                                            //{
                                            //    dHeadingOffset = double.Parse(labelHeadingOffset.Text) / 180 * Math.PI;
                                            //}
                                            //catch
                                            //{
                                            //    dHeadingOffset = 0;
                                            //}
                                            //if (labelHeadingRef.Text != Resource1.String231)
                                            //dHeadingOffset = fHeadingOffset / 180 * Math.PI;  //LPJ 2017-5-12
                                        }
                                        else if ("GPS GGA" == labelVesselRef.Text)
                                        {
                                            Velocity boatV_GPS = new Velocity();
                                            boatV_GPS = (Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i]);
                                            ve = boatV_GPS.VX;
                                            vn = boatV_GPS.VY;

                                            //if (labelHeadingRef.Text != Resource1.String231)
                                            //dHeadingOffset = fHeadingOffset / 180 * Math.PI;  //LPJ 2017-5-12
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                            ve = 0;
                                            vn = 0;
                                        }

                                        EnsembleFlowInfo flow = Calcflow.RiverDischargeCalculate.CalculateEnsembleFlow(param, ve, vn, dHeadingOffset); //LPJ  2013-7-31

                                        //EnsembleFlowInfo flow = Calcflow.RiverDischargeCalculate.CalculateEnsembleFlow(param);
                                        if (flow.Valid)
                                        {//有效的数据
                                            //JZH 2012-02-05  根据左右岸，判定流量正负
                                            //if (radioButtonLeftToRight.Checked)
                                            if (bStartLeftEdge)
                                            {
                                                topFlow += flow.TopFlow;
                                                measuredFlow += flow.MeasuredFlow;
                                                bottomFlow += flow.BottomFlow;
                                            }
                                            else
                                            {
                                                topFlow += flow.TopFlow * (-1.0);
                                                measuredFlow += flow.MeasuredFlow * (-1.0);
                                                bottomFlow += flow.BottomFlow * (-1.0);
                                            }
                                            lastSecond = RTIdata[i].A_FirstPingSeconds;
                                            //添加判断左右岸

                                            //if (left.Count < avgNum)
                                            if (left.Count < dLeftShorePings) //LPJ 2013-5-29 左岸平均呯数
                                            {
                                                left.Add(RTIdata[i]);
                                            }
                                            else
                                            {
                                                //if (radioButtonRightToLeft.Checked)   //
                                                if (!bStartLeftEdge)
                                                {
                                                    if (left.Count > 0)
                                                        left.RemoveAt(0);
                                                    left.Add(RTIdata[i]);
                                                }
                                            }

                                            //if (right.Count < avgNum)
                                            if (right.Count < dRightShorePings) //LPJ 2013-5-29 右岸平均呯数
                                            {
                                                right.Add(RTIdata[i]);
                                            }
                                            else
                                            {
                                                //if (radioButtonLeftToRight.Checked)
                                                if (bStartLeftEdge)
                                                {
                                                    if (right.Count > 0)
                                                        right.RemoveAt(0);
                                                    right.Add(RTIdata[i]);
                                                }
                                            }
                                            //lastSecond = RTIdata[i].A_FirstPingSeconds;
                                        }
                                        lastSecond = RTIdata[i].A_FirstPingSeconds;
                                        //label_TopDiacharge.Text = topFlow.ToString("0.000");   //JZH 2012-04-17 Cancel
                                        //label_MiddleDischarge.Text = measuredFlow.ToString("0.000");
                                        //label_BottomeDischarge.Text = bottomFlow.ToString("0.000");
                                    }
                                    #endregion

                                }
                                else
                                {
                                    //FirstGoodEnsembleNoOffset++;
                                    bGetFirstGoodEnsemble = true;
                                    iPrevGoodEnsemblePos = i;
                                    //JZH 2012-04-09 
                                    lastSecond = RTIdata[i].A_FirstPingSeconds;
                                }
                            }
                            else
                            {
                                iPrevGoodEnsembleNoOffset++;

                            }
                        }
                    }
                    #endregion
                }
                //JZH 2012-04-08 更新导航面板

                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                if (!bEnglish2Metric)
                {
                    current_Length = projectUnit.MeterToFeet(fAccLength, 1).ToString("0.00");
                    current_DistanceMG = projectUnit.MeterToFeet(fAccMG, 1).ToString("0.00");
                    label_AccEast.Text = projectUnit.MeterToFeet(fAccEast, 1).ToString("0.00");
                    label_AccNorth.Text = projectUnit.MeterToFeet(fAccNorth, 1).ToString("0.00");
                }
                else
                {
                    current_Length = fAccLength.ToString("0.00");
                    current_DistanceMG = fAccMG.ToString("0.00");
                    label_AccEast.Text = fAccEast.ToString("0.00");
                    label_AccNorth.Text = fAccNorth.ToString("0.00");
                }

                if (dCourseMG < 0)
                    dCourseMG = dCourseMG / Math.PI * 180 + 360;
                else
                    dCourseMG = dCourseMG / Math.PI * 180;
                current_CourseMG = dCourseMG.ToString("0.0");


                #region 计算左岸流量
                try
                {
                    CalculateShoreFlowParam param = new CalculateShoreFlowParam();
                    //param.RiverDischarge_A = 0.35;     //岸边系数
                    double leftRef = 0.35;

                    try
                    {
                        leftRef = double.Parse(labelLeftRef.Text);
                    }
                    catch
                    {
                        leftRef = 0.35;
                    }
                    param.RiverDischarge_A = leftRef;
                    //param.RiverDischargeDraft = 0.0;  //ADCP吃水
                    param.RiverDischargeDraft = fTransducerDepth;
                    //param.RiverDischargeDistance = 1.0; //岸边距离
                    param.RiverDischargeDistance = fLeftDis;
                    param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;        //ADCP参数
                    param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;  //判断GOODBIn条件
                    param.RiverDischargeOrgData = left.ToArray();
                    leftFlow = Calcflow.RiverDischargeCalculate.CalculateShoreFlow(param);
                    //JZH 2012-04-08 添加岸边流速方向角计算，用于判断岸边流量的正负值                
                    dShoreVelDir = Calcflow.RiverDischargeCalculate.CalculateShoreVelocity(param);  //JZH 2012-04-06 获取岸边平均流速的方向
                    if (dCourseMG >= 0 && dCourseMG <= 180)
                    {
                        if (dShoreVelDir - dCourseMG >= 0 && dShoreVelDir - dCourseMG <= 180)
                        {
                            dShoreCoff = -1.0;
                        }
                        else
                        {
                            dShoreCoff = 1.0;
                        }
                    }
                    else
                    {
                        if (dShoreVelDir - dCourseMG <= 0 && dShoreVelDir - dCourseMG >= -180)
                        {
                            dShoreCoff = 1.0;
                        }
                        else
                        {
                            dShoreCoff = -1.0;
                        }
                    }

                    //vel=Calcflow.RiverDischargeCalculate
                    //JZH 2012-02-05 采用简易判定方法，确定左右岸流量正负
                    //   if (radioButtonRightToLeft.Checked)
                    if (!bStartLeftEdge) //LPJ 2013-6-21
                    {
                        leftFlow = Math.Abs(leftFlow) * dShoreCoff * (-1.0);
                    }
                    else
                    {
                        leftFlow = Math.Abs(leftFlow) * dShoreCoff;
                    }
                    //label_LeftBankDischarge.Text = leftFlow.ToString("0.00");   //JZH 2012-04-17 cancel

                    //JZH 2012-04-16 计算岸边平均水深
                    double dLeftShoreAvgDepth = 0.0;
                    dLeftShoreAvgDepth = CalculateAvgShoreDepth(left) + fTransducerDepth; //LPJ 2013-6-21

                    //JZH 2012-04-16 计算岸边面积

                    double dLeftShoreWidth = fLeftDis; //LPJ 2013-6-21

                    double dLeftShoreCoff = leftRef; //LPJ 2013-6-21
                    dLeftShoreArea = CalculateShoreArea(dLeftShoreAvgDepth, dLeftShoreWidth, dLeftShoreCoff);

                }
                catch //(System.Exception ex)
                {
                    //MessageBox.Show(ex.Message);
                }

                #endregion

                #region 计算右岸流量
                try
                {
                    CalculateShoreFlowParam param = new CalculateShoreFlowParam();
                    //param.RiverDischarge_A = 0.35;
                    double RightRef = 0.35;
                    try
                    {
                        RightRef = double.Parse(labelRightRef.Text);
                    }
                    catch
                    {
                        RightRef = 0.35;
                    }
                    param.RiverDischarge_A = RightRef;

                    //param.RiverDischargeDraft = 0.0;
                    param.RiverDischargeDraft = fTransducerDepth;
                    //param.RiverDischargeDistance = 1.0;
                    param.RiverDischargeDistance = fRightDis;
                    param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;
                    param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;
                    param.RiverDischargeOrgData = right.ToArray();
                    rightFlow = Calcflow.RiverDischargeCalculate.CalculateShoreFlow(param);

                    //JZH 2012-04-08 添加岸边流速方向角计算，用于判断岸边流量的正负值                
                    dShoreVelDir = Calcflow.RiverDischargeCalculate.CalculateShoreVelocity(param);  //JZH 2012-04-06 获取岸边平均流速的方向
                    if (dCourseMG >= 0 && dCourseMG <= 180)
                    {
                        if (dShoreVelDir - dCourseMG >= 0 && dShoreVelDir - dCourseMG <= 180)
                        {
                            dShoreCoff = -1.0;
                        }
                        else
                        {
                            dShoreCoff = 1.0;
                        }
                    }
                    else
                    {
                        if (dShoreVelDir - dCourseMG <= 0 && dShoreVelDir - dCourseMG >= -180)
                        {
                            dShoreCoff = 1.0;
                        }
                        else
                        {
                            dShoreCoff = -1.0;
                        }
                    }
                    //JZH 2012-02-05 采用简易判定方法，确定左右岸流量正负
                    //if (radioButtonRightToLeft.Checked)
                    if (!bStartLeftEdge)
                    {
                        rightFlow = Math.Abs(rightFlow) * dShoreCoff * (-1.0);
                    }
                    else
                    {
                        rightFlow = Math.Abs(rightFlow) * dShoreCoff;
                    }
                    //label_RightBankDischarge.Text = rightFlow.ToString("0.00");   //JZH 2012-04-17 cancel

                    //JZH 2012-04-16 计算岸边平均水深
                    double dRightShoreAvgDepth = 0.0;
                    dRightShoreAvgDepth = CalculateAvgShoreDepth(right) + fTransducerDepth;  //JZH 2012-04-17 

                    //JZH 2012-04-16 计算岸边面积
                    //label_Area.Text = dLeftShoreAvgDepth.ToString("0.000");
                    //double dRightShoreArea = 0.0;
                    double dRightShoreWidth = fRightDis;
                    double dRightShoreCoff = RightRef;
                    dRightShoreArea = CalculateShoreArea(dRightShoreAvgDepth, dRightShoreWidth, dRightShoreCoff);
                }
                catch //(System.Exception ex)
                {
                    //MessageBox.Show(ex.Message);
                }
                #endregion

                //JZH 2012-04-17 更新导航面板
                float fTotalWidth = Math.Abs(fRiverWidth) + fLeftDis + fRightDis; //LPJ 2013-7-1

                double dTotalArea = 0;
                dTotalArea = Math.Abs(fArea) + dLeftShoreArea + dRightShoreArea;

                double dMeanTemp = 0;    //平均流向
                if (fMeanFlowDir < 0)
                    dMeanTemp = fMeanFlowDir / Math.PI * 180 + 360;
                else
                    dMeanTemp = fMeanFlowDir / Math.PI * 180;
                current_MeanFlowDir = dMeanTemp.ToString("0.00");

                double dMeanFlowAverage = 0; //平均流速
                if (dTotalArea == 0)
                    dMeanFlowAverage = 0;
                else
                    dMeanFlowAverage = Math.Abs(leftFlow + rightFlow + topFlow + measuredFlow + bottomFlow) / dTotalArea;


                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                if (!bEnglish2Metric)
                {
                    //JZH 2012-04-17 更新流量面板
                    current_TotalQ = projectUnit.MeterToFeet(leftFlow + rightFlow + topFlow + measuredFlow + bottomFlow, 3).ToString("0.000");
                    current_TopQ = projectUnit.MeterToFeet(topFlow, 3).ToString("0.00");
                    current_MiddleQ = projectUnit.MeterToFeet(measuredFlow, 3).ToString("0.00");
                    current_BottomQ = projectUnit.MeterToFeet(bottomFlow, 3).ToString("0.00");
                    current_LeftQ = projectUnit.MeterToFeet(leftFlow, 3).ToString("0.00");
                    current_RightQ = projectUnit.MeterToFeet(rightFlow, 3).ToString("0.00");
                    current_RiverWidth = projectUnit.MeterToFeet(Math.Abs(fTotalWidth), 1).ToString("0.00");
                    current_Area = projectUnit.MeterToFeet(dTotalArea, 2).ToString("0.00");
                    current_MeanFLowVel = projectUnit.MeterToFeet(dMeanFlowAverage, 1).ToString("0.00");
                }
                else
                {
                    //JZH 2012-04-17 更新流量面板
                    current_TotalQ = (leftFlow + rightFlow + topFlow + measuredFlow + bottomFlow).ToString("0.000");
                    current_TopQ = topFlow.ToString("0.00");
                    current_MiddleQ = measuredFlow.ToString("0.00");
                    current_BottomQ = bottomFlow.ToString("0.00");
                    current_LeftQ = leftFlow.ToString("0.00");
                    current_RightQ = rightFlow.ToString("0.00");
                    current_RiverWidth = Math.Abs(fTotalWidth).ToString("0.00");
                    current_Area = dTotalArea.ToString("0.00");
                    current_MeanFLowVel = dMeanFlowAverage.ToString("0.00");
                }

                //LV_MeasuredQ_Paint(); //LPJ 2013-5-17
                //this.BeginInvoke(RefreshDishargePanel);  //LPJ 2016-10-27 cancel
                //this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
                //this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18

             
                //JZH 2012-01-12 新流量回放计算　　　 ------------结束
            }
            catch
            {
            }
        }

        #region 采集时流量计算 //LPJ 2016-8-24

        private class DischargeMsg
        {
            public List<ArrayClass> left;
            public List<ArrayClass> right;

            public DischargeMsgChanged DischargeMsg_GPS; //LPJ 2016-8-23
            public DischargeMsgChanged DischargeMsg_BT;  //LPJ 2016-8-23
            public DischargeMsgChanged DischargeMsg_GGA;   //LPJ 2016-8-24
            public DischargeMsgChanged DischargeMsg_NULL;  //LPJ 2016-8-24

            public double leftFlow;
            public double rightFlow;
            public double dLeftShoreArea;
            public double dRightShoreArea;

            public DischargeMsg()
            {
                left = new List<ArrayClass>();
                right = new List<ArrayClass>();

                DischargeMsg_BT.lEastLength = new ArrayList();
                DischargeMsg_BT.lNorthLength = new ArrayList();
                DischargeMsg_BT.lBottomDepth = new ArrayList();

                DischargeMsg_GGA.lEastLength = new ArrayList();
                DischargeMsg_GGA.lNorthLength = new ArrayList();
                DischargeMsg_GGA.lBottomDepth = new ArrayList();

                DischargeMsg_GPS.lEastLength = new ArrayList();
                DischargeMsg_GPS.lNorthLength = new ArrayList();
                DischargeMsg_GPS.lBottomDepth = new ArrayList();

                DischargeMsg_NULL.lEastLength = new ArrayList();
                DischargeMsg_NULL.lNorthLength = new ArrayList();
                DischargeMsg_NULL.lBottomDepth = new ArrayList();

            }
        }

        public struct DischargeMsgChanged //LPJ 2016-8-23
        {
            public double topFlow;
            public double measuredFlow;
            public double bottomFlow;

            public double lastSecond;

            public float fAccEast;//JZH 2012-04-08  底跟踪东向累积量
            public float fAccNorth; //JZH 2012-04-08 底跟踪北向累积量
            public float fAccLength; //JZH 2012-04-08 航迹累积长度
            public bool bGetFirstGoodEnsemble; //JZH 2012-04-08 采集到第一个有效单元
            public int iPrevGoodEnsembleNoOffset;  //JZH 2012-04-08  底跟踪前一个有效单元的偏移
            public int iPrevGoodEnsemblePos;

            public ArrayList lEastLength;   //JZH 2012-04-15
            public ArrayList lNorthLength; //JZH 2012-04-15
            public ArrayList lBottomDepth;  //JZH 2012-04-15

            //JZH 2012-04-17 计算平均流向参数
            public float fAccVx;
            public float fAccVy;

            public float fRiverWidth;
            public float fArea;

        }
        DischargeMsg dischargeMsg = new DischargeMsg();  //LPJ 2016-8-24 流量计算累加的变量
        

        //计算采集模式下的流量，船速参考所有
        //SM>
        //private void CalDischarge_Survey(ArrayClass Arr, int ensembleNum, EnsemblesInfo ensembles, float cellsize, ref DischargeMsg dischargeMsg)
        //SM<
        private void CalDischarge_Survey(ArrayClass Arr, int ensembleNum, EnsemblesInfo ensembles, ref DischargeMsg dischargeMsg)
        {
            float fTransducerDepth, fLeftDis, fRightDis;
            //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1
            if (!bEnglish2Metric)
            {
                try
                {
                    fTransducerDepth = (float)(projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1));
                }
                catch
                {
                    fTransducerDepth = (float)(projectUnit.FeetToMeter(0.1, 1));
                }
                try
                {
                    fLeftDis = (float)(projectUnit.FeetToMeter(double.Parse(labelLeftDis.Text), 1));
                    fRightDis = (float)(projectUnit.FeetToMeter(double.Parse(labelRightDis.Text), 1));
                }
                catch
                {
                    fLeftDis = 0;
                    fRightDis = 0;
                }
            }
            else
            {
                try
                {
                    fTransducerDepth = float.Parse(labelTransducerDepth.Text);
                }
                catch
                {
                    fTransducerDepth = 0.1f;
                }
                try
                {
                    fLeftDis = float.Parse(labelLeftDis.Text);
                    fRightDis = float.Parse(labelRightDis.Text);
                }
                catch
                {
                    fLeftDis = 0;
                    fRightDis = 0;
                }
            }

            bool bValid = false; //LPJ 2017-8-9 数据采集时，左右岸计数与回放一致
            ///SM>
            //bValid = CalMeasuredDischarge(0, Arr, ensembleNum - 1, ensembles, cellsize, fTransducerDepth, ref dischargeMsg.DischargeMsg_BT);  //LPJ 2016-8-25 序列号减一
            //CalMeasuredDischarge(1, Arr, ensembleNum - 1, ensembles, cellsize, fTransducerDepth, ref dischargeMsg.DischargeMsg_GPS); //LPJ 2016-8-25 序列号减一
            //CalMeasuredDischarge(2, Arr, ensembleNum - 1, ensembles, cellsize, fTransducerDepth, ref dischargeMsg.DischargeMsg_NULL);  //LPJ 2016-8-25 序列号减一
            //CalMeasuredDischarge(3, Arr, ensembleNum - 1, ensembles, cellsize, fTransducerDepth, ref dischargeMsg.DischargeMsg_GGA);  //LPJ 2016-8-25 序列号减一
            bValid = CalMeasuredDischarge(0, Arr, ensembleNum - 1, ensembles, fTransducerDepth, ref dischargeMsg.DischargeMsg_BT);  //LPJ 2016-8-25 序列号减一

            CalMeasuredDischarge(1, Arr, ensembleNum - 1, ensembles, fTransducerDepth, ref dischargeMsg.DischargeMsg_GPS); //LPJ 2016-8-25 序列号减一
            CalMeasuredDischarge(2, Arr, ensembleNum - 1, ensembles, fTransducerDepth, ref dischargeMsg.DischargeMsg_NULL);  //LPJ 2016-8-25 序列号减一
            CalMeasuredDischarge(3, Arr, ensembleNum - 1, ensembles, fTransducerDepth, ref dischargeMsg.DischargeMsg_GGA);  //LPJ 2016-8-25 序列号减一
            //SM<

            float fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.DischargeMsg_BT.fAccEast, 2) + System.Math.Pow(dischargeMsg.DischargeMsg_BT.fAccNorth, 2));
            double dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_BT.fAccEast, dischargeMsg.DischargeMsg_BT.fAccNorth);

            //LPJ 2016-12-19 
            if (Resource1.String232 == labelVesselRef.Text)
            {
                fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.DischargeMsg_BT.fAccEast, 2) + System.Math.Pow(dischargeMsg.DischargeMsg_BT.fAccNorth, 2));
                dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_BT.fAccEast, dischargeMsg.DischargeMsg_BT.fAccNorth);
            }
            else if ("GPS VTG" == labelVesselRef.Text)
            {
                fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.DischargeMsg_GPS.fAccEast, 2) + System.Math.Pow(dischargeMsg.DischargeMsg_GPS.fAccNorth, 2));
                dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_GPS.fAccEast, dischargeMsg.DischargeMsg_GPS.fAccNorth);
            }
            else if ("GPS GGA" == labelVesselRef.Text)
            {
                fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.DischargeMsg_GGA.fAccEast, 2) + System.Math.Pow(dischargeMsg.DischargeMsg_GGA.fAccNorth, 2));
                dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_GGA.fAccEast, dischargeMsg.DischargeMsg_GGA.fAccNorth);
            }
            else if (Resource1.String233 == labelVesselRef.Text)
            {
                fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.DischargeMsg_NULL.fAccEast, 2) + System.Math.Pow(dischargeMsg.DischargeMsg_NULL.fAccNorth, 2));
                dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_NULL.fAccEast, dischargeMsg.DischargeMsg_NULL.fAccNorth);
            }

            //LPJ 2016-12-19 左右岸流量方向不对
            if (dCourseMG < 0)
                dCourseMG = dCourseMG / Math.PI * 180 + 360;
            else
                dCourseMG = dCourseMG / Math.PI * 180;
          
            try //LPJ 2016-8-25
            {
                if (bValid) //LPJ 2017-8-9
                {
                    AddShoreData(Arr, ref dischargeMsg);
                    CalShoreDischarge(ref dischargeMsg, fTransducerDepth, fLeftDis, fRightDis, dCourseMG);
                }
            }
            catch
            { }

            #region 更新导航面板
            float fRiverWidth = 0;
            float fArea = 0;
            double fMeanFlowDir = 0;
            double topFlow = 0;
            double measuredFlow = 0;
            double bottomFlow = 0;
            float fAccLength = 0;

            if (Resource1.String232 == labelVesselRef.Text)
            {
                fRiverWidth = dischargeMsg.DischargeMsg_BT.fRiverWidth;
                fArea = dischargeMsg.DischargeMsg_BT.fArea;
                fMeanFlowDir = System.Math.Atan2(dischargeMsg.DischargeMsg_BT.fAccVx, dischargeMsg.DischargeMsg_BT.fAccVy);
                topFlow = dischargeMsg.DischargeMsg_BT.topFlow;
                measuredFlow = dischargeMsg.DischargeMsg_BT.measuredFlow;
                bottomFlow = dischargeMsg.DischargeMsg_BT.bottomFlow;
                fAccLength = dischargeMsg.DischargeMsg_BT.fAccLength;

                //dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_BT.fAccEast, dischargeMsg.DischargeMsg_BT.fAccNorth);  //LPJ 2016-12-19 cancel

            }
            else if ("GPS VTG" == labelVesselRef.Text)
            {
                fRiverWidth = dischargeMsg.DischargeMsg_GPS.fRiverWidth;
                fArea = dischargeMsg.DischargeMsg_GPS.fArea;
                fMeanFlowDir = System.Math.Atan2(dischargeMsg.DischargeMsg_GPS.fAccVx, dischargeMsg.DischargeMsg_GPS.fAccVy);
                topFlow = dischargeMsg.DischargeMsg_GPS.topFlow;
                measuredFlow = dischargeMsg.DischargeMsg_GPS.measuredFlow;
                bottomFlow = dischargeMsg.DischargeMsg_GPS.bottomFlow;
                fAccLength = dischargeMsg.DischargeMsg_GPS.fAccLength;

                //dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_GPS.fAccEast, dischargeMsg.DischargeMsg_GPS.fAccNorth); //LPJ 2016-12-19 cancel

            }
            else if ("GPS GGA" == labelVesselRef.Text)
            {
                fRiverWidth = dischargeMsg.DischargeMsg_GGA.fRiverWidth;
                fArea = dischargeMsg.DischargeMsg_GGA.fArea;
                fMeanFlowDir = System.Math.Atan2(dischargeMsg.DischargeMsg_GGA.fAccVx, dischargeMsg.DischargeMsg_GGA.fAccVy);
                topFlow = dischargeMsg.DischargeMsg_GGA.topFlow;
                measuredFlow = dischargeMsg.DischargeMsg_GGA.measuredFlow;
                bottomFlow = dischargeMsg.DischargeMsg_GGA.bottomFlow;
                fAccLength = dischargeMsg.DischargeMsg_GGA.fAccLength;

                //dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_GGA.fAccEast, dischargeMsg.DischargeMsg_GGA.fAccNorth); //LPJ 2016-12-19 cancel

            }
            else if (Resource1.String233 == labelVesselRef.Text)
            {
                fRiverWidth = dischargeMsg.DischargeMsg_NULL.fRiverWidth;
                fArea = dischargeMsg.DischargeMsg_NULL.fArea;
                fMeanFlowDir = System.Math.Atan2(dischargeMsg.DischargeMsg_NULL.fAccVx, dischargeMsg.DischargeMsg_NULL.fAccVy);
                topFlow = dischargeMsg.DischargeMsg_NULL.topFlow;
                measuredFlow = dischargeMsg.DischargeMsg_NULL.measuredFlow;
                bottomFlow = dischargeMsg.DischargeMsg_NULL.bottomFlow;
                fAccLength = dischargeMsg.DischargeMsg_NULL.fAccLength;

                //dCourseMG = System.Math.Atan2(dischargeMsg.DischargeMsg_NULL.fAccEast, dischargeMsg.DischargeMsg_NULL.fAccNorth); //LPJ 2016-12-19 cancel

            }

            //if (dCourseMG < 0)
            //    dCourseMG = dCourseMG / Math.PI * 180 + 360;
            //else
            //    dCourseMG = dCourseMG / Math.PI * 180;
            current_CourseMG = dCourseMG.ToString("0.0");

            float fTotalWidth = Math.Abs(fRiverWidth) + fLeftDis + fRightDis; //LPJ 2013-7-1

            double dTotalArea = 0;
            dTotalArea = Math.Abs(fArea) + dischargeMsg.dLeftShoreArea + dischargeMsg.dRightShoreArea;

            double dMeanTemp = 0;    //平均流向
            if (fMeanFlowDir < 0)
                dMeanTemp = fMeanFlowDir / Math.PI * 180 + 360;
            else
                dMeanTemp = fMeanFlowDir / Math.PI * 180;
            current_MeanFlowDir = dMeanTemp.ToString("0.00");

            double dMeanFlowAverage = 0; //平均流速
            if (dTotalArea == 0)
                dMeanFlowAverage = 0;
            else
                dMeanFlowAverage = Math.Abs(dischargeMsg.leftFlow + dischargeMsg.rightFlow + topFlow + measuredFlow + bottomFlow) / dTotalArea;

            //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
            if (!bEnglish2Metric)
            {
                current_Length = projectUnit.MeterToFeet(fAccLength, 1).ToString("0.00");
                current_DistanceMG = projectUnit.MeterToFeet(fAccMG, 1).ToString("0.00");
                //JZH 2012-04-17 更新流量面板
                current_TotalQ = projectUnit.MeterToFeet(dischargeMsg.leftFlow + dischargeMsg.rightFlow + topFlow + measuredFlow + bottomFlow, 3).ToString("0.000");
                current_TopQ = projectUnit.MeterToFeet(topFlow, 3).ToString("0.00");
                current_MiddleQ = projectUnit.MeterToFeet(measuredFlow, 3).ToString("0.00");
                current_BottomQ = projectUnit.MeterToFeet(bottomFlow, 3).ToString("0.00");
                current_LeftQ = projectUnit.MeterToFeet(dischargeMsg.leftFlow, 3).ToString("0.00");
                current_RightQ = projectUnit.MeterToFeet(dischargeMsg.rightFlow, 3).ToString("0.00");
                current_RiverWidth = projectUnit.MeterToFeet(Math.Abs(fTotalWidth), 1).ToString("0.00");
                current_Area = projectUnit.MeterToFeet(dTotalArea, 2).ToString("0.00");
                current_MeanFLowVel = projectUnit.MeterToFeet(dMeanFlowAverage, 1).ToString("0.00");
            }
            else
            {
                current_Length = fAccLength.ToString("0.00");
                current_DistanceMG = fAccMG.ToString("0.00");
                //JZH 2012-04-17 更新流量面板
                current_TotalQ = (dischargeMsg.leftFlow + dischargeMsg.rightFlow + topFlow + measuredFlow + bottomFlow).ToString("0.000");
                current_TopQ = topFlow.ToString("0.00");
                current_MiddleQ = measuredFlow.ToString("0.00");
                current_BottomQ = bottomFlow.ToString("0.00");
                current_LeftQ = dischargeMsg.leftFlow.ToString("0.00");
                current_RightQ = dischargeMsg.rightFlow.ToString("0.00");
                current_RiverWidth = Math.Abs(fTotalWidth).ToString("0.00");
                current_Area = dTotalArea.ToString("0.00");
                current_MeanFLowVel = dMeanFlowAverage.ToString("0.00");
            }

            #endregion

        }

        //计算岸边流量
        private void CalShoreDischarge(ref DischargeMsg dischargeMsg, float fTransducerDepth, float fLeftDis, float fRightDis, double dCourseMG) //LPJ 2016-8-23
        {
            double dShoreVelDir = 1.0; //JZH 2012-04-06 岸边流速方向 用来判断岸边流量正负
            double dShoreCoff = 0;  //JZH 2012-04-06 岸边流量系数 用来判断岸边流量正负

            #region 计算左岸流量
            try
            {
                CalculateShoreFlowParam param = new CalculateShoreFlowParam();
                //param.RiverDischarge_A = 0.35;     //岸边系数
                double leftRef = 0.35;

                try
                {
                    leftRef = double.Parse(labelLeftRef.Text);
                }
                catch
                {
                    leftRef = 0.35;
                }
                param.RiverDischarge_A = leftRef;
                //param.RiverDischargeDraft = 0.0;  //ADCP吃水
                param.RiverDischargeDraft = fTransducerDepth;
                //param.RiverDischargeDistance = 1.0; //岸边距离
                param.RiverDischargeDistance = fLeftDis;
                param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;        //ADCP参数
                param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;  //判断GOODBIn条件
                param.RiverDischargeOrgData = dischargeMsg.left.ToArray();
                dischargeMsg.leftFlow = Calcflow.RiverDischargeCalculate.CalculateShoreFlow(param);

                dLeftShorePings = dischargeMsg.left.Count(); //LPJ 2016-12-19 左岸呯数

                //JZH 2012-04-08 添加岸边流速方向角计算，用于判断岸边流量的正负值                
                dShoreVelDir = Calcflow.RiverDischargeCalculate.CalculateShoreVelocity(param);  //JZH 2012-04-06 获取岸边平均流速的方向
                if (dCourseMG >= 0 && dCourseMG <= 180)
                {
                    if (dShoreVelDir - dCourseMG >= 0 && dShoreVelDir - dCourseMG <= 180)
                    {
                        dShoreCoff = -1.0;
                    }
                    else
                    {
                        dShoreCoff = 1.0;
                    }
                }
                else
                {
                    if (dShoreVelDir - dCourseMG <= 0 && dShoreVelDir - dCourseMG >= -180)
                    {
                        dShoreCoff = 1.0;
                    }
                    else
                    {
                        dShoreCoff = -1.0;
                    }
                }

                //vel=Calcflow.RiverDischargeCalculate
                //JZH 2012-02-05 采用简易判定方法，确定左右岸流量正负
                //   if (radioButtonRightToLeft.Checked)
                if (!bStartLeftEdge) //LPJ 2013-6-21
                {
                    dischargeMsg.leftFlow = Math.Abs(dischargeMsg.leftFlow) * dShoreCoff * (-1.0);
                }
                else
                {
                    dischargeMsg.leftFlow = Math.Abs(dischargeMsg.leftFlow) * dShoreCoff;
                }
                //label_LeftBankDischarge.Text = leftFlow.ToString("0.00");   //JZH 2012-04-17 cancel

                //JZH 2012-04-16 计算岸边平均水深
                double dLeftShoreAvgDepth = 0.0;
                dLeftShoreAvgDepth = CalculateAvgShoreDepth(dischargeMsg.left) + fTransducerDepth; //LPJ 2013-6-21

                //JZH 2012-04-16 计算岸边面积

                double dLeftShoreWidth = fLeftDis; //LPJ 2013-6-21

                double dLeftShoreCoff = leftRef; //LPJ 2013-6-21
                dischargeMsg.dLeftShoreArea = CalculateShoreArea(dLeftShoreAvgDepth, dLeftShoreWidth, dLeftShoreCoff);

            }
            catch //(System.Exception ex)
            {
                //MessageBox.Show(ex.Message);
            }

            #endregion

            #region 计算右岸流量
            try
            {
                CalculateShoreFlowParam param = new CalculateShoreFlowParam();
                //param.RiverDischarge_A = 0.35;
                double RightRef = 0.35;
                try
                {
                    RightRef = double.Parse(labelRightRef.Text);
                }
                catch
                {
                    RightRef = 0.35;
                }
                param.RiverDischarge_A = RightRef;

                //param.RiverDischargeDraft = 0.0;
                param.RiverDischargeDraft = fTransducerDepth;
                //param.RiverDischargeDistance = 1.0;
                param.RiverDischargeDistance = fRightDis;
                param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;
                param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;
                param.RiverDischargeOrgData = dischargeMsg.right.ToArray();
               
                dischargeMsg.rightFlow = Calcflow.RiverDischargeCalculate.CalculateShoreFlow(param);

                dRightShorePings = dischargeMsg.right.Count(); //LPJ 2016-12-19 右岸呯数

                //JZH 2012-04-08 添加岸边流速方向角计算，用于判断岸边流量的正负值                
                dShoreVelDir = Calcflow.RiverDischargeCalculate.CalculateShoreVelocity(param);  //JZH 2012-04-06 获取岸边平均流速的方向
                if (dCourseMG >= 0 && dCourseMG <= 180)
                {
                    if (dShoreVelDir - dCourseMG >= 0 && dShoreVelDir - dCourseMG <= 180)
                    {
                        dShoreCoff = -1.0;
                    }
                    else
                    {
                        dShoreCoff = 1.0;
                    }
                }
                else
                {
                    if (dShoreVelDir - dCourseMG <= 0 && dShoreVelDir - dCourseMG >= -180)
                    {
                        dShoreCoff = 1.0;
                    }
                    else
                    {
                        dShoreCoff = -1.0;
                    }
                }
                //JZH 2012-02-05 采用简易判定方法，确定左右岸流量正负
                //if (radioButtonRightToLeft.Checked)
                if (!bStartLeftEdge)
                {
                    dischargeMsg.rightFlow = Math.Abs(dischargeMsg.rightFlow) * dShoreCoff * (-1.0);
                }
                else
                {
                    dischargeMsg.rightFlow = Math.Abs(dischargeMsg.rightFlow) * dShoreCoff;
                }
                //label_RightBankDischarge.Text = rightFlow.ToString("0.00");   //JZH 2012-04-17 cancel

                //JZH 2012-04-16 计算岸边平均水深
                double dRightShoreAvgDepth = 0.0;
                dRightShoreAvgDepth = CalculateAvgShoreDepth(dischargeMsg.right) + fTransducerDepth;  //JZH 2012-04-17 

                //JZH 2012-04-16 计算岸边面积
                //label_Area.Text = dLeftShoreAvgDepth.ToString("0.000");
                //double dRightShoreArea = 0.0;
                double dRightShoreWidth = fRightDis;
                double dRightShoreCoff = RightRef;
                dischargeMsg.dRightShoreArea = CalculateShoreArea(dRightShoreAvgDepth, dRightShoreWidth, dRightShoreCoff);
            }
            catch //(System.Exception ex)
            {
                //MessageBox.Show(ex.Message);
            }

            #endregion

        }

        //计算船速更改后的实测流量、导航信息等
        //SM>
        //private bool CalMeasuredDischarge(int iVesselRef, ArrayClass Arr, int ensembleNum, EnsemblesInfo ensembles, float cellsize, float fTransducerDepth, ref DischargeMsgChanged dischargeMsg) //LPJ 2016-8-23
        private bool CalMeasuredDischarge(int iVesselRef, ArrayClass Arr, int ensembleNum, EnsemblesInfo ensembles, float fTransducerDepth, ref DischargeMsgChanged dischargeMsg) //LPJ 2016-8-23
        //SM<
        {
            //float fRiverWidth = 0;
            //float fArea = 0;
            //double dCourseMG = 0;//JZH 2012-04-08 直线方向角
            //float fAccMG = 0;   //JZH 2012-04-08 直线距离

            bool bValid = false; //LPJ 2017-8-9 判断采集的数据流量是否有效，如果无效，则不计入左右岸岸边数中，如果有效，则计入
            try
            {

                float fAveDepth = 0;
                double fMeanFlowDir = 0;

                double fPowerCurveCoeff;
                try
                {
                    fPowerCurveCoeff = double.Parse(labelPowerCurveCoeff.Text); //LPJ 2014-8-28
                }
                catch
                {
                    fPowerCurveCoeff = 0.1667;
                }

                #region 计算导航信息
                {
                    if (ensembleNum == 0)
                    {
                        Velocity BoatVelocity = new Velocity(); //LPJ 2013-7-31
                        if (0 == iVesselRef)
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatVelocity[0]);  //LPJ 2013-7-31
                            }
                            catch
                            {
                                return false;
                            }
                        }

                        else if (1 == iVesselRef)  //LPJ 2016-7-11
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatV_GPS[0]);  //LPJ 2013-7-31
                            }
                            catch
                            {
                                return false;
                            }
                        }
                        else if (2 == iVesselRef)
                        {
                            BoatVelocity.VX = 0;
                            BoatVelocity.VY = 0;
                            BoatVelocity.VZ = 0;
                        }
                        else if (3 == iVesselRef)  //LPJ 2013-7-31
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatV_GPGGA[0]);  //LPJ 2013-7-31
                            }
                            catch
                            { return false; }
                        }

                        if (Math.Abs(BoatVelocity.VX) > 20 ||Math.Abs( BoatVelocity.VY) > 20)
                        //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                        {
                            //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                            dischargeMsg.bGetFirstGoodEnsemble = false;
                        }
                        else  //JZH 2012-04-09 初始化流量计算参数
                        {
                            dischargeMsg.bGetFirstGoodEnsemble = true;
                            dischargeMsg.lastSecond = Arr.A_FirstPingSeconds;
                            dischargeMsg.iPrevGoodEnsemblePos = 0;
                        }
                    }
                    else
                    {
                        //LPJ 2013-9-13 添加船速参考GPS选项，并添加headingOffset修正Discharge
                        Velocity BoatVelocity = new Velocity(); //LPJ 2013-7-31
                        Velocity PrecBoatVelocity = new Velocity();

                        if (1 == iVesselRef)  //LPJ 2016-7-11
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatV_GPS[ensembleNum]);  //LPJ 2013-7-31
                                PrecBoatVelocity = (Velocity)(ensembles.BoatV_GPS[dischargeMsg.iPrevGoodEnsemblePos]);
                            }
                            catch
                            {
                                return false;
                            }
                        }
                        else if (2 == iVesselRef)
                        {
                            BoatVelocity.VX = 0;
                            BoatVelocity.VY = 0;
                            PrecBoatVelocity.VX = 0;
                            PrecBoatVelocity.VY = 0;
                        }
                        else if (3 == iVesselRef)  //LPJ 2013-7-31  //LPJ 2016-8-25
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatV_GPGGA[ensembleNum]);  //LPJ 2013-7-31
                                PrecBoatVelocity = (Velocity)(ensembles.BoatV_GPGGA[dischargeMsg.iPrevGoodEnsemblePos]);
                            }
                            catch
                            {
                                return false;   //LPJ 2016-8-25
                            }
                        }
                        else
                        {
                            try
                            {
                                BoatVelocity = (Velocity)(ensembles.BoatVelocity[ensembleNum]);  //LPJ 2013-7-31
                                PrecBoatVelocity = (Velocity)(ensembles.BoatVelocity[dischargeMsg.iPrevGoodEnsemblePos]);
                            }
                            catch
                            {
                                return false;
                            }
                        }

                        if (Math.Abs(BoatVelocity.VX )< 20 && Math.Abs(BoatVelocity.VY) < 20)
                        {
                            if (dischargeMsg.bGetFirstGoodEnsemble)
                            {
                                float LEast = (1.0f) * 0.5f * (float)(PrecBoatVelocity.VX + BoatVelocity.VX) * (float)(Arr.A_FirstPingSeconds - dischargeMsg.lastSecond); //LPJ 2013-9-13
                                float LNorth = (1.0f) * 0.5f * (float)(PrecBoatVelocity.VY + BoatVelocity.VY) * (float)(Arr.A_FirstPingSeconds - dischargeMsg.lastSecond);  //LPJ 2013-9-13

                                dischargeMsg.fAccEast += LEast;
                                dischargeMsg.fAccNorth += LNorth;
                                dischargeMsg.fAccLength += (float)System.Math.Sqrt(System.Math.Pow(LEast, 2) + System.Math.Pow(LNorth, 2));
                                //fAccMG = (float)System.Math.Sqrt(System.Math.Pow(dischargeMsg.fAccEast, 2) + System.Math.Pow(dischargeMsg.fAccNorth, 2));
                                //dCourseMG = System.Math.Atan2(dischargeMsg.fAccEast, dischargeMsg.fAccNorth);

                                dischargeMsg.iPrevGoodEnsembleNoOffset = 0;
                                dischargeMsg.iPrevGoodEnsemblePos = ensembleNum;

                                //JZH 2012-04-17 计算平均流向
                                float fVx = 0;
                                float fVy = 0;

                                float cellSize = Arr.A_CellSize; //LPJ 2016-8-22
                                CalculateAverageWaterSpeed(ensembleNum, ref fVx, ref fVy, ref fAveDepth);

                                //LPJ 2013-6-22 将计算船速、水流速放在这里 -start
                                float fWaterSpeed = (float)System.Math.Sqrt((System.Math.Pow(fVx, 2) + System.Math.Pow(fVy, 2)));
                                double fWaterDir = 0;
                                try
                                {
                                    fWaterDir = (double)(ensembles.WaterDir[ensembleNum]);
                                }
                                catch
                                {
                                }
                                //discharge.waterDirection = fWaterDir;

                                double fBoatSpeed = 0;
                                fBoatSpeed = (double)(ensembles.BoatSpeed[ensembleNum]);

                                float fBoatVelX = 0;
                                float fBoatVelY = 0;
                                fBoatVelX = ((Velocity)ensembles.BoatVelocity[ensembleNum]).VX;
                                fBoatVelY = ((Velocity)ensembles.BoatVelocity[ensembleNum]).VY;
                                if (fBoatVelX <= 20 && fBoatVelY <= 20)
                                {
                                    double fBoatDir = (double)(ensembles.BoatDir[ensembleNum]);
                                }
                                else
                                {

                                }

                                //LPJ 2013-6-22 将计算船速、水流速放在这里 -end

                                dischargeMsg.fAccVx += fVx;
                                dischargeMsg.fAccVy += fVy;

                                fMeanFlowDir = System.Math.Atan2(dischargeMsg.fAccVx, dischargeMsg.fAccVy);

                                double dProjectionDir = 0; //投影角度
                                if (!bStartLeftEdge)
                                    dProjectionDir = fMeanFlowDir - Math.PI / 2.0;
                                else
                                    dProjectionDir = fMeanFlowDir + Math.PI / 2.0;

                                //JZH 2012-04-15 计算投影长度和面积
                                dischargeMsg.lEastLength.Add(LEast);
                                dischargeMsg.lNorthLength.Add(LNorth);
                                dischargeMsg.lBottomDepth.Add(ensembles.bottomDepth[ensembleNum]);

                                dischargeMsg.fRiverWidth = 0;
                                dischargeMsg.fArea = 0;
                                for (int k = 0; k < dischargeMsg.lEastLength.Count; k++)
                                {
                                    dischargeMsg.fArea += ((float)dischargeMsg.lEastLength[k] * (float)Math.Sin(dProjectionDir) + (float)dischargeMsg.lNorthLength[k] * (float)Math.Cos(dProjectionDir)) * ((float)dischargeMsg.lBottomDepth[k] + fTransducerDepth);
                                    dischargeMsg.fRiverWidth += (float)dischargeMsg.lEastLength[k] * (float)Math.Sin(dProjectionDir) + (float)dischargeMsg.lNorthLength[k] * (float)Math.Cos(dProjectionDir);
                                }

                                //JZH 2012-04-09 计算中部流量
                                #region 中部流量
                                {
                                    CalculateEnsembleFlowParam param = new CalculateEnsembleFlowParam();
                                    param.RiverDischarge_dTime = Arr.A_FirstPingSeconds - dischargeMsg.lastSecond;

                                    if (labelTopEstimate.Text == "幂函数") //LPJ 2013-6-22
                                        param.RiverDischargeTopMode = TopFlowMode.PowerFunction;
                                    else if (labelTopEstimate.Text == "常数")
                                        param.RiverDischargeTopMode = TopFlowMode.Constants;
                                    else
                                        param.RiverDischargeTopMode = TopFlowMode.Slope;

                                    if (labelBottomEstimate.Text == "幂函数")
                                        param.RiverDischargeBottomMode = BottomFlowMode.PowerFunction;
                                    else
                                        param.RiverDischargeBottomMode = BottomFlowMode.Constants;

                                    param.RiverDischargeDraft = fTransducerDepth;   //ADCP吃水

                                    param.RiverDischargeExponent = fPowerCurveCoeff;

                                    param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;
                                    param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;
                                    param.RiverDischargeOrgData = Arr;

                                    float ve = 0, vn = 0; //LPJ 2013-7-31 
                                    double dHeadingOffset = 0; //LPJ 2013-9-13
                                    if (0 == iVesselRef)
                                    {
                                        ve = Arr.B_Earth[0]; //LPJ 2013-7-31
                                        vn = Arr.B_Earth[1]; //LPJ 2013-7-31
                                    }
                                    else if (1 == iVesselRef) //LPJ 2016-8-23
                                    {
                                        Velocity boatV_GPS = new Velocity();
                                        boatV_GPS = (Velocity)(EnsemblesInfoToStore.BoatV_GPS[RTIdata.Count - 1]);

                                        ve = boatV_GPS.VX;
                                        vn = boatV_GPS.VY;

                                        //dHeadingOffset = fHeadingOffset / 180 * Math.PI;  //LPJ 2017-5-15
                                    }
                                    else if (2 == iVesselRef)
                                    {
                                        ve = 0;
                                        vn = 0;
                                    }
                                    else
                                    {
                                        Velocity boatV_GPS = new Velocity();
                                        boatV_GPS = (Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[RTIdata.Count - 1]);

                                        ve = boatV_GPS.VX;
                                        vn = boatV_GPS.VY;
                                        //dHeadingOffset = fHeadingOffset / 180 * Math.PI;  //LPJ 2017-5-15
                                    }

                                    EnsembleFlowInfo flow = Calcflow.RiverDischargeCalculate.CalculateEnsembleFlow(param, ve, vn, dHeadingOffset); //LPJ  2013-7-31

                                    //EnsembleFlowInfo flow = Calcflow.RiverDischargeCalculate.CalculateEnsembleFlow(param);
                                    if (flow.Valid)
                                    {//有效的数据
                                        //JZH 2012-02-05  根据左右岸，判定流量正负
                                        //if (radioButtonLeftToRight.Checked)
                                        if (bStartLeftEdge)
                                        {
                                            dischargeMsg.topFlow += flow.TopFlow;
                                            dischargeMsg.measuredFlow += flow.MeasuredFlow;
                                            dischargeMsg.bottomFlow += flow.BottomFlow;
                                        }
                                        else
                                        {
                                            dischargeMsg.topFlow += flow.TopFlow * (-1.0);
                                            dischargeMsg.measuredFlow += flow.MeasuredFlow * (-1.0);
                                            dischargeMsg.bottomFlow += flow.BottomFlow * (-1.0);
                                        }
                                        dischargeMsg.lastSecond = Arr.A_FirstPingSeconds;
                                        //添加判断左右岸

                                        //if (left.Count < avgNum)

                                        //lastSecond = RTIdata[i].A_FirstPingSeconds;
                                    }
                                    dischargeMsg.lastSecond = Arr.A_FirstPingSeconds;
                                    //label_TopDiacharge.Text = topFlow.ToString("0.000");   //JZH 2012-04-17 Cancel
                                    //label_MiddleDischarge.Text = measuredFlow.ToString("0.000");
                                    //label_BottomeDischarge.Text = bottomFlow.ToString("0.000");

                                    bValid = flow.Valid; //LPJ 2017-8-9 
                                }
                                #endregion

                            }
                            else
                            {
                                //FirstGoodEnsembleNoOffset++;
                                dischargeMsg.bGetFirstGoodEnsemble = true;
                                dischargeMsg.iPrevGoodEnsemblePos = ensembleNum;
                                //JZH 2012-04-09 
                                dischargeMsg.lastSecond = Arr.A_FirstPingSeconds;
                            }
                        }
                        else
                        {
                            dischargeMsg.iPrevGoodEnsembleNoOffset++;

                        }
                    }
                }
                #endregion
            }
            catch
            {
            }
            return bValid;  //LPJ 2017-8-9
        }

        //添加岸边流量计算的原始数据
        private void AddShoreData(ArrayClass Arr, ref DischargeMsg dischargeMsg)
        {
            if (bStartEdge)   //LPJ2016-12-19 正在测量起始岸
            {
                if (bStartLeftEdge)  //起始岸为左岸
                {
                    dischargeMsg.left.Add(Arr);
                }
                else  //起始岸为右岸
                {
                    dischargeMsg.right.Add(Arr);
                }
            }
            else if (bEndEdge) //正在测量终止岸
            {
                if (bStartLeftEdge) //终止岸为右岸
                {
                    dischargeMsg.right.Add(Arr);
                }
                else
                {
                    dischargeMsg.left.Add(Arr);
                }
            }
        }

        #endregion

        #endregion

        #region  LPJ 2016-8-24 更新船速参考选项
        public void OnChangedVesselRef(int iNumber)
        {
            if (0 == iNumber)
            {
                labelVesselRef.Text = Resource1.String232;
            }
            else if (1 == iNumber)
            {
                labelVesselRef.Text = "GPS VTG";
            }
            else if (3 == iNumber)
            {
                labelVesselRef.Text = "GPS GGA";
            }
            else
            {
                labelVesselRef.Text = Resource1.String233;
            }

            iVesselSpeedRef = iNumber;//LPJ 2016-8-18 船速参考
           
            if (playBackMode)
                this.BeginInvoke(RefreshSummaryList); //LPJ 2013-11-21
            this.BeginInvoke(CalDischargeRefresh); //LPJ 2013-11-21
            this.BeginInvoke(RefreshDishargePanel); //LPJ 2013-11-21
            this.BeginInvoke(RefreshNavigation); //LPJ 2013-11-21
            this.BeginInvoke(RefreshOthers); //LPJ 2013-11-21

            this.BeginInvoke(MainPanel_Refresh);
            this.BeginInvoke(TrackPanel_Refresh); 
            this.BeginInvoke(PaintRefreshEvent);

          
        }
        #endregion

        //JZH 2012-04-17 计算岸边面积
        private double CalculateShoreArea(double dDepth, double dShoreWidth, double coff)
        {
            if (coff >= 0.91)
                return dDepth * dShoreWidth;
            else
                return dDepth * dShoreWidth * ((coff - 0.35) / (0.91 - 0.35) * 0.5 + 0.5);
        }

        //JZH 2012-04-16 计算岸边平均深度
        private double CalculateAvgShoreDepth(List<ArrayClass> array)
        {
            List<double> all_range = new List<double>();
            for (int i = 0; i < array.Count; i++)
            {
                List<double> ensemble_range = new List<double>();
                for (int j = 0; j < 4; j++)
                {
                    if (array[i].B_Range[j] != 0.0)
                    {
                        ensemble_range.Add(array[i].B_Range[j]);
                    }
                }
                if (ensemble_range.Count == 0)
                    continue;
                double ensemble_avg = 0.0;
                foreach (double _range in ensemble_range)
                {
                    ensemble_avg += _range;
                }
                ensemble_avg /= ensemble_range.Count;

                all_range.Add(ensemble_avg);
            }
            double avg_range = 0.0;
            foreach (double e_range in all_range)
            {
                avg_range += e_range;
            }
            avg_range /= all_range.Count;
            return avg_range;
        }

        
        /*
        private void decodeBinFile(ArrayList a)
        {
            byte[] Lng = new byte[4];
            for (int i = 0; i < 4; i++)
            {
                Lng[i] = (byte)a[24 + i];
            }
            payloadLen = BitConverter.ToInt32(Lng, 0);
            byte[] packet = new byte[payloadLen];
            a.CopyTo(32, packet, 0, payloadLen);
            ArrayClass Arr = new ArrayClass();
            DecodeEnsemble(packet, Arr, payloadLen);

            arrAmplitude = Arr.Amplitude;
            arrCorrelation = Arr.Correlation;
            pictureBox_W_A.Refresh();
            pictureBox_W_C.Refresh();
            //WriteToDataPage(Arr);
            this.BeginInvoke(WriteToDataPageEvent, Arr); //LPJ 2014-3-11
        }
        */
        /*
        private void GetOtherMembers()
        {
            float time;
            if (restoreNum == EnsemblesInfoToStore.t.Count)
            {
                EnsemblesInfoToStore.t.RemoveAt(0);
            }
            if (2 == EnsemblesInfoToStore.RecivedTime.Count)//第一个样本的时间间隔无法确定，尽是认为与第二个样本的时间差相同
            {
                time = (float)EnsemblesInfoToStore.RecivedTime[1] - (float)EnsemblesInfoToStore.RecivedTime[0];//时间差的绝对值
                EnsemblesInfoToStore.t.Add(time);
                EnsemblesInfoToStore.t.Add(time);
            }
            else if (EnsemblesInfoToStore.RecivedTime.Count > 2)
            {
                time = (float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 1] - (float)EnsemblesInfoToStore.RecivedTime[EnsemblesInfoToStore.RecivedTime.Count - 2];//时间差的绝对值
                EnsemblesInfoToStore.t.Add(time);
            }

            double boatSpeed = Math.Sqrt(Math.Pow
                    (((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VX, 2)
                    + Math.Pow(((Velocity)EnsemblesInfoToStore.BoatVelocity[EnsemblesInfoToStore.BoatVelocity.Count - 1]).VY, 2));

            EnsemblesInfoToStore.BoatSpeed.Add(boatSpeed);

            Velocity[] Vel = (Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1];  //Modified HERE 2011-7-28 get velocity here!!!
            double[] waterSpeed = new double[Vel.Length];
            int k = 0;
            foreach (Velocity v in Vel)
            {
                waterSpeed[k] = Math.Sqrt(Math.Pow(v.VX, 2) + Math.Pow(v.VY, 2));
                k++;
            }
            EnsemblesInfoToStore.WaterSpeed.Add(waterSpeed);

            WaterSpeedTransToColor((Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1]);
            //WaterVelocityTransToColor((Velocity[])EnsemblesInfoToStore.WaterVelocity[EnsemblesInfoToStore.WaterVelocity.Count - 1]);
        }
        */
        private void ClearDischargeMsg()  //LPJ 2016-12-12
        {
            dischargeMsg.dLeftShoreArea = 0;
            dischargeMsg.dRightShoreArea = 0;
            dischargeMsg.left.Clear();
            dischargeMsg.leftFlow = 0;
            dischargeMsg.right.Clear();
            dischargeMsg.rightFlow = 0;

            ClearDischargeMsgChanged(ref dischargeMsg.DischargeMsg_BT); 
            ClearDischargeMsgChanged(ref dischargeMsg.DischargeMsg_GGA);
            ClearDischargeMsgChanged(ref dischargeMsg.DischargeMsg_GPS);
            ClearDischargeMsgChanged(ref dischargeMsg.DischargeMsg_NULL);
        }

        private void ClearDischargeMsgChanged(ref DischargeMsgChanged discharge)   //LPJ 2016-12-12
        {
            discharge.bGetFirstGoodEnsemble = false;
            discharge.bottomFlow = 0;  
            discharge.measuredFlow = 0;
            discharge.topFlow = 0;
            discharge.fAccEast = 0;
            discharge.fAccLength = 0;
            discharge.fAccNorth = 0;
            discharge.fAccVx = 0;
            discharge.fAccVy = 0;
            discharge.fArea = 0;
            discharge.fRiverWidth = 0;
            discharge.iPrevGoodEnsembleNoOffset = 0;
            discharge.iPrevGoodEnsemblePos = 0;
            discharge.lastSecond = 0;
            discharge.lBottomDepth.Clear();
            discharge.lEastLength.Clear();
            discharge.lNorthLength.Clear();
          
        }

        private void ClearEnsemblesInfoToStore()
        {
            EnsemblesInfoToStore.WaterVelocity.Clear();
            EnsemblesInfoToStore.BoatVelocity.Clear();
            EnsemblesInfoToStore.RecivedTime.Clear();
            EnsemblesInfoToStore.RecivedDataTime.Clear();
            EnsemblesInfoToStore.bottomDepth.Clear();

            EnsemblesInfoToStore.BinSize.Clear();

            EnsemblesInfoToStore.t.Clear();
            EnsemblesInfoToStore.BoatSpeed.Clear();
            EnsemblesInfoToStore.WaterSpeed.Clear();
            EnsemblesInfoToStore.ChangeNumSum = 0;
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor.Clear();
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen.Clear();
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan.Clear();
            //EnsemblesInfoToStore.NorthVelocityToBlackWhite.Clear();
            //EnsemblesInfoToStore.NorthVelocityToSixColor.Clear();
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen.Clear();
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan.Clear();
            //EnsemblesInfoToStore.EastVelocityToBlackWhite.Clear();
            //EnsemblesInfoToStore.EastVelocityToSixColor.Clear();
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen.Clear();
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan.Clear();
            EnsemblesInfoToStore.RangeOfFirstBin.Clear();   //JZH 2012-02-14 清除新添加成员

            EnsemblesInfoToStore.WaterDir.Clear(); //LPJ 2013-5-24
            EnsemblesInfoToStore.iGoodBin.Clear(); //LPJ 2013-5-24
            EnsemblesInfoToStore.BoatWater.Clear();  //LPJ 2013-5-24
            EnsemblesInfoToStore.WaterSpeedSum.Clear();
            EnsemblesInfoToStore.NewWaterSpeedToSixColor.Clear();
            EnsemblesInfoToStore.Pitch.Clear();
            EnsemblesInfoToStore.Roll.Clear();
            EnsemblesInfoToStore.BoatDir.Clear();

            //Modified 2011-9-14
            //EnsemblesInfoToStore.GPS_latitude.Clear();         //Modified 2011-8-22
            //EnsemblesInfoToStore.GPS_longitude.Clear();
            //EnsemblesInfoToStore.gpsShipSpeed.Clear();
            //EnsemblesInfoToStore.GPS_HDT.Clear();
            //EnsemblesInfoToStore.VXstore.Clear();
            //EnsemblesInfoToStore.VYstore.Clear();
            //EnsemblesInfoToStore.GPS_GGAbuffer.Clear();     //Modified 2011-8-30 add next 4 lines
            //EnsemblesInfoToStore.GPS_VTGbuffer.Clear();
            //EnsemblesInfoToStore.GPS_HDTbuffer.Clear();
            //EnsemblesInfoToStore.GPS_ROTbuffer.Clear();

            EnsemblesInfoToStore.WaterV_GPS.Clear(); //LPJ 2013-7-31 start
            EnsemblesInfoToStore.BoatV_GPS.Clear();
            EnsemblesInfoToStore.BoatSpeed_GPS.Clear();
            EnsemblesInfoToStore.WaterSpeed_GPS.Clear();
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPS.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPS.Clear();
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPS.Clear();
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPS.Clear();
            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPS.Clear();
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPS.Clear();
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPS.Clear();
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPS.Clear();
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPS.Clear();
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPS.Clear();
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPS.Clear();
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPS.Clear();
            EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPS.Clear();

            EnsemblesInfoToStore.WaterDir_GPS.Clear();
            //EnsemblesInfoToStore.iGoodBin.Clear();
            EnsemblesInfoToStore.BoatWater_GPS.Clear();  
            EnsemblesInfoToStore.WaterSpeedSum_GPS.Clear();
            //LPJ 2013-7-31

            EnsemblesInfoToStore.WaterV_GPGGA.Clear(); //LPJ 2013-7-31 start
            EnsemblesInfoToStore.BoatV_GPGGA.Clear();
            EnsemblesInfoToStore.BoatSpeed_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeed_GPGGA.Clear();
            //EnsemblesInfoToStore.WaterSpeedToBlackWhite_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeedToSixColor_GPGGA.Clear();
            //EnsemblesInfoToStore.WaterSpeedToRedBlueGreen_GPGGA.Clear();
            //EnsemblesInfoToStore.WaterSpeedToYellowBlackCyan_GPGGA.Clear();
            //EnsemblesInfoToStore.NorthVelocityToBlackWhite_GPGGA.Clear();
            //EnsemblesInfoToStore.NorthVelocityToSixColor_GPGGA.Clear();
            //EnsemblesInfoToStore.NorthVelocityToRedBlueGreen_GPGGA.Clear();
            //EnsemblesInfoToStore.NorthVelocityToYellowBlackCyan_GPGGA.Clear();
            //EnsemblesInfoToStore.EastVelocityToBlackWhite_GPGGA.Clear();
            //EnsemblesInfoToStore.EastVelocityToSixColor_GPGGA.Clear();
            //EnsemblesInfoToStore.EastVelocityToRedBlueGreen_GPGGA.Clear();
            //EnsemblesInfoToStore.EastVelocityToYellowBlackCyan_GPGGA.Clear();
            EnsemblesInfoToStore.NewWaterSpeedToSixColor_GPGGA.Clear();

            EnsemblesInfoToStore.WaterDir_GPGGA.Clear();
            //EnsemblesInfoToStore.iGoodBin.Clear();
            EnsemblesInfoToStore.BoatWater_GPGGA.Clear();
            EnsemblesInfoToStore.WaterSpeedSum_GPGGA.Clear();
        }
        private void ClearSaveEnsemblesInfo()    //LPJ 2012-5-4 清除saveensembleinfo
        {
            SaveEnsemblesInfo.WaterVelocity.Clear();
            SaveEnsemblesInfo.BoatVelocity.Clear();
            SaveEnsemblesInfo.RecivedTime.Clear();
            SaveEnsemblesInfo.RecivedDataTime.Clear();
            SaveEnsemblesInfo.bottomDepth.Clear();
            SaveEnsemblesInfo.t.Clear();
            SaveEnsemblesInfo.BoatSpeed.Clear();
            SaveEnsemblesInfo.WaterSpeed.Clear();
            SaveEnsemblesInfo.ChangeNumSum = 0;
            //SaveEnsemblesInfo.WaterSpeedToBlackWhite.Clear();
            SaveEnsemblesInfo.WaterSpeedToSixColor.Clear();
            //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen.Clear();
            //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan.Clear();
            //SaveEnsemblesInfo.NorthVelocityToBlackWhite.Clear();
            //SaveEnsemblesInfo.NorthVelocityToSixColor.Clear();
            //SaveEnsemblesInfo.NorthVelocityToRedBlueGreen.Clear();
            //SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan.Clear();
            //SaveEnsemblesInfo.EastVelocityToBlackWhite.Clear();
            //SaveEnsemblesInfo.EastVelocityToSixColor.Clear();
            //SaveEnsemblesInfo.EastVelocityToRedBlueGreen.Clear();
            //SaveEnsemblesInfo.EastVelocityToYellowBlackCyan.Clear();
            SaveEnsemblesInfo.RangeOfFirstBin.Clear();

            SaveEnsemblesInfo.WaterV_GPS.Clear(); //LPJ 2013-7-31
            SaveEnsemblesInfo.BoatV_GPS.Clear();
            SaveEnsemblesInfo.BoatSpeed_GPS.Clear();
            SaveEnsemblesInfo.WaterSpeed_GPS.Clear();
            //SaveEnsemblesInfo.WaterSpeedToBlackWhite_GPS.Clear();
            SaveEnsemblesInfo.WaterSpeedToSixColor_GPS.Clear();
            //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen_GPS.Clear();
            //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan_GPS.Clear();
            //SaveEnsemblesInfo.NorthVelocityToBlackWhite_GPS.Clear();
            //SaveEnsemblesInfo.NorthVelocityToSixColor_GPS.Clear();
            //SaveEnsemblesInfo.NorthVelocityToRedBlueGreen_GPS.Clear();
            //SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan_GPS.Clear();
            //SaveEnsemblesInfo.EastVelocityToBlackWhite_GPS.Clear();
            //SaveEnsemblesInfo.EastVelocityToSixColor_GPS.Clear();
            //SaveEnsemblesInfo.EastVelocityToRedBlueGreen_GPS.Clear();
            //SaveEnsemblesInfo.EastVelocityToYellowBlackCyan_GPS.Clear(); 
            //LPJ 2013-7-31

            SaveEnsemblesInfo.WaterV_GPGGA.Clear(); //LPJ 2013-7-31
            SaveEnsemblesInfo.BoatV_GPGGA.Clear();
            SaveEnsemblesInfo.BoatSpeed_GPGGA.Clear();
            SaveEnsemblesInfo.WaterSpeed_GPGGA.Clear();
            //SaveEnsemblesInfo.WaterSpeedToBlackWhite_GPGGA.Clear();
            SaveEnsemblesInfo.WaterSpeedToSixColor_GPGGA.Clear();
            //SaveEnsemblesInfo.WaterSpeedToRedBlueGreen_GPGGA.Clear();
            //SaveEnsemblesInfo.WaterSpeedToYellowBlackCyan_GPGGA.Clear();
            //SaveEnsemblesInfo.NorthVelocityToBlackWhite_GPGGA.Clear();
            //SaveEnsemblesInfo.NorthVelocityToSixColor_GPGGA.Clear();
            //SaveEnsemblesInfo.NorthVelocityToRedBlueGreen_GPGGA.Clear();
            //SaveEnsemblesInfo.NorthVelocityToYellowBlackCyan_GPGGA.Clear();
            //SaveEnsemblesInfo.EastVelocityToBlackWhite_GPGGA.Clear();
            //SaveEnsemblesInfo.EastVelocityToSixColor_GPGGA.Clear();
            //SaveEnsemblesInfo.EastVelocityToRedBlueGreen_GPGGA.Clear();
            //SaveEnsemblesInfo.EastVelocityToYellowBlackCyan_GPGGA.Clear(); 
        }

        private void InitialAllParam()
        {
            StartRecord = false; //Modified 2011-8-3 HHHHHHHH
            arrAmplitude = null;
            arrCorrelation = null;
            cellSize = 0;
            cells = 0;
            upBlank = 0;
            insDep = 0;
            //projectInfotextBox.Text = "尚未创建工程... ...";
            //InsInfotextBox.Text = "未接受任何数据... ...";
            //GPSInfotextBox.Text = "无GPS数据... ...";
            //buttonCommConnect.Text = "连接仪器";
            ////buttonStart.Text = "开始测量";   //JZH 2012-01-15
            //buttonStart.Text = "开始发射";
            //LPJ 2012-4-20
         
           
            //buttonStart.Text = "开始测量";   //JZH 2012-01-15
          
            iStartMeasQ = 0;                          //LPJ 2012-10-10 
            bStartMeasQ = false;                      //LPJ 2012-10-12
         
            //hasCreatedProject = false;
          
            //EsnNum = 50;
            //projectPause = true;
            projectHasStarted = false;
            //ConfigChangedFlag = true;
            //CommandChangedFlag = true;
            //GPSInfo = string.Empty;
            //GPS_receiveData = string.Empty;
            //GPSLines = 0;
            //GPS_dataToEnsemble = string.Empty;
            //theta = 0;
            //gpsTime = "000000";
            initialGPSData();
          
            PacketPointer = 0;
            MaxArray = 11;
            ClearEnsemblesInfoToStore();
            ClearEnsemblesGPSInfo();     //LPJ 2012-6-29 增加清除GPS数据
            ClearSaveEnsemblesInfo();     //LPJ 2012-5-4
            ClearSaveEnsemblesGPSInfo();  //LPJ 2012-5-4
            BytesArray.Clear();
            payloadLen = 0;
            HasCheckedPayload = false;
            //EnsembleNumber = 1;
            //fn = 1;
            PickAndDecodeEnsemble_FunctionIsFree = true;
            fileNum = 0;
            HeaderFlag = false;
            preNum = 0;
            HeaderFlagNum = 0;
            totalNum = 0;
            MeasTotalNum = 0;
            MainPanelMaxDisPlayer = false;
            TrackDisplayerPanelMaxDisPlayer = false;
            DrawRecFlag = false;
            ClickPzn = 1;
            MouseDownFlag = false;
            //timeKnot = 0;
            playBackMode = false;
            //BinDataFileNum = 0;
            //PlayBackTimeLenth = 1000; //oridinal
            setPlaybackTimeLength = 300; //Modified 2011-11-28
            //PlayBackTimeLenth = 200; //Modified 2011-07-11, This is the only place needed for changing playbacktimeLength
            PlayBackTimeLenth = setPlaybackTimeLength; //Modified 2011-07-11, This is the only place needed for changing playbacktimeLength
            //DisPlayTimeLenth = string.Empty;
            BinDataEnsembleNum = 0;
            //preBlockNum = -1;
            current_EsambleTotaleNum = "-";
            current_DataTime = "-";
            current_TotalTimelabel = "-";
            //labelEsambleNum.Text = "-";
            //labelCellsNum.Text = "-";
         
            //labelReceiveTime.Text = "-";
            labelBE_Vx.Text = "-";
            labelBE_Vy.Text = "-";
            labelBE_Vz.Text = "-";
            labelBE_Vq.Text = "-";
            labelBI_Vx.Text = "-";
            labelBI_Vy.Text = "-";
            labelBI_Vz.Text = "-";
            labelBI_Vq.Text = "-";
            labelBB0.Text = "-";
            labelBB1.Text = "-";
            labelBB2.Text = "-";
            labelBB3.Text = "-";

            //Modified 2011-7-29 clear GPS info HEREHERE!
            current_LongitudeText = "-";
            current_LatitudeText = "-";
            labelShipSpeedText.Text = "-";
            labelNorthSouth.Text = " ";
            labelEastWest.Text = " ";

            EarthWaterlistView.Items.Clear();
            BeamWaterlistView.Items.Clear();
            InstrmtWaterlistView.Items.Clear();
            EarthGdPnglistView.Items.Clear();
            BeamGdPnglistView.Items.Clear();
            BEGdPngListview.Items.Clear();
            BIGPnglistView.Items.Clear();
            BBGPnglistView.Items.Clear();
            WaterAmplitudelistView.Items.Clear();
            BtmAmplitudelistView.Items.Clear();
            WaterCorrelationlistView.Items.Clear();
            BtmCorrelationlistView.Items.Clear();
            labelTime.Text = "-";
            labelNo.Text = "-";
            labelSysTmp.Text = "-";
            labelWPStutas.Text = "-";
            labelWPTmp.Text = "-";
            labelWPSSpd.Text = "-";
            labelWPSalinity.Text = "-";
            labelWPPressure.Text = "-";
            labelWPBeams.Text = "-";
            labelWPBins.Text = "-";
            labelTransDepth.Text = "-";
            labelFrtBinRange.Text = "-";
            labelBinSize.Text = "0";
            labelPingsD.Text = "-";
            labelPingsA.Text = "-";
            labelFrtPingT.Text = "-";
            labelLastPingT.Text = "-";
            current_WPHeading = "-";
            current_WPPitch = "-";
            current_WPRoll = "-";
            labelWPHeading.Text = "-"; //LPJ 2013-8-20
            labelWPPitch.Text = "-"; //LPJ 2013-8-20
            labelWPRoll.Text = "-"; //LPJ 2013-8-20
            labelBTStutas.Text = "-";
            labelBTSysTmp.Text = "-";
            labelBTWaterTmp.Text = "-";
            labelBTPressure.Text = "-";
            labelBTSalinity.Text = "-";
            labelBTSoundSpd.Text = "-";
            labelBTBeams.Text = "-";
            labelBTDepth.Text = "0";
            labelVRB0.Text = "-";
            labelVRB1.Text = "-";
            labelVRB2.Text = "-";
            labelVRB3.Text = "-";
            labelSNRB0.Text = "-";
            labelSNRB1.Text = "-";
            labelSNRB2.Text = "-";
            labelSNRB0.Text = "-";
            labelBTPings.Text = "-";
            labelBTFstPingT.Text = "-";
            labelBTLastPingT.Text = "-";
            labelBTHeading.Text = "-";
            labelBTPitch.Text = "-";
            labelBTRoll.Text = "-";

            //trackBarMaxV.Value = 100;
            //labelMavV.Text = "10m/s";
            trackBarMaxV.Value = 50; //LPJ 2013-8-20
            labelMavV.Text = "5m/s";//LPJ 2013-8-20

            maxCells = 0;
          
            adjustedMultiple = 2;  //LPJ 2016-8-26
            //PlayBackPauseFlag = false; //LPJ 2013-9-18 开始后不直接回放
            PlayBackPauseFlag = true;
            //labelAverageVelocityText.Text = ""; //Modified 2011-8-16   JZH 2011-12-29 取消置空
            DP_ProVersion = Version_2;          //Modified 2011-8-23, playback version control
            //base.ADCP.Form1.版本V20ToolStripMenuItem.Checked = true;
            //版本V10ToolStripMenuItem.Checked = false;
            //CurrentGPSFileNumber = 0; //Modified 2011-8-30
            //SaveGPSFileNumber = 0; //LPJ 2012-5-4 保存GPS数据的文件数
            //displayUTM = true;  //Modified 2011-9-16
            displayUTM = false;   //JZH 2012-01-31 change to BtmTrack
            displayLatLong = false; //Modified 2011-11-18 change to lat long
            displayBtmTrack = true; //JZH 2012-01-31 change to BtmTrack
            radioButtonBtmTrack.Checked = true;  //JZH 2012-01-31 
            //radioButtonMotoke.Checked = true;
            radioButtonMotoke.Checked = false;  //JZH 2012-01-31
            radioButtonLatLong.Checked = false; //Modified 2011-11-18 changed
            GGAsaveCount = 0; //Modified 2011-9-20
            GPSAutoSizecheckBox.Checked = false; //Modified 2011-11-17

            BinDataEnsembleNum = 0;
            totalNum = 0;
            MeasTotalNum = 0;
     
            //Modified 2011-10-22 clear buffers
            for (int i = 0; i < TrackSaveMaxCount; i++)
            {
                GGAsave[i] = ""; // new String[TrackSaveMaxCount];
                AverageVXsave[i] = 0; // = new float[TrackSaveMaxCount];
                AverageVYsave[i] = 0; // = new float[TrackSaveMaxCount];
                LatitudeSave[i] = 0; // = new float[TrackSaveMaxCount];
                LongitudeSave[i] = 0; // = new float[TrackSaveMaxCount];
                UTMpointSave[i].X = 0; // new Point[TrackSaveMaxCount];
                UTMpointSave[i].Y = 0; // new Point[TrackSaveMaxCount];
            }

            //JZH 2012-01-15 河流流量计算初始化
            RTIdata.Clear();   //JZH 2012-01-15 清除流量计算的原始数据 

            //JZH 2012-02-03 初始化流量计算显示面板

            //label_TopDiacharge.Text = "-";
            //label_MiddleDischarge.Text = "-";
            //label_BottomeDischarge.Text = "-";
            //label_LeftBankDischarge.Text = "-";
            //label_RightBankDischarge.Text = "-";
            //label_TotalDischarge.Text = "-";
            current_BottomQ = "-";
            current_LeftQ = "-";
            current_MiddleQ = "-";
            current_RightQ = "-";
            current_TopQ = "-";
            current_TotalQ = "-";

            //JZH 2012-02-18 初始化MainPanel面板上的实时流速大小、方向、水深
            //labelWaterSpeed.Text = "-";
            //labelWaterDirection.Text = "-";
            current_Depth = "-";

            //JZH 2012-03-21 初始化数据接收队列
            queue.Clear();

            //JZH 2012-03-26 初始化导航信息面板参数
            //fAccEast = 0; //JZH 2012-03-25  底跟踪东向累积量
            //fAccNorth = 0; //JZH 2012-02-25 底跟踪北向累积量
            //fAccLength = 0; //JZH 2012-03-25 航迹累积长度
            //bGetFirstGoodEnsemble = true; //JZH 2012-03-25 采集到第一个有效单元
            //iPrevGoodEnsembleNoOffset = 0;  //JZH 2012-03-25  底跟踪前一个有效单元的偏移
            //fAccMG = 0;   //JZH 2012-03-25 直线距离
            //bNewEnsemble = false; //JZH 2012-03-26
            //JZH 2012-04-09 初始化导航信息面板参数
            current_BoatSpeed = "-";
            current_BoatDirection = "-";
            current_WaterDirection = "-";
            current_WaterSpeed = "-";
            current_Length = "-";
            current_DistanceMG = "-";
            current_CourseMG = "-";
            label_AccEast.Text = "-";
            label_AccNorth.Text = "-";

            //LV_MeasuredQ_Paint(); //LPJ 2013-5-17 
            LV_Measured_QPaint(); //LPJ 2013-6-8
            listView_Navigation_Paint(); //LPJ 2013-6-18 将原来的一个listView设为三个
            listView_Others_Paint(); //LPJ 2013-6-18
          
            //JZH 2012-04-09 初始化航迹计算全局变量
            //bFirstGoodEnsemble = false;
            //dLastGoodEnsembleTime = 0;       //JZH 2012-04-09 　前一个有效数据组时间
            //iPrevGoodEnsemble = 0;           //JZH 2012-04-09　 前一个有效数据组序号
            //fAccuEast = 0;                   //JZH 2012-04-09　 东向累计距离
            //fAccuNorth = 0;                  //JZH 2012-04-09　 北向累计距离
            //fAccuLength = 0;                 //JZH 2012-04-09　 累计航迹长度
            //fAccuDisMG = 0;                  //JZH 2012-04-09　 直线距离
            //dCourMG = 0;                     //JZH 2012-04-09　 直线方向

            //JZH 2012-04-11  初始化流量计算全局变量
            //dTopFlow = 0;
            //dMeasuredFlow = 0;
            //dBottomFlow = 0;
            //dRightFlow = 0;
            //dLeftFlow = 0;

            //JZH 2012-04-16 初始化流量全局变量
            leftBank.Clear();
            rightBank.Clear();
            arrayListEastLength.Clear();
            arrayListNorthLength.Clear();
            arrayListBottomDepth.Clear();

            //JZH 2012-04-16 初始化导航信息面板
            current_RiverWidth = "-";
            current_Area = "-";

            //JZH 2012-04-19 初始化导航信息面板
            current_MeanFlowDir = "-";
            current_MeanFLowVel = "-";

            //JZH 2012-04-18    初始化实测面积、岸边面积全局变量
            //fMeasArea = 0;   //实测面积
            //fMeasRiverWidth = 0;
            //dGRightShoreArea = 0.0;
            //dGLeftShoreArea = 0.0;

            //JZH 2012-04-18 初始化计算平均流向、岸边流量正负系数全局参数
            //fGAccVx = 0;
            //fGAccVy = 0;
            //dGShoreVelDir = 0.0;  //JZH 2012-04-18 岸边流速方向 用来判断岸边流量正负
            //dGShoreCoff = 1.0;  //JZH 2012-04-18 岸边流量系数 用来判断岸边流量正负
            //dGMeanFlowDir = 0.0;
            //fGAveDepth = 0;

            SailTrackMouseWheelScale = 1; //LPJ 2012-8-10 初始鼠标滚轮

            fHeadingOffset = 0; //LPJ 2013-11-18 初始化艏向偏差角
            ReceiveBufferString = "";

            GPS_UTCTime.Clear();
            GPGGA_Longitude.Clear();
            GPGGA_Latitude.Clear();

            //InitDischargeMsg(); //LPJ 2016-8-25 实例化对象
        }

        //private void InitDischargeMsg() //LPJ 2016-8-25 实例化对象
        //{
        //    dischargeMsg.left = new List<ArrayClass>();  //LPJ 2016-8-25
        //    dischargeMsg.right = new List<ArrayClass>();  //LPJ 2016-8-25

        //    dischargeMsg.DischargeMsg_BT.lEastLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_BT.lNorthLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_BT.lBottomDepth = new ArrayList();

        //    dischargeMsg.DischargeMsg_GGA.lEastLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_GGA.lNorthLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_GGA.lBottomDepth = new ArrayList();

        //    dischargeMsg.DischargeMsg_GPS.lEastLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_GPS.lNorthLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_GPS.lBottomDepth = new ArrayList();

        //    dischargeMsg.DischargeMsg_NULL.lEastLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_NULL.lNorthLength = new ArrayList();
        //    dischargeMsg.DischargeMsg_NULL.lBottomDepth = new ArrayList();
        //}

        public bool RealDisPlay_Click(object sender, EventArgs e)
        {
            if (playBackMode == true)
            {
                //if (DialogResult.Yes ==
                //    MessageBox.Show("系统正在进行工程回放，是否要结束回放？", "提示",
                //    MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk)) //LPJ 2012-4-20
                if (DialogResult.Yes ==
                    MessageBox.Show(Resource1.String35, Resource1.String19,
                    MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk))
                {
                    PlayBackTimer.Stop();
                    bPlaybackStop = true; //LPJ 2013-11-19
                    PlayBackTimer.Close();

                    playBackMode = false;
                    InitialAllParam();
                    //MainPanel.Refresh();
                    //panelGPSTrack.Refresh(); //LPJ 2013-6-9
                    this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    this.BeginInvoke(TrackPanel_Refresh);
                    //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16  //JZH 2012-01-12

                    btnSpeedFast.Visible = false; //LPJ 2013-7-12
                    btnSpeedSlow.Visible = false; //LPJ 2013-7-12

                    ProcessBar.Refresh();
                    HPRpictureBox.Refresh();

                    //tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
                    //tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
                    //tabPage_Pitch.Refresh(); //LPJ 2013-5-18
                    //tabPage_Roll.Refresh();  //LPJ 2013-5-18
                    //tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

                    //panelSerialTime.Refresh(); //LPJ 2013-9-22
                    this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

                    //LPJ 2013-5-19 自动检测串口连接 --start
                    CommandConnect();
                    //this.Text = System.IO.Path.Combine(Directory.GetCurrentDirectory() + "\\dp300Data", defCfg.DefCfgInf.FileName);
                    this.Text = System.IO.Path.Combine(Directory.GetCurrentDirectory() + "\\dp300Data", labelSiteName.Text);
                    //LPJ 2013-5-19 自动检测串口连接 --end

                  

                    /*
                    FormNewADCP_Project newProjectForm = new FormNewADCP_Project(this);
                    if (DialogResult.OK == newProjectForm.ShowDialog())
                    {
                        newProjectForm.Close();
                        hasCreatedProject = true;
                    }
                    else  //LPJ 2013-4-16
                    {
                        hasCreatedProject = false;
                    }

                    //LPJ 2012-06-13 显示文件路径
                    this.Text = newProjectForm.filepath;*/

                }
            }
            else
            {
                if (projectHasStarted)
                {
                    if (SaveEnsemblesInfo.ChangeNumSum <= restoreNum && SaveEnsemblesInfo.ChangeNumSum > 0)
                    {
                        fileNum++;
                        SaveAsBinaryFormat(SaveEnsemblesInfo, fileNum); //保存playback 数据
                    }

                    playBackMode = false;
                    closeComm();
                    InitialAllParam();

                    this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    this.BeginInvoke(TrackPanel_Refresh);

                    btnSpeedFast.Visible = false; //LPJ 2013-7-12
                    btnSpeedSlow.Visible = false; //LPJ 2013-7-12 

                    ProcessBar.Refresh();
                    HPRpictureBox.Refresh();

                    this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11
                    
                    CommandConnect();
                    this.Text = System.IO.Path.Combine(Directory.GetCurrentDirectory() + "\\dp300Data", labelSiteName.Text);
                }
                else
                {
                    playBackMode = false;

                    closeComm();
                    InitialAllParam();
                    this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
                    this.BeginInvoke(TrackPanel_Refresh);

                    btnSpeedFast.Visible = false; //LPJ 2013-7-12
                    btnSpeedSlow.Visible = false; //LPJ 2013-7-12

                    ProcessBar.Refresh();
                    HPRpictureBox.Refresh();

                    this.BeginInvoke(PaintRefreshEvent); //LPJ 2014-3-11

                    //LPJ 2013-5-19 自动检测串口连接 --start
                    if (!CommandConnect())
                    {
                        return false;
                    }
                    this.Text = System.IO.Path.Combine(Directory.GetCurrentDirectory() + "\\dp300Data", labelSiteName.Text);
                }
            }
            if (playBackMode)
            {
                GPSdisplayLength = 5000;
            }
            else
            {
                GPSdisplayLength = 500;
            }
            return true;
        }

        public bool bClose = false;
      
        protected override void OnFormClosing(FormClosingEventArgs e)  //Modified 2011-8-2 add closing function KKKKKKKKKK
        {
            // if (MessageBox.Show("确定要退出程序吗？", "提示", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.Yes) //LPJ 2012-4-20
            if (MessageBox.Show(Resource1.String36, Resource1.String19, MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.Yes) //LPJ 2013-7-1 cancel
            {
                if (sp.IsOpen == true)
                {
                    sp.Write("STOP" + "\r");
                    sp.Close();
                }
                if (playBackMode == false)
                {
                    if (projectHasStarted)
                    {
                    }
                }
                else
                {
                    try
                    {
                        PlayBackTimer.Stop(); //LPJ 2013-6-8
                        bPlaybackStop = true; //LPJ 2013-11-19
                        PlayBackTimer.Close();
                    }
                    catch
                    {
                    }
                }
                base.OnFormClosing(e);
                bClose = true; //LPJ 2013-5-23
            }
            else
            {
                e.Cancel = true;
                bClose = false;  //LPJ 2013-5-23
            }
        }

        public void OnHome() //LPJ 2013-9-10 当用户点击Home按钮返回主界面时，各个DP300——wnd调用该函数，结束回放
        {
            try
            {
                PlayBackTimer.Stop();
                bPlaybackStop = true; //LPJ 2013-11-19
                PlayBackTimer.Close();
            }
            catch
            {
            }
        }

        //Modified：GPS != GPS罗经。 7月16日修改
        //原“GPS罗经”checkBox 改为 “GPS”，增加“GPS罗经”checkBox
        private void GPScheckbox_CheckedChanged(object sender, EventArgs e)
        {
           
        }

        private void initialGPSData()
        {
            //GPSInfo = string.Empty;
            //GPSLines = 0;
            GPS_receiveData = string.Empty;
            //GPS_dataToEnsemble = string.Empty;
            //theta = 0;
            gpsTime = "000000";
            //MessageBox.Show("StartRecord : " + StartRecord.ToString() + "\r\ncurrentTotalNum: " + currentTotalNum.ToString() + "\r\ntotalNum: " + totalNum.ToString());  //HHHHHHH
            if (StartRecord == false)
            {
                currentTotalNum = 0;
            }
            else
            {
                currentTotalNum = totalNum;
            }
            //currentTotalNum = currentTotalNum;%%%%%%%%%%%%%
            if (TrueNorth || playBackMode == true)
            {
                //labelTextTrueNorth.Show(); //LPJ 2013-5-25 cancle
                //labelTrueNorth.Show();
                //labelTrueNorthText.Show();
            }
            else
            {
                //labelTextTrueNorth.Hide();
                //labelTrueNorth.Hide();
                //labelTrueNorthText.Hide();
            }
            //Modified 2011-9-16
            //displayUTM = true;
            displayUTM = false; //LPJ 2012-9-28
            displayLatLong = false; //Modified 2011-11-18 change
            //displayBtmTrack = false; //JZH 2012-01-31 
            displayBtmTrack = true;  //LPJ 2012-9-28
            //radioButtonBtmTrack.Checked = false; //JZH 2012-01-31
            radioButtonBtmTrack.Checked = true; //LPJ 2012-9-28
            radioButtonLatLong.Checked = false;  //JZH 2012-01-31
            //radioButtonMotoke.Checked = true;    //JZH 2012-01-31
            radioButtonMotoke.Checked = false;   //LPJ 2012-9-28

            StartLongitudeText = new string[10];
            StartLatitudeText = new string[10];
            for (int i = 0; i <= 8; i++)
            {
                StartLongitudeText[i] = "00000.000";
                StartLatitudeText[i] = "0000.000";
            }
        }

        private void displayprocessbar(int time, ProgressBar pb)
        {
            if (pb.Value < 100)
            {
                pb.Value += time;
            }
        }
     
        private void button_CfgLoad_Click(object sender, EventArgs e)
        {
            folderBrowserDialog1.RootFolder = Environment.SpecialFolder.Desktop;//创建选择文件夹窗口
            if (PathStr != null) //LPJ 2013-1-15
            {
                folderBrowserDialog1.SelectedPath = PathStr;
            }
            else
            {
                folderBrowserDialog1.SelectedPath = Environment.CurrentDirectory; //LPJ 2013-1-14
            }

            if (folderBrowserDialog1.ShowDialog() == DialogResult.OK)//选取路径后。。。
            {
                //获取数据路径及信息文件名
                PathStr = folderBrowserDialog1.SelectedPath;
                try   //JZH 2012-06-17 当左右岸系数输入小数时出错
                {
                    //readCfg(PathStr);
                }
                catch //(System.Exception eee)
                {
                    //
                }
            }
        }
 
        private double fHeadingOffset = 0; //LPJ 2013-11-15 GPS安装偏差值
        
        private double GetGPSHeadingOffset()
        {
            double dHeadingOffset = 0; //该单位为弧度
            int iEnsNumbers = RTIdata.Count;
            if (playBackMode)
                iEnsNumbers = BinDataEnsembleNum;

            List<ArrayClass> rawdata = new List<ArrayClass>();
            try
            {
                List<float> fBoatVx_GPS = new List<float>();
                List<float> fBoatVy_GPS = new List<float>();

                for (int i = 0; i < iEnsNumbers; i++)
                {
                    CDecodeGPS decodeGPS = new CDecodeGPS();
                    float ve = 0, vn = 0;
                    float GPS_boatspeed = 0;
                    double GPS_angle = 0;
                    if (!playBackMode)
                    {
                        if (radioBtnInternalGPS.Checked)
                        {
                            #region 内接GPS
                            string GPVTGbuffer = "";
                            string NMEA_buffer = "";
                            NMEA_buffer = Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);
                            decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPVTG", ref GPVTGbuffer);
                            decodeGPS.GPS_VTGdecode(GPVTGbuffer, ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn); //提取在X、Y方向分量上的GPS中的船速 
                            #endregion
                        }
                        else
                        {
                            #region 外接GPS

                            decodeGPS.GPS_VTGdecode(SaveEnsemblesInfo.GPS_VTGbuffer[i].ToString(), ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn);

                            #endregion
                        }
                    }
                    else
                    {
                        if (radioBtnInternalGPS.Checked)
                        {
                            #region 内接GPS
                            string GPVTGbuffer = "";
                            string NMEA_buffer = "";
                            NMEA_buffer = Encoding.Default.GetString(RTIdata[i].NMEA_Buffer);
                            decodeGPS.GPSNMEA_decode(NMEA_buffer, "GPVTG", ref GPVTGbuffer);
                            decodeGPS.GPS_VTGdecode(GPVTGbuffer, ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn); //提取在X、Y方向分量上的GPS中的船速 
                            #endregion
                        }
                        else
                        {
                            #region 外接GPS

                            decodeGPS.GPS_VTGdecode(EnsemblesInfoToStore.GPS_VTGbuffer[i].ToString(), ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn);
                            #endregion
                        }
                    }

                    fBoatVx_GPS.Add(ve);
                    fBoatVy_GPS.Add(vn);

                    rawdata.Add(RTIdata[i]);
                }

                //调用CGetHeadingOffset类，计算GPS艏向安装偏角
                CGetHeadingOffset headingOffset = new CGetHeadingOffset(rawdata, fBoatVx_GPS, fBoatVy_GPS);
                dHeadingOffset = headingOffset.dHeadingOffset / 180.0 * Math.PI; //调用CGetHeadingOffset类所得的角度，单位为度
                //label_Headingoffset.Text = headingOffset.dHeadingOffset.ToString();

                //显示结果
                //current_CourseMG_GPS = headingOffset.dCourseMG_GPS.ToString("0.000");
                //current_CourseMG_BT = headingOffset.dCourseMG_Bottom.ToString("0.000");
                //current_DMG_GPS = headingOffset.dDMG_GPS.ToString("0.000");
                //current_DMG_BT = headingOffset.dDMG_Bottom.ToString("0.000");
                try
                {
                    //if (headingOffset.dDMG_GPS < 0.0000001)
                        //current_Accuracy = "-";
                    //else
                        //current_Accuracy = ((headingOffset.dDMG_Bottom - headingOffset.dDMG_GPS) / headingOffset.dDMG_GPS * 100).ToString("0.00");
                }
                catch
                {
                    //current_Accuracy = "-";
                }
            }
            catch
            {
            }
            return dHeadingOffset;
        }
        
        FrmSystemSetting frmsystemSet;

        bool CommandsInitialized = false;

        /// <summary>
        /// Called when first starting the measurements.
        /// This will start pinging.  Data has not started to be
        /// recording yet.  This will be done later when the start
        /// edge is clicked.
        /// </summary>
        /// <returns></returns>
        public bool OnStartPinging()
        {
            //ClearEnsemblesInfoToStore();

            linkLabelEdgeSetting.Enabled = false; //LPJ 2013-6-24
            linkLabelSiteInfor.Enabled = false;
            linkLabelSystemConf.Enabled = false;
            linkLabelSystemSetting.Enabled = false;
            linkLabelUnit.Enabled = false;
            linkLabelCompassCalibration.Enabled = false;
            linkLabelGPSConf.Enabled = false;
            linkLabelSettingTime.Enabled = false;
            linkLabelSystemTest.Enabled = false;
            linkLabelUpdateFirmware.Enabled = false;
            linkLabelBeamCheck.Enabled = false; //LPJ 2014-6-20
            linkLabelDownload.Enabled = false;

            //btnGPSCalibration.Enabled = false; //LPJ 2013-11-15
            linkLabelHeadingOffset.Enabled = false; //LPJ 2013-11-18

            btnSpeedFast.Visible = false; //LPJ 2013-7-12
            btnSpeedSlow.Visible = false; //LPJ 2013-7-12

            //frmsystemSet = new FrmSystemSetting(sp, ref systSet);
            if (!CommandsInitialized)
            {
                sp.Write("STOP\r");
                Thread.Sleep(150);

                while (!ReceiveBufferString.Contains("STOP"))
                {
                    sp.Write("STOP\r");
                    Thread.Sleep(150);
                }
                
                SystemSetting();
            }

            sp.Write("START\r");
            Thread.Sleep(150);
            while (!ReceiveBufferString.Contains("START"))
            {
                sp.Write("START\r");
                Thread.Sleep(150);
            }

            CurrentState = TRANSECT_STATE_START;

            iEnsembleInterval = 1;

            WaterAvgNum = 2;
            
            if (bGPSConnect) //LPJ 2013-6-21
            {
                try
                {
                    GPS_sp.Open();

                    //LPJ 2014-7-1 警报定时器初始化
                    iAlarmTime_GPS = 0;
                    AlarmTimer_GPS = new System.Timers.Timer();
                    AlarmTimer_GPS.Elapsed += new System.Timers.ElapsedEventHandler(AlarmTimer_GPS_Elapsed);
                    AlarmTimer_GPS.Interval = 100;
                    //AlarmTimer_GPS.Start();
                }
                catch (System.Exception ee)
                {
                    MessageBox.Show(Resource1.String42 + "/r/n" + ee.Message);
                }
                initialGPSData();
            }

            tabControl4.SelectedIndex = 1; //LPJ 2013-6-21
            ResizeControls(); //LPJ 2013-8-5 

            
            //初始化数据接收定时器
            RealTimeProcessingTimer = new System.Timers.Timer();
            RealTimeProcessingTimer.Elapsed += new System.Timers.ElapsedEventHandler(RealTimeProcessingTimer_Elapsed);
            RealTimeProcessingTimer.Interval = iRealTimeInterval;
            RealTimeProcessingTimer.Start();

            // Create a new path for the project data
            // This create a folder for each new project.
            CreateNewProjectPath();

            // Create a QRev Project file
            CreateQRevProject(labelSiteName.Text);

            return true;
        }
        
        /// <summary>
        /// Start recording and processing the live data.
        /// </summary>
        public void OnStartRecording()
        {
            MouseWheelScale = 1;
            sp.DiscardInBuffer();
            PacketPointer = 0;
            MaxArray = 11;
            BytesArray.Clear();
            payloadLen = 0;
            HasCheckedPayload = false;
            HeaderFlag = false;
            preNum = 0;
            HeaderFlagNum = 0;
            MaxWaterSpeed = 0; //LPJ 2013-8-6 
            //LPJ 2012-10-11 点击开始测流后，清空EnsembleInfoToStore的数据，从现在开始绘制新的流量图---start
            ClearEnsemblesInfoToStore();  //LPJ 2012-10-11
            ClearEnsemblesGPSInfo();      //LPJ 2012-10-11
            totalNum = 0;
            InitDischargeParameter();
            //fAccuEast = 0;
            //fAccuNorth = 0;
            //fAccuLength = 0;
            //fGAccVx = 0;
            //fGAccVy = 0;
            //fMeasArea = 0;
            //fMeasRiverWidth = 0;

            //dTopFlow = 0;
            //dMeasuredFlow = 0;
            //dBottomFlow = 0;
            //dLeftFlow = 0; //LPJ 2013-6-5 清除记录
            //dRightFlow = 0;

            MeasTotalNum = 0;
            GGAsaveCount = 0; //LPJ 2013-8-2 初始化GPS数据个数

            ReceiveBufferString = ""; //LPJ 2014-7-4 清空

            GPS_UTCTime.Clear();
            GPGGA_Longitude.Clear();
            GPGGA_Latitude.Clear();

            ClearDischargeMsg();  //LPJ 2016-12-12 清除流量数据
            //LPJ 2012-10-11 点击开始测流后，清空EnsembleInfoToStore的数据，从现在开始绘制新的流量图---end

            tabControl4.SelectedIndex = 1; //LPJ 2013-6-21
            ResizeControls(); //LPJ 2013-8-5 

            //LPJ 2014-6-9 警报定时器初始化
            iAlarmTime = 0;
            AlarmTimer = new System.Timers.Timer();
            AlarmTimer.Elapsed += new System.Timers.ElapsedEventHandler(AlarmTimer_Elapsed);
            AlarmTimer.Interval = 100;
            //AlarmTimer.Start();

            //projectPause = false;

            StartRecord = true;    //Modified 2011-8-3 used for clear info display   HHHHHHHHH  //LPJ 2016-12-13

        }

        private System.Timers.Timer AlarmTimer; //LPJ 2014-6-9 计时器，当无接收数据时报警
        private int iAlarmTime = 0;  //LPJ 2014-6-9

        private System.Timers.Timer AlarmTimer_GPS; //LPJ 2014-7-1 计时器，当连接GPS后无接收数据时报警
        private int iAlarmTime_GPS = 0;  //LPJ 2014-7-1

        private float iEnsembleInterval = 1; //LPJ 2014-7-1 CEI

        //LPJ 2014-6-9 警报提示
        [DllImport("Kernel32.dll")]
        public static extern bool Beep(int freq, int duration);
        //LPJ 2014-6-9 计时器方法
        private void AlarmTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            iAlarmTime++; //
            if (iAlarmTime / 10.0 > 5 * iEnsembleInterval)
            {
                Beep(800, 60000);
                iAlarmTime = 0;
                //弹出提示框
                if (!bMessageBoxShow)
                {
                    bMessageBoxShow = true;
                    if (MessageBox.Show(Resource1.String297, Resource1.String296, MessageBoxButtons.OK, MessageBoxIcon.Error) == DialogResult.OK)
                        bMessageBoxShow = false;
                }
            }
        }
        bool bMessageBoxShow = false; //LPJ 2014-7-9
        bool bMessageBoxShow_GPS = false;  //LPJ 2014-7-9
        //LPJ 2014-6-9 计时器方法
        private void AlarmTimer_GPS_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            iAlarmTime_GPS++; //
            if (iAlarmTime_GPS / 10.0 > 5 * iEnsembleInterval)
            {
                Beep(500, 30000);
                iAlarmTime_GPS = 0;
                if (!bMessageBoxShow_GPS)
                {
                    bMessageBoxShow_GPS = true;
                    if (MessageBox.Show(Resource1.String298, Resource1.String296, MessageBoxButtons.OK, MessageBoxIcon.Error) == DialogResult.OK)
                        bMessageBoxShow_GPS = false;
                }
            }
        }

        public void btnStop()
        {
            bEndEdge = false;

            if (iStartMeasQ > 0) //LPJ 2013-5-31 当测量后，才写入配置信息
            {
                WriteSmartPageToFile(Path.Combine(newPath, ProjectFullName + ".cfg"));  //LPJ 2014-7-29
            }

            try
            {
                //WriteSmartPageToFile(Directory.GetCurrentDirectory() + "\\dp300Data" + "\\Config.cfg"); //LPJ 2014-7-29
                WriteSmartPageToFile(RttProject.GetDefaultPath("Default_Config", ".cfg"));
            }
            catch
            {
            }

            if(bStartMeasQ)
            {
                 //LPJ 2013-8-8 在测量结束后，自动到另一个起始岸 ---start
                if(labelStartEdge.Text==Resource1.String226)
                    labelStartEdge.Text=Resource1.String227;
                else
                    labelStartEdge.Text=Resource1.String226;
                //LPJ 2013-8-8 在测量结束后，自动到另一个起始岸 ---end
            }

            StartRecord = false; //LPJ 2014-6-17
            sp.Write("STOP" + '\r');
            Thread.Sleep(150);

            while (!ReceiveBufferString.Contains("STOP"))
            {
                sp.Write("STOP" + '\r');
                Thread.Sleep(150);
            }

          //  if (GPScheckbox.Checked == true)
            if(bGPSConnect) //LPJ 2013-6-21
            {
                GPS_sp.Close();
                initialGPSData();

                try
                {
                    //AlarmTimer_GPS.Stop();
                    //AlarmTimer_GPS.Close();
                }
                catch
                {
                }
            }
            //projectPause = true;

            //JZH 2012-03-21 停止并释放实时处理定时器
            RealTimeProcessingTimer.Stop();
            RealTimeProcessingTimer.Close();

            //LPJ 2014-3-14 当点击了起始岸后，才可用
            if (bStartMeasQ)
                this.BeginInvoke(RefreshSummaryList); //LPJ 2013-6-19 在测量完成后，将该测回的汇总信息写入listViewSummary中

            bStartMeasQ = false;
            

            //LPJ 2014-6-9 停止并释放
            //AlarmTimer.Stop();
            //AlarmTimer.Close();

            if (checkBoxGetHeadingOffset.Checked) //LPJ 2015-9-22 当用户选择获取艏向偏差，则计算该值，并将其显示
            {
                GetGPSHeadingOffset();
            }

            linkLabelEdgeSetting.Enabled = true; //LPJ 2013-6-24
            linkLabelSiteInfor.Enabled = true;
            linkLabelSystemConf.Enabled = true;
            linkLabelSystemSetting.Enabled = true;
            linkLabelUnit.Enabled = true;
            //linkLabelCompassCalibration.Enabled = true;
            linkLabelGPSConf.Enabled = true;
            linkLabelSettingTime.Enabled = true;
            linkLabelSystemTest.Enabled = true;
            linkLabelUpdateFirmware.Enabled = true;
            linkLabelBeamCheck.Enabled = true; //LPJ 2014-6-20
            linkLabelDownload.Enabled = true;

            //btnGPSCalibration.Enabled = true; //LPJ 2013-11-15
            linkLabelHeadingOffset.Enabled = true; //LPJ 2013-11-18

            TrackPanelPaint();
        }

        /// <summary>
        /// 停止发射呯
        /// </summary>
        public void OnStopPinging()
        {
            //CurrentState = TRANSECT_STATE_STOP;

            sp.Write("STOP" + '\r');
            Thread.Sleep(150);

            while (!ReceiveBufferString.Contains("STOP"))
            {
                sp.Write("STOP" + '\r');
                Thread.Sleep(150);
            }

            //  if (GPScheckbox.Checked == true)
            if (bGPSConnect) //LPJ 2013-6-21
            {
                GPS_sp.Close();
                initialGPSData();

                try
                {
                    //AlarmTimer_GPS.Stop();
                    //AlarmTimer_GPS.Close();
                }
                catch
                {
                }
            }
            //projectPause = true;

            //JZH 2012-03-21 停止并释放实时处理定时器  //LPJ 2016-12-13
            RealTimeProcessingTimer.Stop();
            RealTimeProcessingTimer.Close();

            linkLabelEdgeSetting.Enabled = true; //LPJ 2013-6-24
            linkLabelSiteInfor.Enabled = true;
            linkLabelSystemConf.Enabled = true;
            linkLabelSystemSetting.Enabled = true;
            linkLabelUnit.Enabled = true;
            //linkLabelCompassCalibration.Enabled = true;
            linkLabelGPSConf.Enabled = true;
            linkLabelSettingTime.Enabled = true;
            linkLabelSystemTest.Enabled = true;
            linkLabelUpdateFirmware.Enabled = true;
            linkLabelBeamCheck.Enabled = true; //LPJ 2014-6-20
            linkLabelDownload.Enabled = true;

            //btnGPSCalibration.Enabled = true; //LPJ 2013-11-15
            linkLabelHeadingOffset.Enabled = true; //LPJ 2013-11-18
            TrackPanelPaint();

            // Save the latest QRev Project data
            SaveQRevProjectFile();
        }

        /// <summary>
        /// 停止记录数据
        /// </summary>
        public void OnStopRecording()
        {
            CurrentState = TRANSECT_STATE_STOP;

            string CMD = "CRSTS " + TRANSECT_STATE_STOP.ToString() + '\r';
            sp.Write(CMD);

            bEndEdge = false;

            // QRev
            // Stop the Edge Ensemble Counter
            StopQRevEndEdgeCounter(bStartLeftEdge);


            if (iStartMeasQ > 0) //LPJ 2013-5-31 当测量后，才写入配置信息
            {
                //WriteSmartPageToFile(newPath + "\\SysCfg\\Config.cfg"); //LPJ 2013-6-20 当测量结束时，将smartPage页中的配置写入文件，并复制到Lastconf  
                WriteSmartPageToFile(Path.Combine(newPath, ProjectFullName + ".cfg"));  //LPJ 2014-7-29
            }

            try
            {
                //LPJ 2014-1-7 将配置信息保存到lastTimeCfg中
                //WriteSmartPageToFile(Directory.GetCurrentDirectory() + "\\dp300Data" + "\\LastTimeCfg" + "\\Config.cfg");
                //WriteSmartPageToFile(Directory.GetCurrentDirectory() + "\\dp300Data" + "\\Config.cfg"); //LPJ 2014-7-29
                WriteSmartPageToFile(RttProject.GetDefaultPath("Default_Config", ".cfg"));
            }
            catch
            {
            }

            if (bStartMeasQ)
            {
                //LPJ 2013-8-8 在测量结束后，自动到另一个起始岸 ---start
                if (labelStartEdge.Text == Resource1.String226)
                    labelStartEdge.Text = Resource1.String227;
                else
                    labelStartEdge.Text = Resource1.String226;
                //LPJ 2013-8-8 在测量结束后，自动到另一个起始岸 ---end
            }

            StartRecord = false; //LPJ 2014-6-17
          
            //LPJ 2014-3-14 当点击了起始岸后，才可用
            if (bStartMeasQ)
                this.BeginInvoke(RefreshSummaryList); //LPJ 2013-6-19 在测量完成后，将该测回的汇总信息写入listViewSummary中

            bStartMeasQ = false;

            //LPJ 2014-6-9 停止并释放
            //AlarmTimer.Stop();
            //AlarmTimer.Close();

            if (checkBoxGetHeadingOffset.Checked) //LPJ 2015-9-22 当用户选择获取艏向偏差，则计算该值，并将其显示
            {
                GetGPSHeadingOffset();
            }
            TrackPanelPaint();

            // QRev
            // Add the Transect to the project
            AddQRevTransectToProject();
        }
            
        private void trackBarMaxV_Scroll(object sender, EventArgs e)
        {
            //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
            if (!bEnglish2Metric)
            {
                labelMavV.Text = (projectUnit.MeterToFeet((float)trackBarMaxV.Value / 10, 1)).ToString("0.00") + "ft/s";
            }
            else
            {
                labelMavV.Text = ((float)trackBarMaxV.Value / 10).ToString() + "m/s";
            }

            if (trackBarMaxV.Value != 0)
                adjustedMultiple = 100f / trackBarMaxV.Value;
            else
                adjustedMultiple = 100;

            ChangeToNewRGB();//LPJ 2013-7-4 重新载入颜色

            //MainPanel.Refresh();
            //panelGPSTrack.Refresh(); //LPJ 2013-6-9
            this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
            this.BeginInvoke(TrackPanel_Refresh);
            //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16 //JZH 2012-01-12
            InfoPanel.Refresh();
        }

        private void trackBarCellNum_Scroll(object sender, EventArgs e)
        {
            //MainPanel.Refresh();
            //panelGPSTrack.Refresh(); //LPJ 2013-6-9
            this.BeginInvoke(MainPanel_Refresh); //LPJ 2013-7-2
            this.BeginInvoke(TrackPanel_Refresh);
            //if (RiverAuthority == true) RiverPanel.Refresh();   //Modified 2011-10-16  //JZH 2012-01-12
           
        }

        private void pictureBox_W_A_Paint(object sender, PaintEventArgs e)  //绘制回波强度副图，这里的图不好看，可改为平滑曲线
        {
            //JZH 2012-04-19 为1200K仪器使用，回波强度在0-200count之间，因此调整了该副图的坐标最大值从2000 降至200 即/2000 改为/200 以后修改成可自动调整
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage32)
            {
                Graphics g = e.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                if (radioButtonWhole_WA.Checked) //合并按钮
                {
                    for (int i = 0; i <= 3; i++)      //画强度值中的50、100、150、200之间的竖线
                    {
                        for (int j = 1; j <= 4; j++)
                        {
                            float x = pictureBox_W_A.Width / 4f * i + pictureBox_W_A.Width / 20f * j;
                            g.DrawLine(Pens.Gainsboro, x, 0, x, pictureBox_W_A.Height);    //画强度值中的以10间隔的浅灰色竖线
                        }
                        if (i != 0) //画强度值中的50、100、150、200之间的黑色竖线
                            g.DrawLine(Pens.Gray, pictureBox_W_A.Width / 4f * i, 0, pictureBox_W_A.Width / 4f * i, pictureBox_W_A.Height);
                    }
                }
                else  //分离按钮，当选择分离时，则每个波束都从0-200绘制一条变化曲线，
                {
                    for (int i = 0; i <= 3; i++) //将分为4块，每块表示一个波束
                    {
                        for (int j = 1; j <= 3; j++)  //将每个波束的强度0-200分为4个区间
                        {
                            float x = pictureBox_W_A.Width / 4f * i + pictureBox_W_A.Width / 16f * j;
                            g.DrawLine(Pens.Gainsboro, x, 0, x, pictureBox_W_A.Height);
                        }
                        if (i != 0)
                            g.DrawLine(Pens.Black, pictureBox_W_A.Width / 4f * i, 0, pictureBox_W_A.Width / 4f * i, pictureBox_W_A.Height);
                    }
                }


                if (arrAmplitude != null)
                {
                    //using (Graphics g = pictureBox1.CreateGraphics())
                    //{
                    int n = arrAmplitude.GetLength(1);//得到水单元层数
                    //PointF[] p0 = new PointF[2 * n];  //LPJ 2012-9-27 cancle
                    //PointF[] p1 = new PointF[2 * n];
                    //PointF[] p2 = new PointF[2 * n];
                    //PointF[] p3 = new PointF[2 * n];

                    PointF[] p0 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p1 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p2 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p3 = new PointF[n]; //LPJ 2012-9-27 change

                    if (radioButtonWhole_WA.Checked)//合并模式
                    {
                        //if (checkBox_WA_b0.Checked)  //LPJ 2012-9-27 cancle
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p0[2 * i] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width, i * FuTuHeight_WA); //在某一层中的起始点坐标，FuTuHeight_WA该值为层高度，实时模式为11，回放为80，可改为该值等于pictureBox_W_A/总层数
                        //        p0[2 * i + 1] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width, FuTuHeight_WA + i * FuTuHeight_WA); //在某一层中的终止点坐标，
                        //    }
                        //    g.DrawLines(Pens.Red, p0);  //在一个波束的所有层的总线段，一层中的起始终止点连成了一个竖直线段，应该改为不要终止点，只是起始点连接，可连成一个折线段
                        //}
                        //if (checkBox_WA_b1.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p1[2 * i] = new PointF(arrAmplitude[1, i] / 200f * pictureBox_W_A.Width, i * FuTuHeight_WA);
                        //        p1[2 * i + 1] = new PointF(arrAmplitude[1, i] / 200f * pictureBox_W_A.Width, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.LimeGreen, p1);
                        //}
                        //if (checkBox_WA_b2.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p2[2 * i] = new PointF(arrAmplitude[2, i] / 200f * pictureBox_W_A.Width, i * FuTuHeight_WA);
                        //        p2[2 * i + 1] = new PointF(arrAmplitude[2, i] / 200f * pictureBox_W_A.Width, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.Blue, p2);
                        //}
                        //if (checkBox_WA_b3.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p3[2 * i] = new PointF(arrAmplitude[3, i] / 200f * pictureBox_W_A.Width, i * FuTuHeight_WA);
                        //        p3[2 * i + 1] = new PointF(arrAmplitude[3, i] / 200f * pictureBox_W_A.Width, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.Magenta, p3);
                        //}

                        //LPJ 2012-9-27 start
                        if (checkBox_WA_b0.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p0[i] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width, i * (float)pictureBox_W_A.Height / (cells - 1)); //在某一层中的起始点坐标，FuTuHeight_WA该值为层高度，实时模式为11，回放为80，可改为该值等于pictureBox_W_A/总层数
                            }
                            Pen redPen = new Pen(Brushes.Red, 2);
                            g.DrawLines(redPen, p0);  //在一个波束的所有层的总线段，一层中的起始终止点连成了一个竖直线段，应该改为不要终止点，只是起始点连接，可连成一个折线段
                        }
                        if (checkBox_WA_b1.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p1[i] = new PointF(arrAmplitude[1, i] / 200f * pictureBox_W_A.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen LimeGreenPen = new Pen(Brushes.LimeGreen, 2);
                            g.DrawLines(LimeGreenPen, p1);
                        }
                        if (checkBox_WA_b2.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p2[i] = new PointF(arrAmplitude[2, i] / 200f * pictureBox_W_A.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen BluePen = new Pen(Brushes.Blue, 2);
                            g.DrawLines(BluePen, p2);
                        }
                        if (checkBox_WA_b3.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p3[i] = new PointF(arrAmplitude[3, i] / 200f * pictureBox_W_A.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen MagentaPen = new Pen(Brushes.Magenta, 2);
                            g.DrawLines(MagentaPen, p3);
                        }
                        //LPJ 2012-9-27 end
                    }
                    else  //分离模式
                    {
                        //if (checkBox_WA_b0.Checked)  //LPJ 2012-9-27 cancle
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p0[2 * i] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width / 4f, i * FuTuHeight_WA);
                        //        p0[2 * i + 1] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width / 4f, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.Red, p0);
                        //}
                        //if (checkBox_WA_b1.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p1[2 * i] = new PointF((arrAmplitude[1, i] / 200f + 1) * pictureBox_W_A.Width / 4f, i * FuTuHeight_WA);
                        //        p1[2 * i + 1] = new PointF((arrAmplitude[1, i] / 200f + 1) * pictureBox_W_A.Width / 4f, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.LimeGreen, p1);
                        //}
                        //if (checkBox_WA_b2.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p2[2 * i] = new PointF((arrAmplitude[2, i] / 200f + 2) * pictureBox_W_A.Width / 4f, i * FuTuHeight_WA);
                        //        p2[2 * i + 1] = new PointF((arrAmplitude[2, i] / 200f + 2) * pictureBox_W_A.Width / 4f, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.Blue, p2);
                        //}
                        //if (checkBox_WA_b3.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p3[2 * i] = new PointF((arrAmplitude[3, i] / 200f + 3) * pictureBox_W_A.Width / 4f, i * FuTuHeight_WA);
                        //        p3[2 * i + 1] = new PointF((arrAmplitude[3, i] / 200f + 3) * pictureBox_W_A.Width / 4f, FuTuHeight_WA + i * FuTuHeight_WA);
                        //    }
                        //    g.DrawLines(Pens.Magenta, p3);
                        //}

                        //LPJ 2012-9-27 start
                        if (checkBox_WA_b0.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p0[i] = new PointF(arrAmplitude[0, i] / 200f * pictureBox_W_A.Width / 4f, i * (float)pictureBox_W_A.Height / (cells- 1));
                            }
                            Pen redPen = new Pen(Brushes.Red, 2);
                            g.DrawLines(redPen, p0);
                        }
                        if (checkBox_WA_b1.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p1[i] = new PointF((arrAmplitude[1, i] / 200f + 1) * pictureBox_W_A.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen LimeGreenPen = new Pen(Brushes.LimeGreen, 2);
                            g.DrawLines(LimeGreenPen, p1);
                        }
                        if (checkBox_WA_b2.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p2[i] = new PointF((arrAmplitude[2, i] / 200f + 2) * pictureBox_W_A.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen BluePen = new Pen(Brushes.Blue, 2);
                            g.DrawLines(BluePen, p2);
                        }
                        if (checkBox_WA_b3.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p3[i] = new PointF((arrAmplitude[3, i] / 200f + 3) * pictureBox_W_A.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen MagentaPen = new Pen(Brushes.Magenta, 2);
                            g.DrawLines(MagentaPen, p3);
                        }
                        //LPJ 2012-9-27 end
                    }
                    //}
                }
            }
        }

        private void pictureBox_W_A_Mousewheel(object sender, MouseEventArgs e)
        {
            if (e.Delta > 0)
            {
                if (vScrollBar_W_A.Value <= 100)
                    vScrollBar_W_A.Value = 0;
                else
                    vScrollBar_W_A.Value -= 100;
            }
            else
            {
                if (vScrollBar_W_A.Value >= 15900)
                    vScrollBar_W_A.Value = 16000;
                else
                    vScrollBar_W_A.Value += 100;
            }
            vScrollBar_W_A_Scroll(null, null);
        }

        private void vScrollBar_W_A_Scroll(object sender, ScrollEventArgs e)
        {
            pictureBox_W_A.Top = -vScrollBar_W_A.Value;
            panel_W_A.Top = -vScrollBar_W_A.Value;
        }

        private void pictureBox_W_A_MouseEnter(object sender, EventArgs e)
        {
            pictureBox_W_A.Focus();
        }

        private void tabPage32_Paint(object sender, PaintEventArgs e)//副图 测流 回波强度
        {
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage32)
            {
                using (Graphics g = e.Graphics)
                {
                    using (Font ft = new Font("Arial", 8))
                    {
                        //LPJ 2012-9-27 删除字符及颜色显示
                        /*
                        g.DrawLine(Pens.Red, 10, 15, 35, 15);
                        SizeF s = g.MeasureString("Beam0", ft);
                        g.DrawString("Beam0", ft, Brushes.Black, 40, 15 - s.Height / 2f);

                        g.DrawLine(Pens.LimeGreen, 90, 15, 115, 15);
                        s = g.MeasureString("Beam1", ft);
                        g.DrawString("Beam1", ft, Brushes.Black, 120, 15 - s.Height / 2f);

                        g.DrawLine(Pens.Blue, 170, 15, 195, 15);
                        s = g.MeasureString("Beam2", ft);
                        g.DrawString("Beam2", ft, Brushes.Black, 200, 15 - s.Height / 2f);

                        g.DrawLine(Pens.Magenta, 250, 15, 275, 15);
                        s = g.MeasureString("Beam3", ft);
                        g.DrawString("Beam3", ft, Brushes.Black, 280, 15 - s.Height / 2f);
                       // s = g.MeasureString("回波强度[单位:count] (20 counts≈1 db)", ft);
                      //  g.DrawString("回波强度[单位:count] (20 counts≈1 db)", ft, Brushes.Black, 30 + pictureBox_W_A.Width / 2f - s.Width / 2f, 30);//LPJ 2012-4-20
                        s = g.MeasureString(Resource1.String48, ft);
                        g.DrawString(Resource1.String48, ft, Brushes.Black, 30 + pictureBox_W_A.Width / 2f - s.Width / 2f, 30);
                         */
                        //LPJ 2012-9-27 删除字符及颜色显示
                        if (true == radioButtonWhole_WA.Checked)
                        {
                            for (int i = 0; i <= 4; i++)
                            {
                                //g.DrawLine(Pens.Black, 30 + pictureBox1.Width / 4f * i, 58, 30 + pictureBox1.Width / 4f * i, 60);
                                SizeF s1 = g.MeasureString((50 * i).ToString(), ft);
                                //g.DrawString((500 * i).ToString(), ft, Brushes.Black, 30 + pictureBox_W_A.Width / 4f * i - s1.Width / 2f, 58 - s1.Height);  //JZH 2012-04-19 cancel
                                //g.DrawString((50 * i).ToString(), ft, Brushes.Black, 30 + pictureBox_W_A.Width / 4f * i - s1.Width / 2f, 58 - s1.Height);     //该修改仅供1200K使用 1200K的回波强度比较低 //LPJ 2012-9-27 cancle
                                g.DrawString((50 * i).ToString(), ft, Brushes.Black, 20 + pictureBox_W_A.Width / 4f * i - s1.Width / 2f, 15 - s1.Height); //LPJ 2012-9-27 将其上移
                            }
                        }
                        else
                        {
                            for (int i = 0; i <= 3; i++)
                            {
                                for (int j = 0; j <= 4; j++)
                                {
                                    //if (!(i != 0 && 0 == j))
                                    //{
                                    //    float x = 30 + pictureBox1.Width / 4f * i + pictureBox1.Width / 16f * j;
                                    //    SizeF s1 = g.MeasureString((500 * j).ToString(), ft);
                                    //    g.DrawString((500 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 58 - s1.Height);
                                    //}
                                    if ((0 == i && 0 == j) || (4 == j))
                                    {
                                        float x = 20 + pictureBox_W_A.Width / 4f * i + pictureBox_W_A.Width / 16f * j;
                                        SizeF s1 = g.MeasureString((50 * j).ToString(), ft);
                                        //g.DrawString((500 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 58 - s1.Height);
                                        g.DrawString((50 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 15 - s1.Height);//LPJ 2012-9-27 将其上移
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private void panel_W_A_Paint(object sender, PaintEventArgs e)
        {
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage32)
            {
                using (Graphics g = e.Graphics)
                {
                    using (Font ft = new Font("Arial", 8))
                    {
                        //if (radioButtonRealTime_WA.Checked)   //LPJ 2012-9-27 取消
                        //{
                        //    for (int i = 0; i < 200; i++)    //LPJ 2012-9-27 副图中画了200层，没必要这么多，可修改为只画设置的层数textBinNum的值
                        //    {
                        //        //g.DrawString("第", ft, Brushes.Black, 7, 15 + 80 * i);
                        //        //SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        //g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + 80 * i + 15);
                        //        //g.DrawString("层", ft, Brushes.Black, 7, 15 + 80 * i + 30);
                        //        //g.DrawLine(Pens.Black, 0, 80 * (i + 1), panel_W_A.Width, 80 * (i + 1));
                        //        SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, (FuTuHeight_WA - s.Height) / 2 + FuTuHeight_WA * i);
                        //        g.DrawLine(Pens.Black, 0, FuTuHeight_WA * (i + 1), panel_W_A.Width, FuTuHeight_WA * (i + 1));   //副图中的层数的横线，这个可以去掉，只显示数字，或将其改为短线段
                        //    }
                        //}
                        //else
                        //{
                        //    for (int i = 0; i < 200; i++)   //LPJ 2012-9-27 这里同上
                        //    {
                        //       // g.DrawString("第", ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i);//LPJ 2012-4-20
                        //        g.DrawString(Resource1.String49, ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i);
                        //        SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + FuTuHeight_WA * i + 15);
                        //       // g.DrawString("层", ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i + 30);//LPJ 2012-4-20
                        //        g.DrawString(Resource1.String50, ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i + 30);
                        //        g.DrawLine(Pens.Black, 0, FuTuHeight_WA * (i + 1), panel_W_A.Width, FuTuHeight_WA * (i + 1));
                        //    }
                        //}

                        //LPJ 2012-9-27 修改——start
                        if (radioButtonRealTime_WA.Checked)  //实时数据
                        {
                            for (int i = 0; i < cells; )
                            //for (int i = 0; i < 200; i++)    //LPJ 2012-9-27 副图中画了200层，没必要这么多，可修改为只画设置的层数textBinNum的值
                            {
                                SizeF s = g.MeasureString((i + 1).ToString(), ft);
                                g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, (float)panel_W_A.Height / cells  * i);
                                //  g.DrawLine(Pens.Black, 0, FuTuHeight_WA * (i + 1), panel_W_A.Width, FuTuHeight_WA * (i + 1));   //副图中的层数的横线，这个可以去掉，只显示数字，或将其改为短线段

                                if (cells > 150)
                                    i += 8;
                                else if (cells > 100)
                                    i += 6;
                                else if (cells > 50)
                                    i += 4;
                                else
                                    i += 2;
                            }
                        }
                        else  //历史数据，回放的时候还是用的实时数据显示？
                        {
                            for (int i = 0; i < cells; i++)
                            //for (int i = 0; i < 200; i++)   //LPJ 2012-9-27 这里同上
                            {
                                // g.DrawString("第", ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i);//LPJ 2012-4-20
                                g.DrawString(Resource1.String49, ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i);
                                SizeF s = g.MeasureString((i + 1).ToString(), ft);
                                g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + FuTuHeight_WA * i + 15);
                                // g.DrawString("层", ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i + 30);//LPJ 2012-4-20
                                g.DrawString(Resource1.String50, ft, Brushes.Black, 7, 15 + FuTuHeight_WA * i + 30);
                                g.DrawLine(Pens.Black, 0, FuTuHeight_WA * (i + 1), panel_W_A.Width, FuTuHeight_WA * (i + 1));
                            }
                        }
                        //LPJ 2012-9-27 修改——end
                    }
                }
            }
        }

        private void radioButtonWhole_WA_CheckedChanged(object sender, EventArgs e)
        {
            tabPage32.Refresh();
            pictureBox_W_A.Refresh();
        }

        private void radioButtonPart_WA_CheckedChanged(object sender, EventArgs e)
        {
            tabPage32.Refresh();
            pictureBox_W_A.Refresh();
        }

        private bool bPlaybackStop = false;  //LPJ 2013-11-19 当鼠标暂停回放时，进行鼠标滑动或拖动动作后，回放会继续进行，因此设置一个变量，用于判断是否已经暂停，如果暂停，则在以上操作完成后，不开始，如果未暂停，则结束后继续开始
        private void buttonPause_Click(object sender, EventArgs e)
        {
            if (playBackMode)
            {
                if (PlayBackPauseFlag = !PlayBackPauseFlag)
                {
                    PlayBackTimer.Elapsed -= new System.Timers.ElapsedEventHandler(PlayBackCenter);
                    PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter); //LPJ 2013-9-24 重新将计时器与函数关联
                    PlayBackTimer.Interval = PlayBackTimeLenth; //LPJ 2013-9-24
                    PlayBackTimer.Stop();

                    bPlaybackStop = true; //LPJ 2013-11-19
                    try
                    {
                        //WriteToDataPage(RTIdata[BinDataEnsembleNum - 1]); //LPJ 2013-7-3
                        this.BeginInvoke(WriteToDataPageEvent, RTIdata[BinDataEnsembleNum - 1]); //LPJ 2014-3-11
                    }
                    catch
                    {
                    }
                }
                else
                {
                    if (BinDataEnsembleNum == EnsembleNumOfAllFiles) //LPJ 2013-9-18 当回放到达最后一个样本时，点击开始，则重新从第一个样本开始
                    {
                        BinDataEnsembleNum = 0;
                        //MouseWheelScale = 0.1f; //LPJ 2013-9-24 每次新开始一个测回，令航迹图的比例尺归为最小
                        MouseWheelScale = 1;
                    }

                    PlayBackTimer.Elapsed -= new System.Timers.ElapsedEventHandler(PlayBackCenter); //LPJ 2013-9-24 重新将计时器与函数关联
                    PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter); //LPJ 2013-9-24 重新将计时器与函数关联
                    PlayBackTimer.Interval = PlayBackTimeLenth; //LPJ 2013-9-24
                    PlayBackTimer.Start();

                    bPlaybackStop = false; //LPJ 2013-11-19
                }

                buttonPause.Text = PlayBackPauseFlag ? "▶" : "||";
            }
        }

        private void panel_W_C_Paint(object sender, PaintEventArgs e) //相关性
        {
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage35)
            {
                using (Graphics g = e.Graphics)
                {
                    using (Font ft = new Font("Arial", 8))
                    {
                        //if (radioButtonRealTime_WC.Checked)  //LPJ 2012-9-27 cancle
                        //{

                        //    for (int i = 0; i < 200; i++)
                        //    {
                        //        //g.DrawString("第", ft, Brushes.Black, 7, 15 + 80 * i);
                        //        //SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        //g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + 80 * i + 15);
                        //        //g.DrawString("层", ft, Brushes.Black, 7, 15 + 80 * i + 30);
                        //        //g.DrawLine(Pens.Black, 0, 80 * (i + 1), panel_W_A.Width, 80 * (i + 1));
                        //        SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, (FuTuHeight_WC - s.Height) / 2 + FuTuHeight_WC * i);
                        //        g.DrawLine(Pens.Black, 0, FuTuHeight_WC * (i + 1), panel_W_A.Width, FuTuHeight_WC * (i + 1));
                        //    }
                        //}
                        //else
                        //{
                        //    for (int i = 0; i < 200; i++)
                        //    {
                        //       // g.DrawString("第", ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i);//LPJ 2012-4-20
                        //        g.DrawString(Resource1.String49, ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i);
                        //        SizeF s = g.MeasureString((i + 1).ToString(), ft);
                        //        g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + FuTuHeight_WC * i + 15);
                        //       // g.DrawString("层", ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i + 30);//LPJ 2012-4-20
                        //        g.DrawString(Resource1.String50, ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i + 30);
                        //        g.DrawLine(Pens.Black, 0, FuTuHeight_WC * (i + 1), panel_W_A.Width, FuTuHeight_WC * (i + 1));
                        //    }
                        //}

                        //LPJ 2012-9-27 start
                        if (radioButtonRealTime_WC.Checked)
                        {
                            for (int i = 0; i < cells; )
                            //for (int i = 0; i < 200; i++)
                            {
                                SizeF s = g.MeasureString((i + 1).ToString(), ft);
                                //g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, (FuTuHeight_WC - s.Height) / 2 + FuTuHeight_WC * i);
                                ////g.DrawLine(Pens.Black, 0, FuTuHeight_WC * (i + 1), panel_W_A.Width, FuTuHeight_WC * (i + 1));
                             
                                g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, (float)panel_W_C.Height / cells * i); //LPJ 2013-9-24 显示深度
                                //g.DrawLine(Pens.Black, 0, (float)panel_W_C.Height / (cells - 1) * (i + 1), 15 - s.Width / 2f, (float)panel_W_C.Height / (cells - 1) * (i + 1));   //副图中的层数的横线，这个可以去掉，只显示数字，或将其改为短线段
                                if (cells > 150)
                                    i += 8;
                                else if (cells > 100)
                                    i += 6;
                                else if (cells > 50)
                                    i += 4;
                                else
                                    i += 2;
                            }
                        }
                        else
                        {
                            for (int i = 0; i < cells; )
                            //for (int i = 0; i < 200; i++)
                            {
                                // g.DrawString("第", ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i);//LPJ 2012-4-20
                                g.DrawString(Resource1.String49, ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i);
                                SizeF s = g.MeasureString((i + 1).ToString(), ft);
                                g.DrawString((i + 1).ToString(), ft, Brushes.Black, 15 - s.Width / 2f, 15 + FuTuHeight_WC * i + 15);
                                // g.DrawString("层", ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i + 30);//LPJ 2012-4-20
                                g.DrawString(Resource1.String50, ft, Brushes.Black, 7, 15 + FuTuHeight_WC * i + 30);
                                g.DrawLine(Pens.Black, 0, FuTuHeight_WC * (i + 1), panel_W_C.Width, FuTuHeight_WC * (i + 1));
                            }
                        }
                        //LPJ 2012-9-27 end
                    }
                }
            }
        }

        private void pictureBox_W_C_MouseEnter(object sender, EventArgs e)
        {
            pictureBox_W_C.Focus();
        }

        private void pictureBox_W_C_Mousewheel(object sender, MouseEventArgs e)
        {
            if (e.Delta > 0)
            {
                if (vScrollBar_W_C.Value <= 100)
                    vScrollBar_W_C.Value = 0;
                else
                    vScrollBar_W_C.Value -= 100;
            }
            else
            {
                if (vScrollBar_W_C.Value >= 15900)
                    vScrollBar_W_C.Value = 16000;
                else
                    vScrollBar_W_C.Value += 100;
            }
            vScrollBar_W_C_Scroll(null, null);
        }

        private void vScrollBar_W_C_Scroll(object sender, ScrollEventArgs e)
        {
            pictureBox_W_C.Top = -vScrollBar_W_C.Value;
            panel_W_C.Top = -vScrollBar_W_C.Value;
        }

        private void tabPage35_Paint(object sender, PaintEventArgs e)//测流 副图 相关性
        {
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage35)
            {
                using (Graphics g = e.Graphics)
                {
                    using (Font ft = new Font("Arial", 8))
                    {
                        // LPJ 2012-9-27 取消颜色说明-——start
                        //g.DrawLine(Pens.Red, 10, 15, 35, 15); 
                        //SizeF s = g.MeasureString("Beam0", ft);
                        //g.DrawString("Beam0", ft, Brushes.Black, 40, 15 - s.Height / 2f); 

                        //g.DrawLine(Pens.LimeGreen, 90, 15, 115, 15);
                        //s = g.MeasureString("Beam1", ft);
                        //g.DrawString("Beam1", ft, Brushes.Black, 120, 15 - s.Height / 2f);

                        //g.DrawLine(Pens.Blue, 170, 15, 195, 15);
                        //s = g.MeasureString("Beam2", ft);
                        //g.DrawString("Beam2", ft, Brushes.Black, 200, 15 - s.Height / 2f);

                        //g.DrawLine(Pens.Magenta, 250, 15, 275, 15);
                        //s = g.MeasureString("Beam3", ft);
                        //g.DrawString("Beam3", ft, Brushes.Black, 280, 15 - s.Height / 2f);
                        // LPJ 2012-9-27 取消颜色说明-——end

                        //s = g.MeasureString("相关性", ft);
                        //g.DrawString("相关性", ft, Brushes.Black, 30 + pictureBox_W_C.Width / 2f - s.Width / 2f, 30); //LPJ 2012-4-20
                        SizeF s = g.MeasureString(Resource1.String56, ft);
                        //g.DrawString(Resource1.String56, ft, Brushes.Black, 30 + pictureBox_W_C.Width / 2f - s.Width / 2f, 30);
                        //g.DrawString(Resource1.String56, ft, Brushes.Black, 30 + pictureBox_W_C.Width / 2f - s.Width / 2f, 5); //LPJ 2012-9-27 将其上移 //LPJ 2012-9-27 取消“相关性”
                        if (true == radioButtonWhole_WC.Checked)
                        {
                            for (int i = 0; i <= 4; i++)
                            {
                                //g.DrawLine(Pens.Black, 30 + pictureBox1.Width / 4f * i, 58, 30 + pictureBox1.Width / 4f * i, 60);
                                SizeF s1 = g.MeasureString((0.25 * i).ToString(), ft);
                                //g.DrawString((0.25 * i).ToString(), ft, Brushes.Black, 30 + pictureBox_W_C.Width / 4f * i - s1.Width / 2f, 58 - s1.Height);
                                g.DrawString((0.25 * i).ToString(), ft, Brushes.Black, 25 + pictureBox_W_C.Width / 4f * i - s1.Width / 2f, 15 - s1.Height);  //LPJ 2012-9-27 将其上移
                            }

                        }
                        else
                        {
                            for (int i = 0; i <= 3; i++)
                            {
                                for (int j = 0; j <= 4; j++)
                                {
                                    //if (!(i != 0 && 0 == j))
                                    //{
                                    //    float x = 30 + pictureBox1.Width / 4f * i + pictureBox1.Width / 16f * j;
                                    //    SizeF s1 = g.MeasureString((500 * j).ToString(), ft);
                                    //    g.DrawString((500 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 58 - s1.Height);
                                    //}
                                    if ((0 == i && 0 == j) || (4 == j))
                                    {
                                        float x = 25 + pictureBox_W_C.Width / 4f * i + pictureBox_W_C.Width / 16f * j;
                                        SizeF s1 = g.MeasureString((0.25 * j).ToString(), ft);
                                        //g.DrawString((0.25 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 58 - s1.Height);
                                        g.DrawString((0.25 * j).ToString(), ft, Brushes.Black, x - s1.Width / 2f, 15 - s1.Height); //LPJ 2012-9-27 将其上移
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private void pictureBox_W_C_Paint(object sender, PaintEventArgs e)
        {
            if (tabControlFuTu.SelectedTab == tabPage_WP && tabControl_FuTu_WP.SelectedTab == tabPage35)
            {
                Graphics g = e.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                if (radioButtonWhole_WC.Checked)
                {
                    for (int i = 0; i <= 3; i++)
                    {
                        for (int j = 1; j <= 4; j++)
                        {
                            float x = pictureBox_W_C.Width / 4f * i + pictureBox_W_C.Width / 20f * j;
                            g.DrawLine(Pens.Gainsboro, x, 0, x, pictureBox_W_C.Height);
                        }
                        if (i != 0)
                            g.DrawLine(Pens.Gray, pictureBox_W_C.Width / 4f * i, 0, pictureBox_W_C.Width / 4f * i, pictureBox_W_C.Height);
                    }

                    //for (int i = 0; i <10;i++ ) //LPJ 2013-9-24 绘制横线
                    //{
                    //    g.DrawLine(Pens.LightGray, 0, (float)(pictureBox_W_C.Height - 1) / 10 * (i + 1), pictureBox_W_C.Width, (float)(pictureBox_W_C.Height - 1) / 10 * (i + 1));
                    //}
                }
                else
                {
                    for (int i = 0; i <= 3; i++)
                    {
                        for (int j = 1; j <= 3; j++)
                        {
                            float x = pictureBox_W_C.Width / 4f * i + pictureBox_W_C.Width / 16f * j;
                            g.DrawLine(Pens.Gainsboro, x, 0, x, pictureBox_W_C.Height);
                        }
                        if (i != 0)
                            g.DrawLine(Pens.Black, pictureBox_W_C.Width / 4f * i, 0, pictureBox_W_C.Width / 4f * i, pictureBox_W_C.Height);
                    }
                }
                if (arrCorrelation != null)
                {
                    //using (Graphics g = pictureBox1.CreateGraphics())
                    //{
                    int n = arrCorrelation.GetLength(1);//得到水单元层数
                    //PointF[] p0 = new PointF[2 * n];  //LPJ 2012-9-27 cancle
                    //PointF[] p1 = new PointF[2 * n];
                    //PointF[] p2 = new PointF[2 * n];
                    //PointF[] p3 = new PointF[2 * n];

                    PointF[] p0 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p1 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p2 = new PointF[n]; //LPJ 2012-9-27 change
                    PointF[] p3 = new PointF[n]; //LPJ 2012-9-27 change

                    if (radioButtonWhole_WC.Checked)
                    {
                        //if (checkBox_WC_b0.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p0[2 * i] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width, i * FuTuHeight_WC);
                        //        p0[2 * i + 1] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Red, p0);
                        //}
                        //if (checkBox_WC_b1.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p1[2 * i] = new PointF(arrCorrelation[1, i] * pictureBox_W_C.Width, i * FuTuHeight_WC);
                        //        p1[2 * i + 1] = new PointF(arrCorrelation[1, i] * pictureBox_W_C.Width, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.LimeGreen, p1);
                        //}
                        //if (checkBox_WC_b2.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p2[2 * i] = new PointF(arrCorrelation[2, i] * pictureBox_W_C.Width, i * FuTuHeight_WC);
                        //        p2[2 * i + 1] = new PointF(arrCorrelation[2, i] * pictureBox_W_C.Width, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Blue, p2);
                        //}
                        //if (checkBox_WC_b3.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p3[2 * i] = new PointF(arrCorrelation[3, i] * pictureBox_W_C.Width, i * FuTuHeight_WC);
                        //        p3[2 * i + 1] = new PointF(arrCorrelation[3, i] * pictureBox_W_C.Width, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Magenta, p3);
                        //}

                        //LPJ 2012-9-27 start
                        if (checkBox_WC_b0.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p0[i] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width, i * (float)pictureBox_W_A.Height / (cells - 1));

                            }
                            Pen RedPen = new Pen(Brushes.Red, 2);
                            g.DrawLines(RedPen, p0);
                        }
                        if (checkBox_WC_b1.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p1[i] = new PointF(arrCorrelation[1, i] * pictureBox_W_C.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen LimeGreenPen = new Pen(Brushes.LimeGreen, 2);
                            g.DrawLines(LimeGreenPen, p1);
                        }
                        if (checkBox_WC_b2.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p2[i] = new PointF(arrCorrelation[2, i] * pictureBox_W_C.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen BluePen = new Pen(Brushes.Blue, 2);
                            g.DrawLines(BluePen, p2);
                        }
                        if (checkBox_WC_b3.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p3[i] = new PointF(arrCorrelation[3, i] * pictureBox_W_C.Width, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen MagentaPen = new Pen(Brushes.Magenta, 2);
                            g.DrawLines(MagentaPen, p3);
                        }
                        //LPJ 2012-9-27 end
                    }
                    else
                    {
                        //if (checkBox_WC_b0.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p0[2 * i] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width / 4f, i * FuTuHeight_WC);
                        //        p0[2 * i + 1] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width / 4f, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Red, p0);
                        //}
                        //if (checkBox_WC_b1.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p1[2 * i] = new PointF((arrCorrelation[1, i] + 1) * pictureBox_W_C.Width / 4f, i * FuTuHeight_WC);
                        //        p1[2 * i + 1] = new PointF((arrCorrelation[1, i] + 1) * pictureBox_W_C.Width / 4f, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.LimeGreen, p1);
                        //}
                        //if (checkBox_WC_b2.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p2[2 * i] = new PointF((arrCorrelation[2, i] + 2) * pictureBox_W_C.Width / 4f, i * FuTuHeight_WC);
                        //        p2[2 * i + 1] = new PointF((arrCorrelation[2, i] + 2) * pictureBox_W_C.Width / 4f, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Blue, p2);
                        //}
                        //if (checkBox_WC_b3.Checked)
                        //{
                        //    for (int i = 0; i < n; i++)
                        //    {
                        //        p3[2 * i] = new PointF((arrCorrelation[3, i] + 3) * pictureBox_W_C.Width / 4f, i * FuTuHeight_WC);
                        //        p3[2 * i + 1] = new PointF((arrCorrelation[3, i] + 3) * pictureBox_W_C.Width / 4f, FuTuHeight_WC + i * FuTuHeight_WC);
                        //    }
                        //    g.DrawLines(Pens.Magenta, p3);
                        //}

                        //LPJ 2012-9-27 start
                        if (checkBox_WC_b0.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p0[i] = new PointF(arrCorrelation[0, i] * pictureBox_W_C.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen RedPen = new Pen(Brushes.Red, 2);
                            g.DrawLines(RedPen, p0);
                        }
                        if (checkBox_WC_b1.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p1[i] = new PointF((arrCorrelation[1, i] + 1) * pictureBox_W_C.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen LimeGreenPen = new Pen(Brushes.LimeGreen, 2);
                            g.DrawLines(LimeGreenPen, p1);
                        }
                        if (checkBox_WC_b2.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p2[i] = new PointF((arrCorrelation[2, i] + 2) * pictureBox_W_C.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen BluePen = new Pen(Brushes.Blue, 2);
                            g.DrawLines(BluePen, p2);
                        }
                        if (checkBox_WC_b3.Checked)
                        {
                            for (int i = 0; i < n; i++)
                            {
                                p3[i] = new PointF((arrCorrelation[3, i] + 3) * pictureBox_W_C.Width / 4f, i * (float)pictureBox_W_A.Height / (cells - 1));
                            }
                            Pen MagentaPen = new Pen(Brushes.Magenta, 2);
                            g.DrawLines(MagentaPen, p3);
                        }
                        //LPJ 2012-9-27 end
                    }
                    //}
                }
            }
        }

        private void radioButtonWhole_WC_CheckedChanged(object sender, EventArgs e)
        {
            tabPage35.Refresh();
            pictureBox_W_C.Refresh();
        }

        private void radioButtonPart_WC_CheckedChanged(object sender, EventArgs e)
        {
            tabPage35.Refresh();
            pictureBox_W_C.Refresh();
        }

        private void radioButtonRealTime_WA_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonRealTime_WA.Checked)
            {
                FuTuHeight_WA = 11;
            }
        }

        private void radioButtonHistory_WA_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonHistory_WA.Checked)
            {
                FuTuHeight_WA = 80;
            }
        }

        private void radioButtonRealTime_WC_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonRealTime_WC.Checked)
            {
                FuTuHeight_WC = 11;
            }
        }

        private void radioButtonHistory_WC_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonHistory_WC.Checked)
            {
                FuTuHeight_WC = 80;
            }
        }

        public static Image RotateImage(Image img, float RotationAngle)//顺时针旋转
        {
            //创建一个空的位图图像
            Bitmap bmp = new Bitmap(img.Width, img.Height);
            //转换为Graphics对象
            Graphics gfx = Graphics.FromImage(bmp);

            gfx.TranslateTransform(img.Width / 2, img.Height / 2);//gfx坐标系的原点定在gfx的中心点
            gfx.RotateTransform(RotationAngle);//gfx坐标系绕中心点旋转
            gfx.InterpolationMode = InterpolationMode.HighQualityBicubic;//双三次插值法，得到高质量图像
            gfx.SmoothingMode = SmoothingMode.HighQuality; //高质量
            gfx.PixelOffsetMode = PixelOffsetMode.HighQuality; //高像素偏移质量
            //gfx.DrawImage(img, new Point(img.Width, img.Height));
            gfx.DrawImage(img, new Point(-img.Width / 2, -img.Height / 2));//在gfx坐标系的原点画img图像

            gfx.Dispose();
            return bmp;
        }

        private void HPRpictureBox_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            float H, P, R;
            try
            {
                H = float.Parse(current_WPHeading);
                P = float.Parse(current_WPPitch);
                R = float.Parse(current_WPRoll);
            }
            catch
            {
                H = 0;
                P = 0;
                R = 0;
            }
            Bitmap r_headingBitmap = (Bitmap)RotateImage(headingBitmap, H);
           // g.DrawImage(r_headingBitmap, (HPRDisplayerPanel.Width - 61) / 2, 5);
            g.DrawImage(r_headingBitmap, 31, 5);
            Bitmap r_pitchBitmap = (Bitmap)RotateImage(pitchBitmap, P);
            g.DrawImage(r_pitchBitmap, 0, HPRDisplayerPanel.Height / 2 - 4);
            Bitmap r_rollBitmap = (Bitmap)RotateImage(rollBitmap, R);
           // g.DrawImage(r_rollBitmap, HPRDisplayerPanel.Width / 2, HPRDisplayerPanel.Height / 2 - 4);
            g.DrawImage(r_rollBitmap, 63, HPRDisplayerPanel.Height / 2 - 4);
        }

        //Modified 2011-7-12 add scroll bar to change palayback speed
        int minimumPlaybackTime = 100;
        //int maximumPlaybackTime = 10000;
        int maximumPlaybackTime = 3000;//Modified 2011-11-28

     
        private void checkBoxGPSCompass_CheckedChanged(object sender, EventArgs e)
        {
           
        }

        bool TrueNorth = false;

        private void checkBoxCompass_CheckedChanged(object sender, EventArgs e)
        {
            if (TrueNorth)
            {
                //labelTextTrueNorth.Show(); //LPJ 2013-5-25 cancle
                //labelTrueNorth.Show();
            }
            else
            {
                //labelTextTrueNorth.Hide();
                //labelTrueNorth.Hide();
            }
            initialGPSData();
        }

      
        //private float SailTrackMaxDisplayWidth; //Modified 2011-11-15 cancel
        //private float SailTrackMaxDisplayHeight;
        private float SailTrackCurrentDisplayUnit;
        private float SailTrackCurrentDisplayTop;
        private float SailTrackCurrentDisplayLeft;
        private float SailTrackMultiple; //Modified 2011-11-15 cancel
        private float SailTrackPreviousMultiple = 1;//上一次刷新后客户区所处于的倍数//Modified 2011-11-15 cancel
        private float SailTrackDragLengthX = 0;
        private float SailTrackDragLengthY = 0;
        private float SailTrackMouseWheelScale = 1;//滚轮缩小率的初始值
        //private float SailTrackXpzn = 0;
        //private float SailTrackYpzn = 0;//初始中心点经纬度
        //private int SailTrackLinesNumOfAllFiles;
        //private Bitmap SailTrackBoatBitmap, SailTrackRotatedBoatBitmap;
        private PointF SailTrackBoatPosition = new PointF(0, 0);
        private PointF SailTrackDragEndPoint;
        //private PointF SailTrackMousePosion;
        //private bool SailTrackLightFlag = false;
        Rectangle SailTrackDisplayRec;
        //private float SailTrackMaxDepth = 500;
        //private float BoatHeight;
        float panelWidth = 0;
        float panelHeight = 0;
        //int saveGPSdataCount = 0;
        //int littleNum2; //Modified 2011-9-17  //JZH 2011-12-29 取消该变量 该变量是为计算500个点的EnsemblesInfoToStore的限制设置的
        int GPSdisplayStartPoint = 0;
        //static int GPSdisplayLength = 500;     //JZH 2011-12-29  
        int GPSdisplayLength = 5000;
        //Modified 2011-11-11
        //double leftLongitudeOfDisplayArea;
        //double rightLongitudeOfDisplayArea;
        //double topLatitudeOfDisplayArea;
        //double bottomLatitudeOfDisplayArea;
        double topLatitudeOfDisplayArea = 0; //SailTrackCurrentDisplayTop;
        double bottomLatitudeOfDisplayArea = 609; //SailTrackCurrentDisplayTop + panelHeight;
        double leftLongitudeOfDisplayArea = 0; //(double)SailTrackCurrentDisplayLeft;
        double rightLongitudeOfDisplayArea = 772; //(double)SailTrackCurrentDisplayTop;


        private void GPSdisplayPanel_Paint(object sender, PaintEventArgs e)
        {
            try
            {
                panelWidth = GPSdisplayPanel.ClientSize.Width - GPScontrolPanel.ClientSize.Width;
                panelHeight = GPSdisplayPanel.ClientSize.Height - GPSdepthPanel.ClientSize.Height;

                //Bitmap SailTrackBitmap = new Bitmap(Application.StartupPath + "\\Resources\\Bitmap1.bmp"); //LPJ 2013-6-11

                Bitmap SailTrackBitmap = new Bitmap(pictureBox5.Image); //LPJ 2013-6-11
                //  SailTrackBitmap.MakeTransparent(Color.Black);

                //SailTrackMaxDisplayWidth = 985; // panelWidth; //DVLpanel.Width;//Modified 2011-11-15 cancel
                //SailTrackMaxDisplayHeight = panelHeight;
                SailTrackDisplayRec.Width = (int)panelWidth;   // GPSdisplayPanel.Width - GPScontrolPanel.Width; // panelWidth;
                SailTrackDisplayRec.Height = (int)panelHeight; // GPSdisplayPanel.Height;

                SailTrackCurrentDisplayUnit = (float)panelWidth / 8;

                SailTrackCurrentDisplayTop = GPSdisplayPanel.ClientRectangle.Top;
                SailTrackCurrentDisplayLeft = GPSdisplayPanel.ClientRectangle.Left;
                SailTrackMultiple = 1; // (float)panelWidth / (float)SailTrackMaxDisplayWidth;//设置随窗口大小的改变绘图区缩放的倍数 //Modified 2011-11-15 cancel
                //SailTrackMultiple = (float)panelWidth / (float)SailTrackMaxDisplayWidth;//设置随窗口大小的改变绘图区缩放的倍数 //Modified 2011-11-15 cancel

                //拖动积累量 //Modified 2011-11-15 comment out
                SailTrackDragLengthX *= (SailTrackMultiple / SailTrackPreviousMultiple);//改变窗口大小后，相应更新拖动积累量的值//Modified 2011-11-15 cancel
                SailTrackDragLengthY *= (SailTrackMultiple / SailTrackPreviousMultiple);//Modified 2011-11-15 cancel
                SailTrackPreviousMultiple = SailTrackMultiple;//Modified 2011-11-15 cancel

                //Modified 2011-11-22, fix Lat Long origing to center display
                if (displayLatLong)
                {
                    SailTrackDragLengthX = 0;
                    SailTrackDragLengthY = 0;
                }
                /////////////////////////////         //////////////////////////////
                /////////////////////////////双缓冲绘图//////////////////////////////
                /////////////////////////////         //////////////////////////////

                BufferedGraphicsContext SailTrackcurrentContext = BufferedGraphicsManager.Current;//获取当前绘图主缓冲区上下文
                BufferedGraphics SailTrackMainBuffer = SailTrackcurrentContext.Allocate(e.Graphics, SailTrackDisplayRec);
                //设置双缓冲的图形缓冲区：使用指定的e.Graphics像素格式，创建指定大小SailTrackDisplayRec的图形缓冲区

                using (Graphics g1 = SailTrackMainBuffer.Graphics)
                {
                    //SolidBrush brush1 = new SolidBrush(Color.FromArgb(255, Color.Azure));  //LPJ 2013-5-15
                    SolidBrush brush1 = new SolidBrush(Color.FromArgb(255, Color.White));

                    g1.FillRectangle(brush1, GPSdisplayPanel.Left, GPSdisplayPanel.Top, panelWidth, panelHeight);

                    //g1.DrawImage(SailTrackBitmap, 10, 17); //draw North arrow
                    g1.DrawImage(SailTrackBitmap, 10, 17, 25, 25); //LPJ 2013-6-25

                    //LPJ 2012-8-10 移到此处--start
                    Point StartUTMPoint = new Point(0, 0);

                    if (!playBackMode)
                    {
                        if (UTMpointSave.Count() < 1)
                            return;
                        StartUTMPoint = UTMpointSave[0];
                        if (UTMpointSave.Count() > StartPoint + 1)   //LPJ 2012-8-10 判断当前UTMpointSave个数
                            StartUTMPoint = UTMpointSave[StartPoint];  //LPJ 2012-8-7 修改
                        /*  for (int id = 0; id < UTMpointSave.Count() - 1; id++)  //LPJ 2012-8-10 当开始没有接收到GPS坐标时，UTM坐标为0，在接收到GPS坐标之后，坐标值不为0，则需要重新绘制UTM格网
                          {
                              if (Math.Abs(UTMpointSave[id].X - 0) > 1e-2 && Math.Abs(UTMpointSave[id].Y - 0) > 1e-2)
                              //if (Math.Abs(UTMpointSave[id].X - UTMpointSave[id + 1].X) > 1e4 || Math.Abs(UTMpointSave[id].Y - UTMpointSave[id + 1].Y) > 1e4)
                              {
                                  StartUTMPoint = UTMpointSave[id];
                                  break;
                              }
                          }*/
                    }
                    else
                    {
                        //if (EnsemblesInfoToStore.UTMpoint.Count < 1)
                        //    return;

                        try
                        {
                            StartUTMPoint = (Point)EnsemblesInfoToStore.UTMpoint[0];
                            if (EnsemblesInfoToStore.UTMpoint.Count > GPSdisplayStartPoint + 1) //LPJ 2012-8-10 判断当前EnsemblesInfoToStore个数
                                StartUTMPoint = (Point)EnsemblesInfoToStore.UTMpoint[GPSdisplayStartPoint];

                            radioButtonLatLong.Enabled = true;
                            radioButtonMotoke.Enabled = true;
                        }
                        catch
                        {
                            radioButtonLatLong.Enabled = false;
                            radioButtonMotoke.Enabled = false;

                            StartUTMPoint.X = 0;
                            StartUTMPoint.Y = 0;
                        }
                    }

                    //LPJ 2012-8-10 移到此处--end

                    using (Pen GreenPen = new Pen(Color.LimeGreen, 1))
                    {
                        using (Font font = new Font("Arial", 8))//画中心经纬度及距离标值所用字体
                        {
                            //鼠标在边缘或手动移动时，画面水平移动距离除以单位刻度的商,代表的是画面流过的线条个数
                            int nX = (int)(SailTrackDragLengthX) / (int)SailTrackCurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面水平移动距离除以单位刻度的余数，代表的是尚未产生最新线条时已经流过的距离
                            int lX = (int)(SailTrackDragLengthX) % (int)SailTrackCurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面竖直移动距离除以单位刻度的商
                            int nY = (int)(SailTrackDragLengthY) / (int)SailTrackCurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面竖直移动距离除以单位刻度的余数
                            int lY = (int)(SailTrackDragLengthY) % (int)SailTrackCurrentDisplayUnit;
                            //DebugMSGtextBox.AppendText("\r\nnX, 1X, nY, 1Y: " + nX.ToString() + ", " + lX.ToString() + ", " + nY.ToString() + ", " + lY.ToString());

                            bool DrawOrignX = false;
                            float OrignX = 0;

                            for (int i = 0; i <= 8; i++)//画竖线
                            {
                                //由顶端到低端，依次向下画横线，如果检测到画线的位置已经超出了显示区下端，则结束本次画面绘制
                                if (lX + SailTrackCurrentDisplayUnit * i > panelWidth)
                                {
                                    break;
                                }

                                //float NumX = 50 * (i - 4 - nX) * SailTrackMouseWheelScale;
                                //float NumX = 100 * (i - 4 - nX) * SailTrackMouseWheelScale; //Modified 2011-11-18, change scale line  //JZH 2012-04-17 
                                //float NumX = 10 * (i - 4 - nX) * SailTrackMouseWheelScale;    //JZH 2012-04-17 改变比例尺大小
                                float NumX = 1 * (i - 4 - nX) * SailTrackMouseWheelScale;  

                                string NumXStr = NumX.ToString();
                                SizeF NumXSize = g1.MeasureString(NumXStr, font);
                                float NumXLength = NumXSize.Width;//字符串长度（像素）
                                //标定横坐标
                                //if (displayUTM ) 
                                //if (displayUTM || displayBtmTrack) //JZH 2012-01-31   //LPJ 2012-8-2 取消
                                if (displayBtmTrack) //LPJ 2012-8-2 修改
                                {
                                    g1.DrawString(NumXStr, font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i - NumXLength / 2,
                                        SailTrackCurrentDisplayTop);
                                }
                                else if (displayUTM) //LPJ 2012-8-2  增加，UTM坐标的范围与底跟踪的范围不同  --start  
                                {
                                    string startUTM = "";
                                    //    Point StartUTMPoint = (Point)EnsemblesInfoToStore.UTMpoint[0];   //LPJ 2012-8-7 bug,当开始测量后EnsemblesInfoToStore.UTMpoint.count=0;
                                    //Point StartUTMPoint = UTMpointSave[StartPoint];  //LPJ 2012-8-7 修改 LPJ 2012-8-10 移到循环外部
                                    //for (int id = 0; id < UTMpointSave.Count()-1; id++)  //LPJ 2012-8-10 当开始没有接收到GPS坐标时，UTM坐标为0，在接收到GPS坐标之后，坐标值不为0，则需要重新绘制UTM格网
                                    //{
                                    //    if (Math.Abs(UTMpointSave[id].X - UTMpointSave[id + 1].X) > 1e4 || Math.Abs(UTMpointSave[id].Y - UTMpointSave[id + 1].Y) > 1e4)
                                    //    {
                                    //        StartUTMPoint = UTMpointSave[id+1];
                                    //        break;
                                    //    }
                                    //}
                                    startUTM = (string)(StartUTMPoint.Y + (i - 4 - nX) * 1 * SailTrackMouseWheelScale).ToString();
                                    //startUTM = (string)(StartUTMPoint.Y + (i - 4 - nX) * 10 * SailTrackMouseWheelScale).ToString();  //LPJ 2012-8-21 当移动UTM格网时，坐标显示不正确
                                    //startUTM = (string)(StartUTMPoint.Y + (i - 4) * 10 * SailTrackMouseWheelScale).ToString();
                                    g1.DrawString(startUTM, font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i - NumXLength / 2,
                                        SailTrackCurrentDisplayTop);   //LPJ 2012-8-2 修改X、Y坐标，显示时是X与Y坐标互换
                                }  //LPJ 2012-8-2  增加，UTM坐标的范围与底跟踪的范围不同  --end 
                                else
                                {
                                    //Modified 2011-11-11, draw longitude vertically
                                    //LongitudeName = StartLongitudeText[i];
                                    StringFormat drawFormat = new StringFormat();
                                    drawFormat.FormatFlags = StringFormatFlags.DirectionVertical;
                                    g1.DrawString(StartLongitudeText[i], font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i - NumXLength / 2,
                                        SailTrackCurrentDisplayTop,
                                        drawFormat);

                                }
                                if (i == nX + 4)  //纵轴线:nX==0,即第四根线；nX==1，即第五根线，... ...
                                {
                                    //标出经度值 
                                    DrawOrignX = true;
                                    OrignX = SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i;
                                    //if (displayUTM)
                                    {
                                        //g1.DrawString(SailTrackXpzn.ToString() + 'E', font, Brushes.SkyBlue,
                                        //    OrignX, SailTrackCurrentDisplayTop + panelHeight - font.Height);
                                        g1.DrawString("S", font, Brushes.Blue,
                                            OrignX, SailTrackCurrentDisplayTop + panelHeight - 1.5f * font.Height);
                                    }

                                    //VerticalFont
                                    GreenPen.DashStyle = DashStyle.Solid;  //实线
                                }
                                else
                                {
                                    GreenPen.DashStyle = DashStyle.Dot;    //点线形式
                                }

                                //画竖线
                                g1.DrawLine(GreenPen,
                                    SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i, SailTrackCurrentDisplayTop,
                                    SailTrackCurrentDisplayLeft + lX + SailTrackCurrentDisplayUnit * i, SailTrackCurrentDisplayTop + panelHeight);
                            }

                            //绘图区中心线两侧所显示的的线条个数
                            int SideHNum = (int)(panelHeight / SailTrackCurrentDisplayUnit) / 2;
                            //使初始绘图区中心始终为纵横两条线的交点
                            int AllHNum = 2 * SideHNum + 1;
                            //上侧最后一条横线到绘图区顶端之间的距离
                            float SmallHeight = SailTrackCurrentDisplayTop + panelHeight / 2 - SideHNum * SailTrackCurrentDisplayUnit;

                            bool DrawOrignY = false;
                            float OrignY = 0;
                            //画横线，使初始绘图区中心始终为纵横两条线的交点
                            for (int j = 0; j <= AllHNum; j++)
                            {
                                //由顶端到低端，依次向下画横线，如果检测到画线的位置已经超出了显示区下端，则结束本次画面绘制
                                if (lY + SmallHeight + SailTrackCurrentDisplayUnit * j > panelHeight)
                                {
                                    break;
                                }

                                //float NumY = 50 * (j - SideHNum - nY) * SailTrackMouseWheelScale;
                                //float NumY = 100 * (j - SideHNum - nY) * SailTrackMouseWheelScale; //Modified 2011-11-18, change scale line  //JZH 2012-04-17
                                //float NumY = 10 * (j - SideHNum - nY) * SailTrackMouseWheelScale;    //JZH 2012-04-17 改变比例尺大小
                                float NumY = 1 * (j - SideHNum - nY) * SailTrackMouseWheelScale;   

                                //Modified 2011-11-21, negate X asix mark. When Mr Qi start the program, he set the X for North pointing right, and Y for East pointing down
                                NumY *= -1;
                                string NumYStr = NumY.ToString();
                                SizeF NumYSize = g1.MeasureString(NumYStr, font);
                                float NumYHeight = NumYSize.Height;
                                //标定纵坐标
                                //if (displayUTM)
                                //if (displayUTM || displayBtmTrack) //JZH 2012-01-31   //LPJ 2012-8-2 cancle
                                if (displayBtmTrack)  //LPJ 2012-7-2 修改 
                                {
                                    g1.DrawString(NumYStr, font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight + SailTrackCurrentDisplayUnit * j - NumYHeight / 2);
                                }
                                else if (displayUTM) //LPJ 2012-8-2 增加，UTM格网坐标显示 --start 
                                {
                                    string startUTM = "";
                                    //Point StartUTMPoint = (Point)EnsemblesInfoToStore.UTMpoint[0]; //LPJ 2012-8-7 bug
                                    //Point StartUTMPoint = UTMpointSave[StartPoint];  //LPJ 2012-8-7 修改 LPJ 2012-8-10 移到循环外部
                                    startUTM = (string)(StartUTMPoint.X - (j - (AllHNum - 1) / 2 - nY) * 1 * SailTrackMouseWheelScale).ToString();
                                    //startUTM = (string)(StartUTMPoint.X - (j - (AllHNum - 1) / 2 - nY) * 10 * SailTrackMouseWheelScale).ToString();  //LPJ 2012-8-21 
                                    //startUTM = (string)(StartUTMPoint.X - (j - (AllHNum - 1) / 2) * 10 * SailTrackMouseWheelScale).ToString(); 
                                    g1.DrawString(startUTM, font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight + SailTrackCurrentDisplayUnit * j - NumYHeight / 2);
                                }//LPJ 2012-8-2 增加 --end
                                else
                                {
                                    g1.DrawString(StartLatitudeText[j], font, Brushes.Gray,
                                        SailTrackCurrentDisplayLeft,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight + SailTrackCurrentDisplayUnit * j - NumYHeight / 2);
                                }
                                if (j == nY + SideHNum) //横轴线
                                {
                                    //画纬度值:
                                    //SizeF size = g1.MeasureString(SailTrackYpzn.ToString() + 'N', font);
                                    SizeF size = g1.MeasureString("E", font);
                                    float length = size.Width;
                                    DrawOrignY = true;
                                    OrignY = SailTrackCurrentDisplayTop + lY + SmallHeight + SailTrackCurrentDisplayUnit * j;

                                    //g1.DrawString(SailTrackYpzn.ToString() + 'N', font, Brushes.SkyBlue,
                                    //    SailTrackCurrentDisplayLeft + panelWidth - length, OrignY);
                                    g1.DrawString("E", font, Brushes.Blue,
                                        SailTrackCurrentDisplayLeft + panelWidth - length, OrignY);

                                    GreenPen.DashStyle = DashStyle.Solid;  //实线
                                }
                                else
                                {
                                    GreenPen.DashStyle = DashStyle.Dot;    //点线形式
                                }

                                //画横线
                                g1.DrawLine(GreenPen,
                                        SailTrackCurrentDisplayLeft,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight + SailTrackCurrentDisplayUnit * j,
                                        SailTrackCurrentDisplayLeft + panelWidth,
                                        SailTrackCurrentDisplayTop + SmallHeight + lY + SailTrackCurrentDisplayUnit * j);
                            }
                            if (DrawOrignX && DrawOrignY)
                            {
                                g1.FillEllipse(Brushes.GreenYellow, OrignX - 3f, OrignY - 3f, 6f, 6f);
                            }

                            //由于每次都是从（CurrentDisplayTop+SmallHeight）处开始往下绘制画横线，
                            //故要补充绘制（CurrentDisplayTop+SmallHeight）以上的部分：
                            if (lY + SmallHeight >= SailTrackCurrentDisplayUnit)
                            {
                                //准备画的线是标定为0的那根线向上数第(SideHNum + (nY+1))根
                                //float NumY = 50 * (0 - SideHNum - nY - 1) * SailTrackMouseWheelScale;
                                float NumY = 100 * (0 - SideHNum - nY - 1) * SailTrackMouseWheelScale;
                                string NumYStr = NumY.ToString();
                                SizeF NumYSize = g1.MeasureString(NumYStr, font);
                                float NumYHeight = NumYSize.Height;
                                //标定纵坐标
                                g1.DrawString(NumYStr, font, Brushes.LightGray,
                                    SailTrackCurrentDisplayLeft,
                                    SailTrackCurrentDisplayTop + lY + SmallHeight - SailTrackCurrentDisplayUnit - NumYHeight / 2);
                                //画横线
                                g1.DrawLine(GreenPen,
                                        SailTrackCurrentDisplayLeft,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight - SailTrackCurrentDisplayUnit,
                                        SailTrackCurrentDisplayLeft + panelWidth,
                                        SailTrackCurrentDisplayTop + lY + SmallHeight - SailTrackCurrentDisplayUnit);
                            }
                        }
                    }
                    //Modified 2011-12-2, testx
                    //SailTrackMainBuffer.Render(e.Graphics);
                    //SailTrackMainBuffer.Dispose();
                    //return;

                    //float scaleFactor = SailTrackMultiple / SailTrackMouseWheelScale; //Modified 2011-11-15 add
                    float scaleFactor = SailTrackMouseWheelScale / SailTrackMultiple;
                    //Modified 2011-11-15, Reading, translate x, y origin to center of screen of gragged new center
                    Matrix SailTrackmatrix = new Matrix();//定义一个做几何变换的对象

                    SailTrackmatrix.Translate((float)panelWidth / 2 + SailTrackDragLengthX, (float)panelHeight / 2 + SailTrackDragLengthY);//缩放中心设为绘图区中心
                    //SailTrackmatrix.Scale(SailTrackMultiple / SailTrackMouseWheelScale, SailTrackMultiple / SailTrackMouseWheelScale);
                    SailTrackmatrix.Scale(1 / scaleFactor, 1 / scaleFactor);
                    g1.Transform = SailTrackmatrix;//Modified 2011-11-15 cancel
                    PointF SailTrackMapBoatPzn = SailTrackTansToMapPoint(SailTrackBoatPosition);//Modified 2011-11-15 cancel

                    //int GPSdataCount = 0;

                    //GPSdataCount = EnsemblesInfoToStore.GPS_GGAbuffer.Count;  //Modified 2011-9-2

                    if (playBackMode)
                    {
                        GPSdataCount = BinDataEnsembleNum;   //Modified 2011-9-13
                    }
                    else
                    {
                        GPSdataCount = totalNum;
                    }

                    if (GPSdataCount == 0)//Modified 2011-11-15 cancel
                    {
                        SailTrackMapBoatPzn.X = 0;//Modified 2011-11-15 cancel
                        SailTrackMapBoatPzn.Y = 0;//Modified 2011-11-15 cancel
                    }
                    else//Modified 2011-11-15 cancel
                    {
                        SailTrackMapBoatPzn.X = currentX;//Modified 2011-11-15 cancel
                        SailTrackMapBoatPzn.Y = currentY;//Modified 2011-11-15 cancel
                    }
                    ////Modified 2011-9-1 end test

                    //float XX, YY;//Modified 2011-11-15 cancel
                    int progressValue = 0;

                    ////Modified 2011-10-26 draw two circles in center
                    //if (displayUTM)
                    {
                        g1.FillEllipse(Brushes.Red, -8 * SailTrackMouseWheelScale, -8 * SailTrackMouseWheelScale,
                            16 * SailTrackMouseWheelScale, 16 * SailTrackMouseWheelScale);
                        g1.FillEllipse(Brushes.Yellow, -4 * SailTrackMouseWheelScale, -4 * SailTrackMouseWheelScale,
                            8 * SailTrackMouseWheelScale, 8 * SailTrackMouseWheelScale);
                        //g1.FillEllipse(Brushes.Red, -8, -8, 16, 16 );
                        //g1.FillEllipse(Brushes.Yellow, -4, -4, 8, 8);
                    }

                    if (TrackStop)
                    {
                        ComputeXYposition((string)GGAsave[GGAsaveCount - 1]);  //playback and record

                        if (playBackMode)
                        {
                            //  DebugMSGtextBox.Text = "当前点/总点数： " + BinDataEnsembleNum.ToString() + " / " + EnsembleNumOfAllFiles.ToString(); //LPJ 2012-4-20
                            //DebugMSGtextBox.Text = Resource1.String58 + BinDataEnsembleNum.ToString() + " / " + EnsembleNumOfAllFiles.ToString();

                            progressValue = (int)(((float)BinDataEnsembleNum / (float)EnsembleNumOfAllFiles) * 100);

                            if (progressValue >= 96) progressValue = 96;
                            progressBarGPSTrack.Value = progressValue; //Modified 2011-9-13
                            //progressBarGPSTrack.Value = （int)（progressBarGPSTrack.Width * BinDataEnsembleNum / EnsembleNumOfAllFiles);
                            displayprocessbar(4, progressBarGPSTrack);
                        }
                        else
                        {
                            // DebugMSGtextBox.Text = "当前点： " + BinDataEnsembleNum.ToString(); // + " / " + EnsembleNumOfAllFiles.ToString();//LPJ 2012-4-20
                            //DebugMSGtextBox.Text = Resource1.String59 + BinDataEnsembleNum.ToString(); // + " / " + EnsembleNumOfAllFiles.ToString();

                        }

                        SailTrackMainBuffer.Render(e.Graphics);
                        SailTrackMainBuffer.Dispose();
                        return;
                    }

                    //Modified 2011-9-24 here
                    PointF PtStart = new PointF(0, 0);
                    PointF tempP = new PointF(0, 0); ;
                    PointF VP = new PointF(0, 0);
                    Point saveLastPoint = new Point(0, 0);
                    //int testDiff = 0 ;
                    //int MaxDiff = 0;

                    if (GPSdataCount >= 2)
                    {
                        if (!playBackMode) //record mode
                        {
                            if (TrackPause)
                            {
                                GPSdataCount = PausePoint;
                            }

                            //Modified 2011-9-18 to prevent overrun
                            if (GPSdataCount < GGAsaveCount)
                            {
                                SailTrackMainBuffer.Render(e.Graphics);
                                SailTrackMainBuffer.Dispose();
                                return;
                            }

                            if (GGAsaveCount < GPSdisplayLength)
                            {
                                GPSdisplayStartPoint = 0;
                                PtStart.X = 0;
                                PtStart.Y = 0;
                            }
                            else
                            {
                                GPSdisplayStartPoint = GGAsaveCount - GPSdisplayLength;
                                PtStart = UTMpointSave[GPSdisplayStartPoint];
                                //StartLongitude = GPS_longitude; //Modified 2011-11-8
                            }

                            int PrevGoodEnsembleNoOffset = 0;  //JZH 2012-04-18  底跟踪前一个有效单元的偏移                     
                            bool GetFirstGoodEnsemble = true;  //JZH 2012-04-18  采集到第一个有效单元
                            float AccEast = 0; //JZH 2012-04-18  底跟踪东向累积量
                            float AccNorth = 0; //JZH 2012-04-18 底跟踪北向累积量
                            int PrevGoodEnsemblePos = 0; //JZH 2012-04-18 前一个底跟踪有效单元位置
                            float fLastSecond = 0;    //JZH 2012-06-14 上一个有效的Ensemble时间
                            for (int i = GPSdisplayStartPoint; i < GGAsaveCount; i++) //Modified 2011-9-17
                            {
                                if (displayLatLong) //LatLong
                                {
                                    // DebugMSGtextBox.Text = "已记录点数： " + GPSdataCount.ToString(); //LPJ 2012-4-20
                                    DebugMSGtextBox.Text = Resource1.String60 + GPSdataCount.ToString();

                                    Point ans = new Point(0, 0);

                                    //LPJ 2012-6-29 取消，此处进行判断是因为在i<10时，没有给出起始的GPS坐标，即绘图区的范围坐标值是没有的，在下面添加了对该时刻的GPS坐标是否为0的判断可以解决这个问题
                                    //if (i < 10) //此处的判断有什么作用？？？？？？？？？？？？？
                                    //{
                                    //    tempP.X = 0; // ans.X - panelWidth / 2;
                                    //    tempP.Y = 0; // ans.Y - panelHeight / 2;
                                    //}
                                    //else
                                    {
                                        if (System.Math.Abs(LatitudeSave[i]) < 0.001 || System.Math.Abs(LongitudeSave[i]) < 0.001)  //LPJ 2012-6-28 判断该时刻GPS坐标是否为0
                                            continue;//LPJ 2012-6-27

                                        //Modified 2011-11-15, get X, Y position from GPS data
                                        ans = PTFM.CurrentScreenPosition(
                                            (float)LatitudeSave[i],
                                            (float)LongitudeSave[i],
                                            UperLeftOfDisplayRectangle,
                                            LowerRightOfDisplayRectagle,
                                            leftLongitudeOfDisplayArea,
                                            rightLongitudeOfDisplayArea,
                                            topLatitudeOfDisplayArea,
                                            bottomLatitudeOfDisplayArea);

                                        //Modified 2011-11-14, $$$
                                        tempP.X = (ans.X - StartLatLongPosition.X) * scaleFactor;
                                        tempP.Y = (ans.Y - StartLatLongPosition.Y) * scaleFactor;
                                    }
                                }
                                else if (displayUTM) //UTM   //JZH 2012-04-18
                                {
                                    if (System.Math.Abs(UTMpointSave[i].X) < 0.001 || System.Math.Abs(UTMpointSave[i].Y) < 0.001)  //LPJ 2012-8-10 判断该时刻UTM坐标是否为0
                                        continue;

                                    UTMpoint = UTMpointSave[i]; //Modified 2011-9-27
                                    //float CurrentX = (float)((UTMpoint.X - StartUTMPoint.X) / 10.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 将UTM坐标转换为屏幕坐标
                                    //float CurrentY = (float)((UTMpoint.Y - StartUTMPoint.Y) / 10.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 

                                    float CurrentX = (float)((UTMpoint.X - StartUTMPoint.X) / 1.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 将UTM坐标转换为屏幕坐标
                                    float CurrentY = (float)((UTMpoint.Y - StartUTMPoint.Y) / 1.0) * SailTrackCurrentDisplayUnit; 

                                    tempP.Y = CurrentX;    //LPJ 2012-8-2
                                    tempP.X = CurrentY;    //LPJ 2012-8-2
                                    tempP.Y *= -1;

                                    //tempP.Y = UTMpoint.X; //Modified 2011-11-21 reverse X, Y  //LPJ 2012-8-2 取消
                                    //tempP.X = UTMpoint.Y;                                 //LPJ 2012-8-2 取消
                                    //tempP.Y *= -1;                                        //LPJ 2012-8-2 取消

                                    //saveLastPoint = UTMpoint;
                                    //  DebugMSGtextBox.Text = "已记录点数： " + GPSdataCount.ToString(); //LPJ 2012-4-20
                                    DebugMSGtextBox.Text = Resource1.String60 + GPSdataCount.ToString();
                                }
                                else  //JZH 2012-04-18
                                {
                                    if (i == 0)
                                    {
                                        UTMpoint.X = 0;  //
                                        UTMpoint.Y = 0;

                                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                        if ("GPS VTG" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                        }
                                        else if ("GPS GGA" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                            fBoatVx = 0;
                                            fBoatVy = 0;
                                        }

                                        if (Math.Abs( fBoatVx) > 20 || Math.Abs( fBoatVy) > 20)
                                        // if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                                        {
                                            //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                                            GetFirstGoodEnsemble = false;
                                        }
                                        else  //JZH 2012-06-14 改正导航航迹计算
                                        {
                                            GetFirstGoodEnsemble = true;
                                            fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[0];
                                            PrevGoodEnsemblePos = 0;
                                        }
                                    }
                                    else
                                    {
                                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                        float fBoatVx_Prev, fBoatVy_Prev;
                                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                        fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX;
                                        fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY;
                                        if ("GPS VTG" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VX;
                                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VY;
                                        }//LPJ 2013-7-31
                                        else if ("GPS GGA" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VX;
                                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VY;
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                            fBoatVx = 0;
                                            fBoatVy = 0;
                                            fBoatVx_Prev = 0;
                                            fBoatVy_Prev = 0;
                                        }

                                        if (Math.Abs( fBoatVx )< 20 && Math.Abs( fBoatVy) < 20)
                                        //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX < 20 && ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY < 20)
                                        {
                                            if (GetFirstGoodEnsemble)
                                            {
                                                //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);   //JZH 2012-06-14
                                                //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14

                                                float LEast = (1.0f) * 0.5f * (float)(fBoatVx_Prev + fBoatVx) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);   //JZH 2012-06-14
                                                float LNorth = (1.0f) * 0.5f * (float)(fBoatVy_Prev + fBoatVy) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14

                                                AccEast += LEast;
                                                AccNorth += LNorth;
                                                //JZH 2012-04-17 支持自动缩放
                                                //float fTransAccEast = AccEast / 10 * SailTrackCurrentDisplayUnit;
                                                //float fTransAccNorth = AccNorth / 10 * SailTrackCurrentDisplayUnit;

                                                float fTransAccEast = AccEast / 1 * SailTrackCurrentDisplayUnit;
                                                float fTransAccNorth = AccNorth / 1 * SailTrackCurrentDisplayUnit;

                                                UTMpoint.X = (int)fTransAccEast; //JZH 2012-04-17
                                                UTMpoint.Y = (int)fTransAccNorth;

                                                PrevGoodEnsembleNoOffset = 0;
                                                PrevGoodEnsemblePos = i;
                                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14

                                            }
                                            else
                                            {
                                                GetFirstGoodEnsemble = true;
                                                PrevGoodEnsemblePos = i;
                                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14
                                            }
                                        }
                                        else
                                        {
                                            PrevGoodEnsembleNoOffset++;

                                        }

                                    }
                                    tempP.X = UTMpoint.X;
                                    tempP.Y = UTMpoint.Y;
                                    tempP.Y *= -1;
                                }


                                //JZH 2011-01-05  暂时先计算平均流速， 以后直接在记录原始数据时候改正？
                                //float AverageVY = 0;
                                //float AverageVX = 0;
                                //float AverageDepth = 0;

                                if ((i % setAveragePoints) == 0 && i > setAveragePoints)
                                {
                                    //JZH 2012-01-05 计算平均流速
                                    float AVX = AverageVXsave[i];
                                    float AVY = AverageVYsave[i];

                                    if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        AVX = AverageVXsave_GPS[i];
                                        AVY = AverageVXsave_GPS[i];
                                    }
                                    else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        AVX = AverageVXsave_GPGGA[i];
                                        AVY = AverageVXsave_GPGGA[i];
                                    }
                                    else if (Resource1.String233 == labelVesselRef.Text)
                                    {
                                        AVX = AverageVXsave_Null[i];
                                        AVY = AverageVXsave_Null[i];
                                    }


                                    VP.Y = tempP.Y + AVY * setAverageScale;
                                    //Modified 2011-11-20, next three line to reverse VX

                                    //float AVX = AverageVX;  //JZH 2012-01-05
                                    //AVX *= -1;   //JZH 2012-07-13 取消，否则流速矢量棒东西方向会相反
                                    VP.X = tempP.X + AVX * setAverageScale; //(float)EnsemblesInfoToStore.VYstore[i] * setAverageScale;
                                    g1.DrawLine(Pens.Blue, tempP, VP); //SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition)));
                                }

                                g1.DrawLine(Pens.Red, PtStart, tempP); //SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition)));

                                PtStart = tempP; // SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition));
                            }
                            g1.FillEllipse(Brushes.Red, tempP.X - 4, tempP.Y - 4, 8 * SailTrackMouseWheelScale, 8 * SailTrackMouseWheelScale); //(-1 * originSize / 2) * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale);

                            //Modified 2011-11-17, addAuto zoom in
                            if (GPSautoSize)
                            {
                                if (displayLatLong) //LatLong
                                {
                                    CheckGPSAutoSize(LatitudeSave[GGAsaveCount - 1], LongitudeSave[GGAsaveCount - 1]);
                                    if (AdjustGPSautoSize)
                                    {
                                        SailTrackMouseWheelScale *= 2;
                                        setAverageScale *= 2;
                                        if (setAverageScale > 1000) setAverageScale = 1000;
                                        AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
                                        ComputeLatLongGridText(StartLatitude, StartLongitude);
                                    }
                                }
                                else //for UTM , add later
                                {
                                    CheckUTMAutoSize(UTMpointSave[GGAsaveCount - 1]);
                                }
                            }
                        }
                        else //playbackmode  //Modified 2011-11-27, try display every setAveragePoints
                        {
                            if (TrackOverPlay == true)
                            {
                                SailTrackMainBuffer.Render(e.Graphics);
                                SailTrackMainBuffer.Dispose();
                                return;
                            }
                            if (TrackPause)
                            {
                                GPSdataCount = PausePoint;
                            }


                            //JZH 2012-01-04 回放模式采用新的数据载入方法,为响应拖动条拖放,改写以下代码
                            //Modified 旧版代码

                            //JZH 2012-01-04 新版代码
                            if (BinDataEnsembleNum < GPSdisplayLength)
                            {
                                GPSdisplayStartPoint = 0;
                                PtStart.X = 0;
                                PtStart.Y = 0;
                            }
                            else
                            {
                                GPSdisplayStartPoint = BinDataEnsembleNum - GPSdisplayLength;
                                PtStart = (Point)EnsemblesInfoToStore.UTMpoint[GPSdisplayStartPoint];
                            }

                            //progressValue = (int)(((float)GGAsaveCount / (float)EnsembleNumOfAllFiles) * 100);
                            progressValue = (int)(((float)BinDataEnsembleNum / (float)EnsembleNumOfAllFiles) * 100);  //JZH 2011-01-04 
                            if (progressValue >= 96) progressValue = 96;
                            progressBarGPSTrack.Value = progressValue; //Modified 2011-9-13
                            displayprocessbar(4, progressBarGPSTrack);

                            //Modified 2011-10-28 $$
                            //for (int i = GPSdisplayStartPoint; i < GGAsaveCount; i++) //Modified 2011-9-17
                            int PrevGoodEnsembleNoOffset = 0;  //JZH 2012-01-31  底跟踪前一个有效单元的偏移
                            //int FirstGoodEnsembleNoOffset = 0;       //JZH 2012-01-31  底跟踪第一个有效单元偏移
                            bool GetFirstGoodEnsemble = true;  //JZH 2012-01-31  采集到第一个有效单元
                            float AccEast = 0; //JZH 2012-02-09  底跟踪东向累积量
                            float AccNorth = 0; //JZH 2012-02-09 底跟踪北向累积量
                            int PrevGoodEnsemblePos = 0; //JZH 2012-04-01 前一个底跟踪有效单元位置
                            float LastSecond = 0;

                            for (int i = GPSdisplayStartPoint; i < BinDataEnsembleNum; i++) //JZH 2012-01-04
                            {
                                //if ((i % setAveragePoints) == 0 && i > setAveragePoints) //Modified 2011-11-28    //JZH　2012-01-31 debug
                                {
                                    //DebugMSGtextBox.Text = Resource1.String58 + BinDataEnsembleNum.ToString() + " / " + EnsembleNumOfAllFiles.ToString();
                                    //DebugMSGtextBox.AppendText("\r\n" + Resource1.String61 + setPlaybackTimeLength.ToString() + "ms， " + Resource1.String62); //：" + ChangeTimerCounter.ToString() + "次");

                                    DebugMSGtextBox.Text = Resource1.String58 + BinDataEnsembleNum.ToString() + " / " + EnsembleNumOfAllFiles.ToString() +
                                        "\r\n" + Resource1.String61 + setPlaybackTimeLength.ToString() + "ms， " + Resource1.String62;

                                    if (displayLatLong) //LatLong //Modified 2011-11-11
                                    {
                                        if (System.Math.Abs(Convert.ToDouble(EnsemblesInfoToStore.GPS_latitude[i])) < 0.001 || System.Math.Abs(Convert.ToDouble(EnsemblesInfoToStore.GPS_longitude[i])) < 0.001)  //2012-6-27
                                            //break;
                                            continue;//LPJ2012-6-27

                                        //JZH 2012-01-04 新的获取当前点的方法
                                        if (i > 0) //JZH 2012-01-31 调试发现第一个经纬度值为0,变换后将导致溢出
                                        {
                                            Point ans = PTFM.CurrentScreenPosition(
                                                Convert.ToDouble(EnsemblesInfoToStore.GPS_latitude[i]),  //Lat, Long data get from ComputeCombinedWaterVilocity()
                                                Convert.ToDouble(EnsemblesInfoToStore.GPS_longitude[i]),  //JZH 注意EnsemblesInfoToStore.GPS_latitude/longitude该objecct为float类型,不能直接拆箱为(double)类型
                                                UperLeftOfDisplayRectangle,
                                                LowerRightOfDisplayRectagle,
                                                leftLongitudeOfDisplayArea,
                                                rightLongitudeOfDisplayArea,
                                                topLatitudeOfDisplayArea,
                                                bottomLatitudeOfDisplayArea);

                                            tempP.X = (ans.X - StartLatLongPosition.X) * scaleFactor;
                                            tempP.Y = (ans.Y - StartLatLongPosition.Y) * scaleFactor;
                                        }
                                    }
                                    else if (displayUTM) //UTM
                                    {
                                        //UTMpoint = UTMpointSave[i];
                                        if (System.Math.Abs(Convert.ToDouble(((Point)EnsemblesInfoToStore.UTMpoint[i]).X)) < 0.001 || System.Math.Abs(Convert.ToDouble(((Point)EnsemblesInfoToStore.UTMpoint[i]).Y)) < 0.001)  //2012-8-10                                       
                                            continue;

                                        UTMpoint = (Point)EnsemblesInfoToStore.UTMpoint[i];  //JZH 2011-01-04 cancel temp!!!!!!

                                        //float CurrentX = (float)((UTMpoint.X - StartUTMPoint.X) / 10.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 将UTM坐标转换为屏幕坐标
                                        //float CurrentY = (float)((UTMpoint.Y - StartUTMPoint.Y) / 10.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 

                                        float CurrentX = (float)((UTMpoint.X - StartUTMPoint.X) / 1.0) * SailTrackCurrentDisplayUnit; //LPJ 2012-8-2 将UTM坐标转换为屏幕坐标
                                        float CurrentY = (float)((UTMpoint.Y - StartUTMPoint.Y) / 1.0) * SailTrackCurrentDisplayUnit;

                                        tempP.Y = CurrentX;    //LPJ 2012-8-2
                                        tempP.X = CurrentY;    //LPJ 2012-8-2
                                        tempP.Y *= -1;

                                    }
                                    else   //BtmTrack 
                                    {
                                        //Test JZH 2012-01-31
                                        if (i == 0)
                                        {
                                            UTMpoint.X = 0;  //
                                            UTMpoint.Y = 0;

                                            float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                            if ("GPS VTG" == labelVesselRef.Text)
                                            {
                                                fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                                fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                            }//LPJ 2013-7-31
                                            else if ("GPS GGA" == labelVesselRef.Text)
                                            {
                                                fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                                fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                            }
                                            else if (Resource1.String233 == labelVesselRef.Text)
                                            {
                                                fBoatVx = 0;
                                                fBoatVy = 0;
                                            }

                                            if (Math.Abs( fBoatVx) > 20 || Math.Abs( fBoatVy )> 20)
                                            //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                                            {
                                                //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                                                GetFirstGoodEnsemble = false;
                                            }
                                            else  //JZH 2012-06-14 修正导航航迹计算
                                            {
                                                GetFirstGoodEnsemble = true;
                                                LastSecond = (float)EnsemblesInfoToStore.RecivedTime[0];
                                                PrevGoodEnsemblePos = 0;
                                            }
                                        }
                                        else
                                        {
                                            float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                            float fBoatVx_Prev, fBoatVy_Prev;
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX;
                                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY;
                                            if ("GPS VTG" == labelVesselRef.Text)
                                            {
                                                fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                                fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                                fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VX;
                                                fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VY;
                                            }//LPJ 2013-7-31
                                            if ("GPS GGA" == labelVesselRef.Text)
                                            {
                                                fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                                fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                                fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VX;
                                                fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VY;
                                            }
                                            else if (Resource1.String233 == labelVesselRef.Text)
                                            {
                                                fBoatVx = 0;
                                                fBoatVy = 0;
                                                fBoatVx_Prev = 0;
                                                fBoatVy_Prev = 0;
                                            }

                                            if (Math.Abs( fBoatVx) < 20 && Math.Abs( fBoatVy )< 20)
                                            //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX < 20 && ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY < 20)
                                            {
                                                if (GetFirstGoodEnsemble)
                                                {
                                                    //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * (float)EnsemblesInfoToStore.t[i];
                                                    //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * (float)EnsemblesInfoToStore.t[i];
                                                    //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * ((float)EnsemblesInfoToStore.RecivedTime[i] - LastSecond);  //JZH 2012-06-14
                                                    //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * ((float)EnsemblesInfoToStore.RecivedTime[i] - LastSecond);  //JZH 2012-06-14

                                                    float LEast = (1.0f) * 0.5f * (float)(fBoatVx_Prev + fBoatVx) * ((float)EnsemblesInfoToStore.RecivedTime[i] - LastSecond);  //JZH 2012-06-14
                                                    float LNorth = (1.0f) * 0.5f * (float)(fBoatVy_Prev + fBoatVy) * ((float)EnsemblesInfoToStore.RecivedTime[i] - LastSecond);  //JZH 2012-06-14

                                                    AccEast += LEast;
                                                    AccNorth += LNorth;
                                                    //JZH 2012-04-17 支持自动缩放
                                                    //float fTransAccEast = AccEast / 10 * SailTrackCurrentDisplayUnit;
                                                    //float fTransAccNorth = AccNorth / 10 * SailTrackCurrentDisplayUnit;

                                                    float fTransAccEast = AccEast / 1 * SailTrackCurrentDisplayUnit;
                                                    float fTransAccNorth = AccNorth / 1 * SailTrackCurrentDisplayUnit;
                                                    //UTMpoint.X = (int)AccEast;   //JZH 2012-04-17 
                                                    //UTMpoint.Y = (int)AccNorth;
                                                    UTMpoint.X = (int)fTransAccEast; //JZH 2012-04-17
                                                    UTMpoint.Y = (int)fTransAccNorth;

                                                    //UTMpoint.X = UTMpoint.X + (int)LEast;
                                                    //UTMpoint.Y = UTMpoint.Y + (int)LNorth;
                                                    //FirstGoodEnsembleNoOffset = 0;
                                                    PrevGoodEnsembleNoOffset = 0;
                                                    PrevGoodEnsemblePos = i;
                                                    LastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14

                                                }
                                                else
                                                {
                                                    //FirstGoodEnsembleNoOffset++;
                                                    GetFirstGoodEnsemble = true;
                                                    PrevGoodEnsemblePos = i;
                                                    LastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14
                                                }
                                            }
                                            else
                                            {
                                                PrevGoodEnsembleNoOffset++;

                                            }

                                        }
                                        //tempP.Y = UTMpoint.X; //Modified 2011-11-21 reverse X, Y
                                        //tempP.X = UTMpoint.Y;
                                        //tempP.Y *= -1;
                                        tempP.X = UTMpoint.X;
                                        tempP.Y = UTMpoint.Y;
                                        tempP.Y *= -1;


                                        //Test JZH 2012-01-31
                                    }
                                    //if ((i % setAveragePoints) == 0 && i > setAveragePoints) //Modified 2011-10-26 temporary take out //Modified 2011-11-28
                                    {
                                        //JZH 2011-01-05  暂时先计算平均流速， 以后直接在记录原始数据时候改正？
                                        float AverageVY = 0;
                                        float AverageVX = 0;
                                        //float AverageDepth = 0; //LPJ 2013-7-3

                                        ////JZH 2012-01-05 计算平均流速
                                        //CalculateAverageWaterSpeed(i, ref AverageVX, ref AverageVY, ref AverageDepth);

                                        AverageVX = fAverageX[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过
                                        AverageVY = fAverageY[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过

                                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                                        {
                                            AverageVX = fAverageX_GPS[i];
                                            AverageVY = fAverageY_GPS[i];
                                        }
                                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                                        {
                                            AverageVX = fAverageX_GPGGA[i];
                                            AverageVY = fAverageY_GPGGA[i];
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                            AverageVX = fAverageX_Null[i];
                                            AverageVY = fAverageY_Null[i];
                                        }

                                        VP.Y = tempP.Y - AverageVY * setAverageScale * SailTrackMouseWheelScale;  //LPJ 2013-6-9

                                        //Modified 2011-11-20, next three line to reverse VX
                                        //float AVX = AverageVXsave[i];
                                        //float AVX = (float)EnsemblesInfoToStore.VXstore[i];  //JZH 2012-01-04
                                        float AVX = AverageVX;  //JZH 2012-01-05
                                        //AVX *= -1;   JZH 2012-01-05  //JZH 2012-04-10 cancel

                                        //VP.X = tempP.X + AVX * setAverageScale; //(float)EnsemblesInfoToStore.VYstore[i] * setAverageScale;
                                        VP.X = tempP.X + AVX * setAverageScale * SailTrackMouseWheelScale; //LPJ 2013-6-9

                                        g1.DrawLine(Pens.Blue, tempP, VP); //SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition)));
                                    }

                                    if (displayLatLong || displayUTM) //LPJ 2012-07-02添加  LPJ 2012-7-3 修改
                                    {
                                        if (System.Math.Abs(PtStart.X - tempP.X) > 1.0e5 || System.Math.Abs(PtStart.Y - tempP.Y) > 1.0e5) //LPJ 2012-6-27 当前后两个时刻的GPS坐标相差较大时
                                        {
                                            PtStart.X = tempP.X;
                                            PtStart.Y = tempP.Y;
                                        }
                                    }

                                    g1.DrawLine(Pens.Red, PtStart, tempP); //SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition)));

                                    PtStart = tempP; // SailTrackTansToMapPoint((PointF)(bc.SailTrackBoatPosition));
                                }

                                //Modified 2011-11-17, addAuto zoom in
                                /* if (GPSautoSize)
                                 {
                                     if (displayLatLong) //LatLong
                                     {
                                         CheckGPSAutoSize(LatitudeSave[GGAsaveCount - 1], LongitudeSave[GGAsaveCount - 1]);
                                         if (AdjustGPSautoSize)
                                         {
                                             SailTrackMouseWheelScale *= 2;
                                             //Modified 2011-12-7
                                             setAverageScale *= 2; //Modified 2011-11-27
                                             if (setAverageScale > 1000) setAverageScale = 1000;
                                             AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
                                             ComputeLatLongGridText(StartLatitude, StartLongitude);
                                         }
                                     }
                                     else if (displayUTM) //for UTM , add later   //JZH 2012-04-17
                                     {
                                         CheckUTMAutoSize(UTMpointSave[GGAsaveCount - 1]);
                                     }
                                     else   //JZH 2012-04-17
                                     {
                                         CheckBottomTrackAutoSize(UTMpoint);
                                     }
                                 }*/
                            }

                            g1.FillEllipse(Brushes.Red, tempP.X - 4, tempP.Y - 4, 8 * SailTrackMouseWheelScale, 8 * SailTrackMouseWheelScale); //(-1 * originSize / 2) * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale);
                        }
                    }

                    //// 自定义缓冲中的图形渲染在屏幕上
                    SailTrackMainBuffer.Render(e.Graphics);
                    SailTrackMainBuffer.Dispose();
                }
            }
            catch//(Exception ex)
            {
                //MessageBox.Show(ex.Message);
            }
        }
        //int ChangeTimerCounter = 0;
        //bool TimerChanged = false;
        //private PointF Sta = new PointF(0, 0);

        //private int n = 0;//记录已经写入的文件数
        private class SailTrackInfoClass
        {
            public ArrayList SailTrackPointArray = new ArrayList();//用以存储测线的关键点
            public ArrayList SailTrackHeightDisplayerPointArray = new ArrayList();
            public ArrayList SailTrackTimeArray = new ArrayList();
            public ArrayList SailTrackVelArray = new ArrayList();
        }

        //private SailTrackInfoClass SailTrackInfoclass = new SailTrackInfoClass();
        private PointF SailTrackTansToMapPoint(PointF pt)
        {
            PointF SailTrackRealStartPointToStore = new PointF();
            //SailTrackRealStartPointToStore.X = (pt.X * ((float)SailTrackMaxDisplayWidth / 8) / 50); 
            //SailTrackRealStartPointToStore.Y = (pt.Y * ((float)SailTrackMaxDisplayWidth / 8) / 50); 
            SailTrackRealStartPointToStore.X = (pt.X * ((float)panelWidth / 8) / 100); //Modified 2011-11-20 Change
            SailTrackRealStartPointToStore.Y = (pt.Y * ((float)panelWidth / 8) / 100); //Modified 2011-11-20 Change
            return (SailTrackRealStartPointToStore);
        }

        private bool SailTrackTragCursorChangeToTrag = false;
        private PointF SailTrackDragStartPoint;
        private void GPSdisplayPanel_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right) //Modified 2011-11-14
            {
                if (displayUTM || displayBtmTrack) //LPJ 2012-8-21 底跟踪可自动拖动
                //if (displayUTM)
                {
                    int XmousePosition = (int)((e.X - (int)(panelWidth / 2)) * SailTrackMouseWheelScale);
                    int YmousePosition = (int)((e.Y - (int)(panelHeight / 2)) * SailTrackMouseWheelScale);
                    LabelPostionXText.Text = XmousePosition.ToString();
                    LabelPositionYText.Text = YmousePosition.ToString();
                    SailTrackTragCursorChangeToTrag = false;
                }
                else
                {
                    Point MousePosition = new Point(0, 0);
                    MousePosition.X = e.X;
                    MousePosition.Y = e.Y;
                    Point_BL ans2 = PTransform.Mouse_LatLong(
                        MousePosition,
                        UperLeftOfDisplayRectangle,
                        LowerRightOfDisplayRectagle,
                        leftLongitudeOfDisplayArea,
                        rightLongitudeOfDisplayArea,
                        topLatitudeOfDisplayArea,
                        bottomLatitudeOfDisplayArea);
                    LabelPostionXText.Text = ans2.Longitude.ToString("00000.000");
                    LabelPositionYText.Text = ans2.Latitude.ToString("0000.000");
                }
            }
            else if (e.Button == MouseButtons.Left)
            {
                if (displayUTM || displayBtmTrack) //LPJ 2012-8-21 底跟踪自动拖动
                //if (displayUTM) //Modified 2011-11-12 add displayUTM
                {
                    SailTrackTragCursorChangeToTrag = true;
                    //Cursor.Current = new Cursor(Application.StartupPath + "\\Resources\\CursorTrag.cur"); //LPJ 2013-6-11
                    try
                    {
                        Cursor.Current = new Cursor(Application.StartupPath + "\\Resources\\CursorTrag.cur");
                    }
                    catch
                    {
                        //this.Cursor = new Cursor(Cursor.Current.Handle);
                    }
                    SailTrackDragStartPoint = e.Location;
                }
                else
                {
                    SailTrackTragCursorChangeToTrag = false;
                }
            }
        }

        private bool SailTrackPanelEnterFlag = false;
        private void GPSdisplayPanel_MouseEnter(object sender, EventArgs e)
        {
            try
            {
                Cursor.Current = new Cursor(Application.StartupPath + "\\Resources\\CursorTouch.cur");
            }
            catch
            {
                //this.Cursor = new Cursor(Cursor.Current.Handle);
            }
            this.GPSdisplayPanel.Focus();
            SailTrackPanelEnterFlag = true;
        }

        private void GPSdisplayPanel_MouseHover(object sender, EventArgs e)
        {

        }

        private void GPSdisplayPanel_MouseMove(object sender, MouseEventArgs e)
        {
            if (GPSdataCount < 10) return; //Modified 2011-11-12 add
            if ((displayUTM && SailTrackTragCursorChangeToTrag)
                || (displayBtmTrack && SailTrackTragCursorChangeToTrag))  //LPJ 2012-8-21 使底跟踪可以移动
            //if (displayUTM && SailTrackTragCursorChangeToTrag)
            {
                //2011-11-20, not finished!!!
                //Cursor.Current = new Cursor(Application.StartupPath + "\\CursorTrag.cur");
                SailTrackDragEndPoint = e.Location;
                SailTrackDragLengthX += SailTrackDragEndPoint.X - SailTrackDragStartPoint.X;
                SailTrackDragLengthY += SailTrackDragEndPoint.Y - SailTrackDragStartPoint.Y;

                float leftX = SailTrackDragLengthX; // -(panelWidth / 2);
                leftX -= (panelWidth * -1) / 2;
                float topY = SailTrackDragLengthY;
                topY = panelHeight + topY;

                SailTrackDragStartPoint = e.Location;
                //if (playBackMode == true) //Modified 2011-9-15 //LPJ 2013-11-19 当暂停后，拖动会继续回放
                //{
                //    PlayBackTimer.Stop();
                //    //PlayBackTimer.Close();
                //    GPSdisplayPanel.Refresh();
                //    PlayBackTimer.Start();
                //}
                //else
                {
                    GPSdisplayPanel.Refresh();
                }
            }
        }

        private void GPSdisplayPanel_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                try
                {
                    Cursor.Current = new Cursor(Application.StartupPath + "\\Resources\\CursorTouch.cur");
                }
                catch
                {
                    //this.Cursor = new Cursor(Cursor.Current.Handle);
                }
                SailTrackTragCursorChangeToTrag = false;
            }
        }

        private void GPSdisplayPanel_MouseCaptureChanged(object sender, EventArgs e)
        {
        }

        private void GPSdisplayPanel_MouseLeave(object sender, EventArgs e)
        {
            SailTrackPanelEnterFlag = false;
            SailTrackTragCursorChangeToTrag = false;
        }

        private void GPSdisplayPanel_DragDrop(object sender, DragEventArgs e)
        {

        }

        int MaxSailTrackMouseWheelScale = 1000;
        private void GPSdisplayPanel_MouseWheel(object sender, MouseEventArgs e)
        {
            //Cursor.Current = new Cursor(Application.StartupPath + "\\CursorTouch.cur");
            //PointF MousePositionToWindows = PointToClient(MousePosition);
            PointF SailTrackMousePositionToWindows = PointToClient(MousePosition);
            if (SailTrackPanelEnterFlag)
            {
                if (e.Delta > 0) //放大
                {
                    if (SailTrackMouseWheelScale > 1)
                    {
                        if (SailTrackMouseWheelScale < 5)
                        {
                            SailTrackMouseWheelScale--;
                        }
                        else
                        {
                            SailTrackMouseWheelScale -= 2;//修正每次缩小倍数的增量，使看上去缩放比较均匀
                        }
                    }

                    //if (SailTrackMouseWheelScale < MaxSailTrackMouseWheelScale)
                    //{
                    //    if (SailTrackMouseWheelScale < 5)
                    //    {
                    //        SailTrackMouseWheelScale++;
                    //    }
                    //    else
                    //    {
                    //        SailTrackMouseWheelScale += 2;//修正每次缩小倍数的增量，使看上去缩放比较均匀
                    //    }
                    //}
                }
                else if (e.Delta < 0) //缩小
                {
                    if (SailTrackMouseWheelScale < MaxSailTrackMouseWheelScale)
                    {
                        if (SailTrackMouseWheelScale > 5)
                        {
                            SailTrackMouseWheelScale += 2;
                        }
                        else
                        {
                            SailTrackMouseWheelScale++;//修正每次缩小倍数的增量，使看上去缩放比较均匀
                        }
                    }

                    //if (SailTrackMouseWheelScale > 1)
                    //{
                    //    if (SailTrackMouseWheelScale > 5)
                    //    {
                    //        SailTrackMouseWheelScale -= 2;
                    //    }
                    //    else
                    //    {
                    //        SailTrackMouseWheelScale--;//修正每次缩小倍数的增量，使看上去缩放比较均匀
                    //    }
                    //}
                }

                ComputeLatLongGridText(StartLatitude, StartLongitude); //Modified 2011-11-14

                //Point_XY MouseLatLong(Point MousePosition,  Point UperLeftOfDisplayRectangle,  Point LowerRightOfDisplayRectagle,  
                //  double leftLatitudeOfDisplayArea,  double rightLatitudeOfDisplayArea,  double topLongitudeOfDisplayArea,  
                //  double bottomLongitudeOfDisplayArea );

                //Modified 2011-9-15
                //if (playBackMode == true) //LPJ 2013-11-19 当用户暂停后，滚动滑轮则回放会继续
                //{
                //    PlayBackTimer.Stop();
                //    GPSdisplayPanel.Refresh();
                //    PlayBackTimer.Start();
                //}
                //else
                {
                    GPSdisplayPanel.Refresh();
                }
                //GPSdisplayPanel.Refresh();
            }
        }

        //Modified 2011-11-17 add
        bool AdjustGPSautoSize = false;
        private void CheckGPSAutoSize(double CheckLatitude, double CheckLongitude)
        {
            //if (GPSautoSize == false) return;
            if (GPSAutoSizecheckBox.Checked == false) return;

            if (CheckLongitude < leftLongitudeOfDisplayArea || CheckLongitude > rightLongitudeOfDisplayArea
                || CheckLatitude < bottomLatitudeOfDisplayArea || CheckLatitude > topLatitudeOfDisplayArea)
            {
                AdjustGPSautoSize = true;
            }
            else
            {
                AdjustGPSautoSize = false;
            }
            //    double rightLongitudeOfDisplayArea,  
            //    double topLatitudeOfDisplayArea,  
            //    double bottomLatitudeOfDisplayArea
            //    double leftLongitudeOfDisplayArea,  
            //    double rightLongitudeOfDisplayArea,  
            //    double topLatitudeOfDisplayArea,  
            //    double bottomLatitudeOfDisplayArea
        }

        //JZH 2012-04-17 自动调整底跟踪航迹
        /*
        private void CheckBottomTrackAutoSize(Point UTMPreverse)
        {
            Point UTMP = new Point(0, 0);
            UTMP.X = UTMPreverse.X;
            UTMP.Y = UTMPreverse.X;
            //Modified 2011-11-22, compute X boundary
            float leftX = -1 * (SailTrackMouseWheelScale * (SailTrackDragLengthX + panelWidth / 2));
            float rightX = leftX + panelWidth * SailTrackMouseWheelScale;
            //Modified 2011-11-22, compute Y boundary
            float topY = SailTrackMouseWheelScale * (SailTrackDragLengthY - (panelHeight / 2));
            float bottomY = topY + panelHeight * SailTrackMouseWheelScale;
            if (UTMP.X < leftX || UTMP.X > rightX)
            {
                SailTrackMouseWheelScale *= 2;
                //setAverageScale *= 2; //Modified 2011-11-27
                //if (setAverageScale > 1000) setAverageScale = 1000;
                //AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
            }
            if (UTMP.Y < topY || UTMP.Y > bottomY)
            {
                SailTrackMouseWheelScale *= 2;
                //setAverageScale *= 2;
                //if (setAverageScale > 1000) setAverageScale = 1000;
                //AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
            }

            //Modified 2011-11-22, Auto decrease scale factor
            if (UTMP.X > leftX / 2 && UTMP.X < rightX / 2 && UTMP.Y > topY / 2 && UTMP.Y < bottomY / 2)
            {
                SailTrackMouseWheelScale /= 2;
                if (SailTrackMouseWheelScale < 1) SailTrackMouseWheelScale = 1;
                //if (setAverageScale < 50)
                //{
                //    setAverageScale /= 2;
                //    if (setAverageScale < 5) setAverageScale = 5;
                //}
                //AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
                ////setAverageScale /= 2;
                //if (setAverageScale < 5) setAverageScale = 5;
            }


        }
        */
        private void CheckUTMAutoSize(Point UTMPreverse)
        {
            //Modified 2011-11-21, due to original N-X and E-Y arrangement, need to reverse X, Y
            Point UTMP = new Point(0, 0);
            UTMP.X = UTMPreverse.Y;
            UTMP.Y = UTMPreverse.X;
            //Modified 2011-11-22, compute X boundary
            float leftX = -1 * (SailTrackMouseWheelScale * (SailTrackDragLengthX + panelWidth / 2));
            float rightX = leftX + panelWidth * SailTrackMouseWheelScale;
            //Modified 2011-11-22, compute Y boundary
            float topY = SailTrackMouseWheelScale * (SailTrackDragLengthY - (panelHeight / 2));
            float bottomY = topY + panelHeight * SailTrackMouseWheelScale;

            //Modified 2011-11-22, for debugfing
            //DebugMSGtextBox.AppendText("\r\nMouse Scale: " + SailTrackMouseWheelScale.ToString());
            //DebugMSGtextBox.AppendText("\r\nX left: " + leftX.ToString() + " , X right: " + rightX.ToString());
            //DebugMSGtextBox.AppendText("\r\nY Top: " + topY.ToString() + " ,Y bottom: " + bottomY.ToString());
            //DebugMSGtextBox.AppendText("\r\nDragX: " + SailTrackDragLengthX.ToString() + ", DragY: " + SailTrackDragLengthY.ToString ());

            //Modified 2011-11-22, Auto increase scale factor
            if (UTMP.X < leftX || UTMP.X > rightX)
            {
                SailTrackMouseWheelScale *= 2;
                setAverageScale *= 2; //Modified 2011-11-27
                if (setAverageScale > 1000) setAverageScale = 1000;
                AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
            }
            if (UTMP.Y < topY || UTMP.Y > bottomY)
            {
                SailTrackMouseWheelScale *= 2;
                setAverageScale *= 2;
                if (setAverageScale > 1000) setAverageScale = 1000;
                AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
            }

            //Modified 2011-11-22, Auto decrease scale factor
            if (UTMP.X > leftX / 2 && UTMP.X < rightX / 2 && UTMP.Y > topY / 2 && UTMP.Y < bottomY / 2)
            {
                SailTrackMouseWheelScale /= 2;
                if (SailTrackMouseWheelScale < 1) SailTrackMouseWheelScale = 1;
                if (setAverageScale < 50)
                {
                    setAverageScale /= 2;
                    if (setAverageScale < 5) setAverageScale = 5;
                }
                AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-12-2
                //setAverageScale /= 2;
                //if (setAverageScale < 5) setAverageScale = 5;
            }
            //GPScontrolPanel.Refresh();
        }

        //Modified 2011-11-14 add
        private void ComputeLatLongGridText(double StartLatitude, double StartLongitude)
        {
            //Modified 2011-11-14 need to compute 
            //    Point UperLeftOfDisplayRectangle,  
            //    Point LowerRightOfDisplayRectagle,  
            //    double leftLongitudeOfDisplayArea,  
            //    double rightLongitudeOfDisplayArea,  
            //    double topLatitudeOfDisplayArea,  
            //    double bottomLatitudeOfDisplayArea
            // and grid line text for the following function:
            //Point CurrentScreenPosition(
            //    double currentLatitude,  
            //    double currentLongitude,  
            //    Point UperLeftOfDisplayRectangle,  
            //    Point LowerRightOfDisplayRectagle,  
            //    double leftLongitudeOfDisplayArea,  
            //    double rightLongitudeOfDisplayArea,  
            //    double topLatitudeOfDisplayArea,  
            //    double bottomLatitudeOfDisplayArea );

            //panelWidth = GPSdisplayPanel.ClientSize.Width - GPScontrolPanel.ClientSize.Width;
            //panelHeight = GPSdisplayPanel.ClientSize.Height - GPSdepthPanel.ClientSize.Height;

            panelWidth = GPSdisplayPanel.Width - GPScontrolPanel.Width; //LPJ 2013-8-19
            panelHeight = GPSdisplayPanel.Height - GPSdepthPanel.Height;  //LPJ 2013-8-19

            UperLeftOfDisplayRectangle.X = (int)SailTrackCurrentDisplayLeft;
            UperLeftOfDisplayRectangle.Y = (int)SailTrackCurrentDisplayTop;
            LowerRightOfDisplayRectagle.X = (int)(UperLeftOfDisplayRectangle.X + panelWidth);
            LowerRightOfDisplayRectagle.Y = (int)(UperLeftOfDisplayRectangle.Y + panelHeight);

            //double initialGridSize = 0.1; //Modified 2011-11-15, init grid size
            double initialGridSize = 0.01; //Modified 2011-11-15, init grid size  //LPJ 2012-7-30 将初始显示坐标范围0.1度修改为0.01度
            //Modified 2011-11-14, Longitude grid line text, Longitude line is always 9 (include left and right edges)
            leftLongitudeOfDisplayArea = StartLongitude - 4 * initialGridSize * SailTrackMouseWheelScale;
            rightLongitudeOfDisplayArea = StartLongitude + 4 * initialGridSize * SailTrackMouseWheelScale;
            double WidthOfLongitude = rightLongitudeOfDisplayArea - leftLongitudeOfDisplayArea;

            for (int i = 0; i <= 8; i++) //Modified 2011-11-11, Longitude grid line is always 9
            {
                StartLongitudeText[i] = (string)(leftLongitudeOfDisplayArea + i * initialGridSize * SailTrackMouseWheelScale).ToString("00000.000");
            }

            //Modified 2011-11-14, compute Latitude grid line number
            float GPSgridSize = panelWidth / 8;
            float GPSverticalGridNum = panelHeight / GPSgridSize;
            float residu1 = (float)(GPSverticalGridNum - (int)GPSverticalGridNum);
            int GPSverticalGridLine;

            //if (residu1 > 0.5) //LPJ 2012-8-10 修改，当residu1大于0.5时，则纬度格网数加1
            if (residu1 <= 0.5)  //LPJ 2012-8-10 修改
            {
                GPSverticalGridLine = (int)GPSverticalGridNum;
            }
            else
            {
                GPSverticalGridLine = (int)GPSverticalGridNum + 1;
            }

            //Modified 2011-11-14, compute Latitude grid text

            double FirstLineOfLatitude = StartLatitude + (GPSverticalGridLine / 2) * initialGridSize * SailTrackMouseWheelScale;
            double LastLineOfLatitude = FirstLineOfLatitude + (GPSverticalGridLine) * initialGridSize * SailTrackMouseWheelScale;

            for (int j = 0; j < GPSverticalGridLine; j++)
            {
                StartLatitudeText[j] = (string)(FirstLineOfLatitude - j * initialGridSize * SailTrackMouseWheelScale).ToString("0000.000");
            }

            //Modified 2011-11-14, compute topLatitudeOfDisplayArea and bottomLatitudeOfDisplayArea
            double ProportionOfLatitude = (double)panelHeight / (double)panelWidth;
            double HeightOfLatitude = (WidthOfLongitude * ProportionOfLatitude) / 2;

            topLatitudeOfDisplayArea = StartLatitude + HeightOfLatitude;
            bottomLatitudeOfDisplayArea = StartLatitude - HeightOfLatitude;

            if (GPSdataCount > 2) //Modified 2011-11-15, recompute start point every time change the scale
            {
                Point ans = PTFM.CurrentScreenPosition(
                    (double)StartLatitude,
                    (double)StartLongitude,
                    UperLeftOfDisplayRectangle,
                    LowerRightOfDisplayRectagle,
                    leftLongitudeOfDisplayArea,
                    rightLongitudeOfDisplayArea,
                    topLatitudeOfDisplayArea,
                    bottomLatitudeOfDisplayArea);

                ////Test
                //Point P1 = new Point(0, 0);
                //Point P2 = new Point(1000, 1000);

                //P1.X = 0;
                //P1.Y = 0;
                //P2.X = 1000;
                //P2.Y = 1000;
                //double testLong = -120;
                //double testLat = 35;
                //Point testUperLeftOfDisplayRectangle = P1;
                //Point testLowerRightOfDisplayRectagle = P2;
                //double testleftLongitudeOfDisplayArea = testLong - 0.9;
                //double testrightLongitudeOfDisplayArea = testLong + 0.1;
                //double testtopLatitudeOfDisplayArea = testLat + 0.1;

                //Point ans = PTFM.CurrentScreenPosition(
                //    testLat,
                //    testLong,
                //    testUperLeftOfDisplayRectangle,
                //    testLowerRightOfDisplayRectagle,
                //    testleftLongitudeOfDisplayArea,
                //    testrightLongitudeOfDisplayArea,
                //    testtopLatitudeOfDisplayArea,
                //    testbottomLatitudeOfDisplayArea);

                StartLatLongPosition.X = ans.X;
                StartLatLongPosition.Y = ans.Y;
            }
        }

        Point StartLatLongPosition;

        //Modified 2011-8-30 add
        /*
        float SailTrackgetdata(string data, int num)
        {
            int iLength = data.Length;
            int start = 0;
            int end = 0;
            int i = 0;
            int j = 0;

            for (; i < iLength; i++)
            {
                if (data[i] == ',')
                {
                    j++;//记录遍历过程中遇到的逗号的个数
                    if (num == j)
                    {
                        start = i + 1;
                    }
                    else if (num + 1 == j)
                    {
                        end = i;
                        break;
                    }
                }
            }
            string str = data.Substring(start, end - start);
            if (str == "")
            {
                return 0;
            }
            else
            {
                return (float.Parse(str));
            }
        }
        */
        public static Image SailTrackRotateImage(Image img, float RotationAngle)//顺时针旋转
        {
            //创建一个空的位图图像
            Bitmap bmp = new Bitmap(2 * img.Width, 2 * img.Height);
            //转换为Graphics对象
            Graphics gfx = Graphics.FromImage(bmp);

            //Matrix matrix = new Matrix();
            //matrix.RotateAt(rotationAngle, new Point(img.Width, img.Height));//旋转
            //gfx.Transform = matrix;
            gfx.TranslateTransform(img.Width, img.Height);//gfx坐标系的原点定在gfx的中心点
            gfx.RotateTransform(RotationAngle);//gfx坐标系绕中心点旋转
            gfx.InterpolationMode = InterpolationMode.HighQualityBicubic;//双三次插值法，得到高质量图像
            gfx.SmoothingMode = SmoothingMode.HighQuality; //高质量
            gfx.PixelOffsetMode = PixelOffsetMode.HighQuality; //高像素偏移质量
            //gfx.DrawImage(img, new Point(img.Width, img.Height));
            gfx.DrawImage(img, new Point(0, 0));//在gfx坐标系的原点画img图像

            gfx.Dispose();
            return bmp;
        }
        /*
        private float SailTrackAngleOf2Points(PointF Sta, PointF End)
        {
            float Angle = 0;
            if (End.X >= Sta.X)
            {
                Angle = 180 - (float)((180 / Math.PI) * Math.Acos((End.Y - Sta.Y) / Math.Sqrt(Math.Pow((End.X - Sta.X), 2) + Math.Pow((End.Y - Sta.Y), 2))));
            }
            else
            {
                Angle = 180 + (float)((180 / Math.PI) * Math.Acos((End.Y - Sta.Y) / Math.Sqrt(Math.Pow((End.X - Sta.X), 2) + Math.Pow((End.Y - Sta.Y), 2))));
            }

            return Angle;
        }
        */
        //Modified 2011-9-2
        private void hScrollBarAveragePoints_Scroll(object sender, ScrollEventArgs e)
        {
            int eventType;
            //int value;
            float fValue;
            eventType = e.Type.GetHashCode();

            fValue = (float)hScrollBarAveragePoints.Value;

            //if (eventType == 4) MessageBox.Show(hScrollBarPlaybackSpeed.Value.ToString());
            if (eventType == 0)    //less
            {
                setAveragePoints -= 5;
            }
            else if (eventType == 1) //more
            {
                setAveragePoints += 5;
            }
            else if (eventType == 2) //biger less
            {
                setAveragePoints -= 10;
            }
            else if (eventType == 3) //biger more
            {
                setAveragePoints += 10;
            }
            else if (eventType == 5) //center button
            {
                setAveragePoints = (int)fValue;
            }
            if (setAveragePoints <= 5) setAveragePoints = 5;
            if (setAveragePoints > 100) setAveragePoints = 100;

            AveragePointslabel.Text = setAveragePoints.ToString();
            AverageScalelabel.Text = setAverageScale.ToString(); //Modified 2011-11-28
            GPSdisplayPanel.Refresh();
        }

        //Modified 2011-9-2
        private void hScrollBarAverageScale_Scroll(object sender, ScrollEventArgs e)
        {
            int eventType;
            //int value;
            float fValue;
            eventType = e.Type.GetHashCode();

            fValue = (float)hScrollBarAverageScale.Value;

            //if (eventType == 4) MessageBox.Show(hScrollBarPlaybackSpeed.Value.ToString());
            if (eventType == 0)    //less
            {
                setAverageScale -= 5;
            }
            else if (eventType == 1) //more
            {
                setAverageScale += 5;
            }
            else if (eventType == 2) //biger less
            {
                setAverageScale -= 10;
            }
            else if (eventType == 3) //biger more
            {
                setAverageScale += 10;
            }
            else if (eventType == 5) //center button
            {
                setAverageScale = (int)fValue;
            }
            if (setAverageScale <= 0) setAverageScale = 0;
            if (setAverageScale > 1000) setAverageScale = 1000;

            AverageScalelabel.Text = setAverageScale.ToString();
            GPSdisplayPanel.Refresh();
        }

        //string ggadataCopy;
        //Modified 2011-9-15 modify to compute two points distance using  computeDistanceFromLatLong()

        //double currentLat, currentLong, preLat, preLong;
        //float DistanceAB;

        //        结构体名：Point_XY
        //结构体内变量： public double  X;   //X坐标  指向北
        //               public double  Y;   //Y坐标  指向东
        /// <summary>
        /// 高斯投影 由大地坐标 纬度B 经度L 中央子午线 L0，及椭球参数a, aa，///转换为高斯平面坐标
        ///其中GPS坐标系为WGS-84坐标系，故椭球参数a=6378137.000  ///aa=298.257223563
        /// 其中：角度格式为 度
        /// </summary>
        //public Point_XY Gaosi_BL2xy(double a, double aa, double B_degree, double L_degree, double L0_degree)；
        //输入参数说明：
        //参数名称	参数类型	参数定义	参数单位
        //a	double	参考椭球长半轴	m
        //aa	double	椭球扁率倒数	无
        //B_degree	double	大地纬度	度
        //L_degree	double	大地经度	度
        //L0_degree	double	投影中央子午线经度	度
        //输出参数说明：x坐标指向北 y坐标指向东
        //输出结构体 Point_XY  
        //调用示例：
        //BL_2_xy temp1 = new BL_2_xy();//定义一个坐标转换对象 temp1
        //Point_XY ans= temp1.Gaosi_BL2xy(6378137.000, 298.257223563, 30.5, 120.5, 120);//高斯投影  WGS-84坐标  B=30.5° L=120.5° L0=120°
        //double X1 = ans.X;
        //double Y1 = ans.Y;
        //        计算示例：
        //输入	输出
        //椭球参数	6378137	298.257223563	
        //高斯平面坐标	x（m）
        //中央经线（度）	120		3375648.0327
        //纬度(度)	30.5		y（m）
        //经度(度)	120.5		47999.7613

        double testLat = 30.5;
        double testLong = 120.5;
        double L0;
        //Point_XY ans2;
        BL_2_xy tempBL = new BL_2_xy();//定义一个坐标转换对象 temp1
        Point_XY currentBL;
        //Point_XY preBL;
        //Point diffBL;
        Point_XY originBL;
        string saveGGA = "";

        //Point StartUTMpnt;  //LPJ 2012-7-2 增加起始UTM坐标点 //LPJ 2012-8-6 取消
        private void ComputeXYposition(string GGAdata)
        {
            //ggadataCopy = GGAdata;
            if (GGAdata == null)
            {
                GGAdata = saveGGA;
                //return;
            }
            else
            {
                saveGGA = GGAdata;
            }
            try
            {
                //GPS_GGAdecode(GGAdata);

                #region Decode GPGGA ---start   LPJ 2014-7-10
                CDecodeGPS decodeGPS = new CDecodeGPS();
                decodeGPS.GPS_GGAdecode(GGAdata, ref gpsTime, ref GPS_longitude, ref GPS_latitude, ref NorthSouth, ref EastWest);
                defaultGPGGA = GPS_GGAbuffer;
                GPS_FloatLatitude = float.Parse(GPS_latitude);
                if (NorthSouth == "S")
                    GPS_FloatLatitude *= -1.0f;
                GPS_latitude = GPS_latitude.Insert(2, "º") + NorthSouth;
                GPS_FloatLongitude = float.Parse(GPS_longitude);
                if (EastWest == "W")
                {
                    GPS_FloatLongitude *= -1.0f;
                }
                GPS_longitude = GPS_longitude.Insert(3, "º") + EastWest;
                #endregion
            }
            catch
            {
                return;
            }

            FloatLatitude = GPS_FloatLatitude;
            FloatLongitude = GPS_FloatLongitude;

            //Modified2011-9-16， test UTM_BL_2xy.dll
            //testLat = (double)FloatLatitude / 100;  // LPJ 2012-7-2 取消，由于GPS坐标格式为ddmm.mmmm度分格式（前导位数不足则补0），将在下面重新将坐标转换为度
            //testLong = (double)FloatLongitude / 100;
            //L0 = (double)((int)testLong);

            //LPJ 2012-7-2 将GPS坐标格式转化为度----start
            int iLat, iLong;
            iLat = (int)FloatLatitude / 100;
            iLong = (int)FloatLongitude / 100;
            testLat = iLat + (FloatLatitude / 100.0 - iLat) / 60.0 * 100.0;
            testLong = iLong + (FloatLongitude / 100.0 - iLong) / 60.0 * 100.0;
            L0 = (double)iLong;
            //LPJ 2012-7-2 将GPS坐标格式转化为度----end

            currentBL = tempBL.UTM_BL2xy(6378137.000, 298.257223563, testLat, testLong, L0);//UTM 投影  WGS-84坐标  B=30.5° L=120.5°L0=120°

            //Modified 2011-9-10 here
            currentX = FloatLatitude;
            currentY = FloatLongitude;

            //if (totalNum < StartPoint) //LPJ 2012-8-9 修改，如果设为 StartPoint，则前（StartPoint-1）个UTM坐标均为0
            //if (totalNum < 2) //LPJ 2012-8-9 修改
            if (totalNum < StartPoint || Math.Abs(originLat - FloatLatitude) > 100.0 || Math.Abs(originLong - FloatLongitude) > 100.0) //LPJ 2012-8-10 当当前GPS坐标与之前的坐标相差大于1°，则重新设定起始坐标
            {
                originLat = FloatLatitude;
                originLong = FloatLongitude;
                //previousXposition = 0;
                currentX = 0;
                //previousYposition = 0;
                currentY = 0;

                originBL = currentBL;

                UTMpoint.X = 0;
                UTMpoint.Y = 0;
                //UTMpoint = diffBL;
            }
            else
            {
                //currentX = (FloatLatitude - originLat) * 1100.0f;
                //currentY = (FloatLongitude - originLong) * 900.0f;
                //if (System.Math.Abs(FloatLatitude - originLat) > 10.0 || System.Math.Abs(FloatLongitude - originLong) > 10.0) //LPJ 2012-7-2 判断该时刻坐标与前一时刻坐标相差是否超过10'，若是，则重新设置起始GPS坐标
                //{
                //    currentX = 0;    //LPJ 2012-7-2 暂时取消
                //    currentY = 0;

                //    UTMpoint.X = 0;
                //    UTMpoint.Y = 0;

                //    originLat = FloatLatitude;
                //    originLong = FloatLongitude;
                //    originBL = currentBL;
                //}
                //else
                {
                    currentX = (FloatLatitude - originLat) * 1;
                    currentY = (FloatLongitude - originLong) * 1;

                    UTMpoint.X = (int)(currentBL.X - originBL.X);
                    UTMpoint.Y = (int)(currentBL.Y - originBL.Y);
                }

                //Modified 2011-9-27 save UTMpoint here
                UTMpointSave[GGAsaveCount] = UTMpoint;  //Modified 2011-9-27 use new GGAsaveCount, it is updaed in ComputeCombinedWaterVelocity()
                //LatitudeSave[GGAsaveCount] = GPS_FloatLatitude; //Modified 2011-11-11 test
                //LongitudeSave[GGAsaveCount] = GPS_FloatLongitude;
                //previousXposition = currentX;
                //previousYposition = currentY;
            }

            //  StartUTMpnt = UTMpoint;  //LPJ 2012-7-2 增加 //LPJ 2012-7-3 取消
        }

        //Modified 2011-8-31
        private void GPScontrolPanel_Paint(object sender, PaintEventArgs e)
        {
            try
            {
                if (totalNum >= 2)
                {
                    this.ControlLatLonglabel.Text = GPS_latitude + "     " + GPS_longitude;  //Modified 2011-8-31
                    if (playBackMode)
                    {
                        this.ControlVXVYlabel.Text = AverageVXsave[GGAsaveCount - 1].ToString("0.00") + "   " + AverageVYsave[GGAsaveCount - 1].ToString("0.00");
                    }
                    else
                    {
                        this.ControlVXVYlabel.Text = VXstore + "   " + VYstore;
                    }

                    this.ControlTimelabel.Text = current_DataTime;
                    //this.ControlXYlabel.Text = UTMpoint.X.ToString() + "      " + UTMpoint.Y.ToString() + " m";
                    this.ControlXYlabel.Text = UTMpoint.Y.ToString() + "      " + UTMpoint.X.ToString() + " m"; //Modified 2011-11-21 reverse X,Y axis
                }
                AveragePointslabel.Text = setAveragePoints.ToString();

                //    BufferedGraphicsContext SailTrackControlPanel = BufferedGraphicsManager.Current;//获取当前绘图主缓冲区上下文
                //    BufferedGraphics SailTrackControlBuffer = SailTrackControlPanel.Allocate(e.Graphics, SailTrackDisplayRec);
                //    //设置双缓冲的图形缓冲区：使用指定的e.Graphics像素格式，创建指定大小SailTrackDisplayRec的图形缓冲区
                //    Bitmap TrackForwardBitmap;
                //    TrackForwardBitmap = new Bitmap(Application.StartupPath + "\\TrackForward.bmp");
                //    Bitmap TrackPauseBitmap;
                //    TrackPauseBitmap = new Bitmap(Application.StartupPath + "\\TrackPause.bmp");
                //    Bitmap TrackStopBitmap;
                //    TrackStopBitmap = new Bitmap(Application.StartupPath + "\\TrackStop.bmp");
                //    using (Graphics g1 = SailTrackControlBuffer.Graphics)
                //    {
                //        //TrackForwardBitmap = new Bitmap(Application.StartupPath + "\\TrackForward.bmp");
                //        //g1.DrawImage(TrackForwardBitmap, 10, 176); 
                //    }
                //    SailTrackControlBuffer.Render(e.Graphics);
                //    SailTrackControlBuffer.Dispose();
                //buttonTrackForward.Refresh();
                if (playBackMode)
                {
                    //buttonTrackFF.Show();
                    //buttonTrackRR.Show();
                    buttonTrackFF.Enabled = true;
                    //buttonTrackFF.BackColor = BlackWhite ;
                    buttonTrackRR.Enabled = true;
                    //progressBarGPSTrack.Value = 50;
                    progressBarGPSTrack.Visible = true;
                }
                else
                {
                    buttonTrackFF.Hide();
                    buttonTrackRR.Hide();
                    buttonTrackFF.Enabled = false;
                    buttonTrackRR.Enabled = false;
                    progressBarGPSTrack.Visible = false;
                }
            }
            catch
            {
            }
        }

        private void buttonTrackForward_Click(object sender, EventArgs e)
        {
            TrackForward = !TrackForward;
            if (TrackForward)
            {
                TrackPause = false;
                TrackStop = false;
            }
            buttonTrackForward.Refresh();
        }

        private void buttonTrackPause_Click(object sender, EventArgs e)
        {
            TrackPause = !TrackPause;
            if (TrackPause)
            {
                TrackForward = false;
                TrackStop = false;
                PausePoint = totalNum;
            }
        }

        private void buttonTrackStop_Click(object sender, EventArgs e)
        {
            TrackStop = !TrackStop;
            if (TrackStop)
            {
                TrackForward = false;
                TrackPause = false;
            }
        }

        private void buttonTrackForward_Paint(object sender, PaintEventArgs e)
        {

        }

        private void groupBox17_Paint(object sender, PaintEventArgs e)
        {

        }

        //Modified 2011-9-10
        private void buttonTrackFF_Click(object sender, EventArgs e)
        {
            setPlaybackTimeLength -= 100;
            if (setPlaybackTimeLength < minimumPlaybackTime) setPlaybackTimeLength = minimumPlaybackTime;
            if (setPlaybackTimeLength > maximumPlaybackTime) setPlaybackTimeLength = maximumPlaybackTime;
            //InsInfotextBox.Text = setPlaybackTimeLength.ToString(); //debug
            PlayBackTimer.Stop();
            PlayBackTimer.Close();
            PlayBackTimer = new System.Timers.Timer();
            PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
            PlayBackTimer.Interval = setPlaybackTimeLength;
            PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
            ProcessBar.Refresh();

            if (!bPlaybackStop) //LPJ 2013-11-19
                PlayBackTimer.Start();
        }
        //Modified 2011-9-10
        private void buttonTrackRR_Click(object sender, EventArgs e)
        {
            setPlaybackTimeLength += 100;
            if (setPlaybackTimeLength < minimumPlaybackTime) setPlaybackTimeLength = minimumPlaybackTime;
            if (setPlaybackTimeLength > maximumPlaybackTime) setPlaybackTimeLength = maximumPlaybackTime;
            //InsInfotextBox.Text = setPlaybackTimeLength.ToString(); //debug
            PlayBackTimer.Stop();
            PlayBackTimer.Close();
            PlayBackTimer = new System.Timers.Timer();
            PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
            PlayBackTimer.Interval = setPlaybackTimeLength;
            PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
            ProcessBar.Refresh();
            if(!bPlaybackStop) //LPJ 2013-11-19
            PlayBackTimer.Start();
        }

        private void hScrollBarStartPoint_Scroll(object sender, ScrollEventArgs e)
        {
        }

        int StartPoint = 10;
        private void button2_Click(object sender, EventArgs e)
        {
            int currentPoint = totalNum;
            if (playBackMode == true)
            {
                PlayBackTimer.Stop();
            }
            for (int i = 0; i < currentPoint; i++)
            {
                //previousXposition = 0;
                currentX = 0;
                //previousYposition = 0;
                currentY = 0;
                GPSdisplayPanel.Refresh();
            }

            if (playBackMode == true)
            {
                if(!bPlaybackStop) //LPJ 2013-11-19
                PlayBackTimer.Start();
            }

            labelStartPoint.Text = currentPoint.ToString();
        }
        //Modified 2011-9-15 compute distance
        //double Distance;
        /*
        private float computeDistanceFromLatLong(double latitudeA, double longitudeA, double latitudeB, double longitudeB)
        {
            //Modified 2011-9-15, convert first point
            double MLatA, MLatB, MLonA, MLonB;

            MLatA = latitudeA;
            MLatB = latitudeB;

            if (longitudeA < 0)
            {
                MLonA = 90 + Math.Abs(longitudeA);
            }
            else
            {
                MLonA = 90 - longitudeA;
            }
            if (longitudeB < 0)
            {
                MLonB = 90 + Math.Abs(longitudeB);
            }
            else
            {
                MLonB = 90 - longitudeB;
            }
            double Compute;

            Compute = Math.Sin(MLatA) * Math.Sin(MLatB) * Math.Cos(MLonA - MLonB) + Math.Cos(MLatA) * Math.Cos(MLatB);
            Distance = 6378.140f * Math.Acos(Compute) * Math.PI / 180;
            return ((float)Distance);
        }
        */
        //bool displayUTM = true;  
        bool displayUTM = false;   //JZH 2012-01-31
        bool displayLatLong = false;
        bool displayBtmTrack = true;    //JZH 2011-12-18

        //JZH 2012-01-31 添加底跟踪航迹显示按钮
        private void radioButtonBtmTrack_CheckedChanged(object sender, EventArgs e)
        {
            displayBtmTrack = radioButtonBtmTrack.Checked;
            if (displayBtmTrack)
            {
                displayLatLong = false;
                displayUTM = false;
            }
            GPSdisplayPanel.Refresh();
        }

        private void radioButtonMotoke_CheckedChanged(object sender, EventArgs e)
        {
            if (GPSdataCount < 2) return;
            displayUTM = radioButtonMotoke.Checked;
            if (displayUTM)
            {
                displayLatLong = false; // !radioButtonLatLong.Checked;
                displayBtmTrack = false;  //JZH 2012-01-31
            }
            GPSdisplayPanel.Refresh();
        }

        private void radioButtonLatLong_CheckedChanged(object sender, EventArgs e)
        {
            if (GPSdataCount < 2) return;
            displayLatLong = radioButtonLatLong.Checked;
            if (displayLatLong)
            {
                displayUTM = false; // !radioButtonMotoke.Checked;
                displayBtmTrack = false; //JZH 2012-01-31
            }
            GPSdisplayPanel.Refresh();
        }

        //Modified 2011-11-17, add autosize
        bool GPSautoSize = false;
        private void GPSAutoSizecheckBox_CheckedChanged(object sender, EventArgs e)
        {
            if (GPSdataCount < 2) return;
            if (GPSautoSize == false)
            {
                GPSautoSize = true;
                GPSAutoSizecheckBox.Checked = true;
            }
            else
            {
                GPSAutoSizecheckBox.Checked = false;
                GPSautoSize = false;
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////
        //All parameters put here together Modified 2011-8-24
        //////////////////////////////////////////////////////////////////////////////////////////////

        [Serializable]
        private class EnsemblesInfo    //including all info for playback 2011-7-25
        {
            public ArrayList WaterVelocity = new ArrayList();        //地球参考系 水速，
            //每个元素包含数百单元层的三维速度分量
            public ArrayList BoatVelocity = new ArrayList();         //地球参考系 船速,

            public ArrayList BoatV_GPS = new ArrayList();            //船速，参考：GPS，  LPJ 2013-7-31
            public ArrayList WaterV_GPS = new ArrayList();           //绝对水流速，参考：GPS， LPJ 2013-7-31

            public ArrayList BoatV_GPGGA = new ArrayList();            //船速，参考：GPS，  LPJ 2013-7-31
            public ArrayList WaterV_GPGGA = new ArrayList();           //绝对水流速，参考：GPS， LPJ 2013-7-31

            public ArrayList WaterV_Null = new ArrayList();         //绝对流速，无参考，LPJ 2013-11-22

            //每个元素为特定时刻船速的三维速度分量
            public ArrayList RecivedTime = new ArrayList();          //样本接收时间
            public ArrayList RecivedDataTime = new ArrayList();      //年月日时分秒
            public ArrayList bottomDepth = new ArrayList();          //海底深度
            //////add GPS and VX, VY..... Modified 2011-8-22 *********************
            public ArrayList GPS_latitude = new ArrayList();         //float, Modified 2011-8-22
            public ArrayList GPS_longitude = new ArrayList();        //float

            public ArrayList Latitude = new ArrayList();         //float, Modified 2013-9-17
            public ArrayList Longitude = new ArrayList();        //float,2013-9-17

            public ArrayList gpsShipSpeed = new ArrayList();         //float
            public ArrayList GPS_HDT = new ArrayList();              //float
            public ArrayList VXstore = new ArrayList();              //float
            public ArrayList VYstore = new ArrayList();              //float
            public ArrayList GPS_GGAbuffer = new ArrayList();        //string, Modified 2011-8-30 add next 4 lines
            public ArrayList GPS_VTGbuffer = new ArrayList();        //string
            public ArrayList GPS_HDTbuffer = new ArrayList();        //string
            public ArrayList GPS_ROTbuffer = new ArrayList();        //string
            public ArrayList UTMpoint = new ArrayList();             //Point, Modified 2011-9-23
            public ArrayList RangeOfFirstBin = new ArrayList();      //float JZH 2012-01-10   计算有效平均流速单元与单元深度时需要

            //SM>
            public ArrayList BinSize = new ArrayList();
            //SM<

            public ArrayList iGoodBin = new ArrayList();         //LPJ 2013-5-16 增加变量用于计算有效单元层数
            public ArrayList Pitch = new ArrayList();      //LPJ 2013-5-18
            public ArrayList Roll = new ArrayList();       //LPJ 2013-5-18
            public ArrayList BoatWater = new ArrayList();  //LPJ 2013-5-18
            public ArrayList WaterDir = new ArrayList();   //LPJ 2013-5-18
            public ArrayList BoatDir = new ArrayList();    //LPJ 2013-7-3 增加测船方向
            public ArrayList WaterSpeedSum = new ArrayList(); //LPJ 2013-7-3 每个ensemble的总流速

            public ArrayList BoatWater_GPS = new ArrayList();  //LPJ 2013-7-31
            public ArrayList WaterDir_GPS = new ArrayList();   //LPJ 2013-7-31
            public ArrayList BoatDir_GPS = new ArrayList();    //LPJ 2013-7-31增加测船方向
            public ArrayList WaterSpeedSum_GPS = new ArrayList(); //LPJ 2013-7-31 每个ensemble的总流速

            public ArrayList BoatWater_GPGGA = new ArrayList();  //LPJ 2013-7-31
            public ArrayList WaterDir_GPGGA = new ArrayList();   //LPJ 2013-7-31
            public ArrayList BoatDir_GPGGA = new ArrayList();    //LPJ 2013-7-31增加测船方向
            public ArrayList WaterSpeedSum_GPGGA = new ArrayList(); //LPJ 2013-7-31 每个ensemble的总流速

            public ArrayList BoatWater_Null = new ArrayList();  //LPJ 2013-11-22
            public ArrayList WaterDir_Null = new ArrayList();   //LPJ 2013-11-22
            public ArrayList BoatDir_Null = new ArrayList();    //LPJ 2013-11-22 增加测船方向
            public ArrayList WaterSpeedSum_Null = new ArrayList(); //LPJ 2013-11-22 每个ensemble的总流速

            [NonSerialized]
            public int ChangeNumSum = 0;
            public ArrayList t = new ArrayList();
            public ArrayList BoatSpeed = new ArrayList();
            public ArrayList WaterSpeed = new ArrayList();

            public ArrayList BoatSpeed_GPS = new ArrayList();  //LPJ 2013-7-31
            public ArrayList WaterSpeed_GPS = new ArrayList(); //LPJ 2013-7-31

            public ArrayList BoatSpeed_GPGGA = new ArrayList();  //LPJ 2013-7-31
            public ArrayList WaterSpeed_GPGGA = new ArrayList(); //LPJ 2013-7-31

            public ArrayList WaterSpeed_Null = new ArrayList(); //LPJ 2013-11-22

            public ArrayList NewWaterSpeedToSixColor = new ArrayList(); //LPJ 2013-7-4
            public ArrayList NewWaterSpeedToSixColor_GPS = new ArrayList(); //LPJ 2013-7-31
            public ArrayList NewWaterSpeedToSixColor_GPGGA = new ArrayList(); //LPJ 2013-7-31
            public ArrayList NewWaterSpeedToSixColor_Null = new ArrayList(); //LPJ 2013-11-22  无参考 //LPJ 2013-11-22

            //public ArrayList WaterSpeedToBlackWhite = new ArrayList();   //水速RGB
            public ArrayList WaterSpeedToSixColor = new ArrayList();   //水速RGB
            //public ArrayList WaterSpeedToRedBlueGreen = new ArrayList();   //水速RGB
            //public ArrayList WaterSpeedToYellowBlackCyan = new ArrayList();   //水速RGB

            //public ArrayList WaterSpeedToBlackWhite_GPS = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            public ArrayList WaterSpeedToSixColor_GPS = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList WaterSpeedToRedBlueGreen_GPS = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList WaterSpeedToYellowBlackCyan_GPS = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList WaterSpeedToBlackWhite_GPGGA = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            public ArrayList WaterSpeedToSixColor_GPGGA = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList WaterSpeedToRedBlueGreen_GPGGA = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList WaterSpeedToYellowBlackCyan_GPGGA = new ArrayList();   //水速RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList WaterSpeedToBlackWhite_Null = new ArrayList();   //水速RGB 无参考 //LPJ 2013-11-22
            public ArrayList WaterSpeedToSixColor_Null = new ArrayList();   //水速RGB 无参考 //LPJ 2013-11-22
            //public ArrayList WaterSpeedToRedBlueGreen_Null = new ArrayList();   //水速RGB  无参考 //LPJ 2013-11-22
            //public ArrayList WaterSpeedToYellowBlackCyan_Null = new ArrayList();   //水速RGB  无参考 //LPJ 2013-11-22

            #region LPJ 2016-8-16 cancel
            //public ArrayList NorthVelocityToBlackWhite = new ArrayList();   //北分量RGB
            //public ArrayList NorthVelocityToSixColor = new ArrayList();   //北分量RGB
            //public ArrayList NorthVelocityToRedBlueGreen = new ArrayList();   //北分量RGB
            //public ArrayList NorthVelocityToYellowBlackCyan = new ArrayList();   //北分量RGB

            //public ArrayList EastVelocityToBlackWhite = new ArrayList();   //东分量RGB
            //public ArrayList EastVelocityToSixColor = new ArrayList();   //东分量RGB
            //public ArrayList EastVelocityToRedBlueGreen = new ArrayList();   //东分量RGB
            //public ArrayList EastVelocityToYellowBlackCyan = new ArrayList();   //东分量RGB

            //public ArrayList NorthVelocityToBlackWhite_GPS = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToSixColor_GPS = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToRedBlueGreen_GPS = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToYellowBlackCyan_GPS = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList EastVelocityToBlackWhite_GPS = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToSixColor_GPS = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToRedBlueGreen_GPS = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToYellowBlackCyan_GPS = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList NorthVelocityToBlackWhite_GPGGA = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToSixColor_GPGGA = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToRedBlueGreen_GPGGA = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList NorthVelocityToYellowBlackCyan_GPGGA = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList EastVelocityToBlackWhite_GPGGA = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToSixColor_GPGGA = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToRedBlueGreen_GPGGA = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31
            //public ArrayList EastVelocityToYellowBlackCyan_GPGGA = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-7-31

            //public ArrayList NorthVelocityToBlackWhite_Null = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList NorthVelocityToSixColor_Null = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList NorthVelocityToRedBlueGreen_Null = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList NorthVelocityToYellowBlackCyan_Null = new ArrayList();   //北分量RGB 参考GPS //LPJ 2013-12-3

            //public ArrayList EastVelocityToBlackWhite_Null = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList EastVelocityToSixColor_Null = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList EastVelocityToRedBlueGreen_Null = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-12-3
            //public ArrayList EastVelocityToYellowBlackCyan_Null = new ArrayList();   //东分量RGB 参考GPS //LPJ 2013-12-3
            #endregion
        }
        //private EnsemblesInfo dat0 = new EnsemblesInfo();
        //private EnsemblesInfo dat1 = new EnsemblesInfo();
        //private EnsemblesInfo dat = new EnsemblesInfo();   //JZH 2011-12-23 读取整个回放数据组 
        //private EnsemblesInfo GPSdata = new EnsemblesInfo();  //Modified 2011-9-20 add
        private EnsemblesInfo EnsemblesInfoToStore = new EnsemblesInfo();
        private EnsemblesInfo SaveEnsemblesInfo = new EnsemblesInfo();

        [Serializable]
        public struct Velocity   //LPJ 2013-11-18 将该类设为共有类
        {
            public float VX;
            public float VY;
            public float VZ;
        }
 
        [StructLayout(LayoutKind.Explicit)]
        private struct TestUnion
        {
            [FieldOffset(0)]
            public byte A;
            [FieldOffset(1)]
            public byte B;
            [FieldOffset(2)]
            public byte C;
            [FieldOffset(3)]
            public byte D;
            [FieldOffset(0)]
            public float Float;
            [FieldOffset(0)]
            public int Int;
        }

        object l = new object();
        static object locker1 = new object();
        static object locker = new object();
        //static object lockerRiver = new object();

        static System.Timers.Timer RealTimeProcessingTimer;  //JZH 2012-03-21 实时数据解析定时器
        private int iRealTimeInterval = 200;                 //JZH 2012-03-21 实时数据解析定时器间隔

        delegate void InitialParamDelegate();  //JZH 2012-03-21 定义一个初始化的委托，供回放定时器载入回放数据异常使用
        //InitialParamDelegate InitialParam;     //JZH 2012-03-21

        static System.Timers.Timer PlayBackTimer;

        private TestUnion ByteArrayToNumber;

        Point UTMpoint;        //Modified 2011-9-23
        //int UTMpointY;        //Modified 2011-9-23
        DisplayDelegate DecodeBytesData;//声明这个委托，用以执行航行线程（时钟线程）
        delegate void GPSDelegate(string s); //定义一个委托
        delegate void PlayBackDelegate(); //定义一个委托
        delegate void DisplayDelegate(); //定义一个委托
        //GPSDelegate getGPS_spDATA;
        PlayBackDelegate PlayBack;
        //DisplayDelegate DecodeBytesDataGPS;//LPJ 2013-11-14 声明这个委托，用以执行GPS安装校正

        //private DirectoryInfo Dinfo;

        Bitmap headingBitmap;
        Bitmap pitchBitmap;
        Bitmap rollBitmap;
        //Modified 2011-9-10
        //Bitmap TrackForwardBitmap;
        //Bitmap TrackPauseBitmap;
        //Bitmap TrackStopBitmap;

        private SerialPort sp;//用默认值初始化串口;
        private SerialPort GPS_sp;

        private List<float> GPS_UTCTime = new List<float>(); //LPJ 2014-7-21
        private List<double> GPGGA_Latitude = new List<double>();  //LPJ 2014-7-21
        private List<double> GPGGA_Longitude = new List<double>();  //LPJ 2014-7-21

        float lastGPS_UTCTime; //LPJ 2016-8-11
        double lastGPGGA_Latitude;  //LPJ 2016-8-11
        double lastGPGGA_Longitude;  //LPJ 2016-8-11

        private ArrayList BytesArray = new ArrayList();
        //private Object thisLock = new Object();
        //Modified 2011-12-14, with the help from 中海达 李炜
        //private List<ArrayClass> RiverLeftBankFlowDataList = new List<ArrayClass>();
        //private List<ArrayClass> RiverRightBankFlowDataList = new List<ArrayClass>();
        //ArrayClass[] RightBankArrayClassData;
        //ArrayClass[] LeftBankArrayClassData;

        static int restoreNum = 500;
        int FuTuHeight_WC = 11;
        int FuTuHeight_WA = 11;
        int payloadLen = 0;
        int preNum = 0;//28位 样本名E0000000（8位）+20位
        int HeaderFlagNum = 0;
        //int EnsembleNumber = 1;
        //int EsnNum = 50;
        int currentTotalNum = 0;   //Modified 2011-8-1 
        //int GPSstoredNumber = 0;    //Modified, 2011-8-5 add to find if GPS data missing*****************************
        int CCC = 0; //count of calls, computed for remainder
        int callNum = 0;
        int gpsFlag = 0;  //Modified 2011-11-2 to check the GPS synchronization
        int ggaNum = 0;
        int vtgNum = 0;
        int hdtNum = 0;
        int rotNum = 0;
        int totalNum = 0;
        int MeasTotalNum = 0; //LPJ 2012-5-4 记录开始测量后保存的ensemble总数
        //int fn = 1;
        //int CurrentGPSFileNumber = 0; //Modified 2011-8-30
        //int SaveGPSFileNumber = 0;   //LPJ 2012-5-4
        //int setAveragePoints = 5; //Modified 2011-9-2
        int setAveragePoints = 1;  //JZH 2012-01-31 debug
        int setAverageScale = 100; //Modified 2011-9-2
        int GPSdataCount = 0;
        private int maxCells = 0;
        //private int BinDataFileNum = 0;
        private int EnsembleNumOfAllFiles;
        private int PlayBackTimeLenth = 1000;//回放每个样本的时间间隔// original //Modified 2011-07-11 changing from 10 to 1000, the results is no difference
        private int setPlaybackTimeLength = 1000; //add 2011-07-12 Modified
        private int BinDataEnsembleNum = 0;
        //private int preBlockNum = -1;
        private int CurrentIndexOfEnsemblesInfoToStore;
        private int CurrentNumXFromMousePosion;
        private int CurrentNumYFromMousePosion;
        //private int BinDataEnsembleNum = 0;
        private int fileNum = 0;
        private static int HDRLEN = 0;
        private static int MaxArray = 11;
        private int PacketPointer = 0;
        public int Version_1 = 1;
        public int Version_2 = 2;
        public int DP_ProVersion = 2;
        public int GPSFileCount = 0;

        //double theta = 0;

        float[,] arrCorrelation;
        float[,] arrAmplitude;
        float cellSize = 0;
        long cells = 0;
        float upBlank = 0;
        float insDep = 0;
        float BlankSize = 0.0f;
        int WaterAvgNum = 2; //LPJ 2013-6-21
        //float TimeBtwnPings = 0.1f; //LPJ 2013-6-21
        //float BTblankSize = 0.25f; //LPJ 2013-8-1
        float fSalinity = 0; //LPJ 2013-9-29

        //float timeKnot = 0;
        float VXsum = 0.0f;         // Modified 2011-8-4 compute combined water velocity  ******************
        float VXstore = 0.0f;
        float VYstore = 0.0f;
        float GPS_FloatLatitude = 0;
        float GPS_FloatLongitude = 0;
        float VYsum = 0.0f;
        private float LimiteVelocity = 10;
        private float MaxVelocityByCostommer = 10;//最大水速测量范围
        private float ClickPzn = 1;
        private float adjustedMultiple = 1;

        public bool projectHasStarted = false;
        public bool playBackMode = false; //Modified 2011-8-23  
        private bool PlayBackPauseFlag = true; //LPJ 2013-9-18
        //private bool CommandChangedFlag = true;
        private bool MouseDownFlag = false;
        private bool HeaderFlag = false;//校验开始16字节是否为0x80
        private bool DrawRecFlag = false;
        private bool TrackDisplayerPanelMaxDisPlayer = false;
        //private bool ConfigChangedFlag = true;
        //bool startPrintIndicator = false; //Modified 2011-8-3   HHHHHHHH
        bool PickAndDecodeEnsemble_FunctionIsFree = true;
        bool GPSCompass = false; //Modified 2011-7-15, 增加GPS罗经 checkBox.增加GPSCompass
        //bool hasCreatedProject = false;
        //bool projectPause = true;
        bool HasCheckedPayload = false;
        bool StartRecord = false;
        //bool displayAverageVelocity = false;
        //bool displayAverageVelocity = true;   //JZH 2011-12-29 初始化为true,即checkBoxAverageVelocity默认为选中；

        public string CurrentPlaybackDirectory; //HHHHHHHHHHHHH Modified, 2011-8-2
        public string playbackGPSdataPath;      //HHHHHHHHHHHHH Modified, 2011-8-2
        public String ProjectName = "";
        public String ProjectFullName = "";    //LPJ 2013-4-16 输入的工程名加时间
        public string OldProjectName = "Project Name"; //LPJ 2012-6-13
        public string newPath;                                  // File path for configuration File
        public string RiverPlaybackPath;
        public string PathStr;  //LPJ 2013-5-30 将路径设置为公有变量
        //private string DisPlayTimeLenth = string.Empty;
        private string VelocityID = "E000001\0";
        private string InstrumentID = "E000002\0";
        private string EarthID = "E000003\0";
        private string AmplitudeID = "E000004\0";
        private string CorrelationID = "E000005\0";
        private string BeamNID = "E000006\0";
        private string XfrmNID = "E000007\0";
        private string EnsembleDataID = "E000008\0";
        private string AncillaryID = "E000009\0";
        private string BottomTrackID = "E000010\0";
        private string NMEAID = "E000011\0";
        private string GPS_receiveData = string.Empty;
        //string GPS_dataToEnsemble = string.Empty;
        string gpsTime = "000000";
        string gpsShipSpeed = "000000";
        string GPS_latitude = "0000.000"; //Modified 2011-7-25
        string GPS_longitude = "00000.000";
        float StartLongitude = 0; // = "00000.000"; //Modified 2011-11-12 default to 0,0
        float StartLatitude = 0;

        string[] StartLongitudeText; // = new string[8]; //
        string[] StartLatitudeText;
        string NorthSouth = "N";
        string EastWest = "E";
        string ReceiveBufferString = "";
        //"º"
        //string VXread;// = "";
        //string VYread;// = "";
        //string GPSInfo = string.Empty;
        string GPS_HDT = "0.0";
        //string GPS_ROT = "0.0";
        //string addNum = "";
        String GPSdisplayData = String.Empty;
        String GPSInfoData = String.Empty;  //2011-8-10 Modified, found the some \r\n are mssing
        String defaultGPGGA = "$GPGGA,0,0,N,0,E,0,0,0,0,M,0,M,0,0*00\r\n";
        String defaultGPVTG = "$GPVTG,000.0,T,000.0,M,000.0,N,000.0,K,0*N\r\n"; //$GPVTG,360.0,T,348.7,M,000.0,N,000.0,K*43
        String defaultGPHDT = "$HEHDT,0.0,T*00\r\n";
        String defaultGPROT = "$HEROT,0.0,A*00\r\n";
        String GPS_GGAbuffer = "$GPGGA,000000.00,0000.0000,N,00000.00,E,0,0,0,0,M,0,M,0,0*00\r\n"; //$GPGGA, hhmmss.ss, ddmm.mmmm, n, dddmm.mmmm, e, q, ss
        String GPS_VTGbuffer = "$GPVTG,0,T,0,M,0,N,0,K,0*N\r\n";
        String GPS_HDTbuffer = "$HEHDT,0.0,T*00\r\n";
        String GPS_ROTbuffer = "$HEROT,0.0,A*00\r\n";
        //string Version_1_CurrentGPSFileName = "GPSdata.txt";
        //string Version_2_CurrentGPSFileName = "GPSdata000000.txt";

        float currentX = 0;
        float currentY = 0;
        float FloatLatitude;
        float FloatLongitude;
        float originLat;
        float originLong;
        //float previousXposition = 0;
        //float previousYposition = 0;

        bool TrackForward = true;
        bool TrackPause = false;
        bool TrackStop = false;
        int PausePoint = 0;
        //double topLatitudeOfDisplayArea = 0; //SailTrackCurrentDisplayTop;
        //double bottomLatitudeOfDisplayArea = 609; //SailTrackCurrentDisplayTop + panelHeight;
        //double leftLongitudeOfDisplayArea = 0; //(double)SailTrackCurrentDisplayLeft;
        //double rightLongitudeOfDisplayArea = 772; //(double)SailTrackCurrentDisplayTop;

        //bool RiverPause = false; //Modified 2011-11-27 change to pause true
        //private void RiverPauseButton_Click(object sender, EventArgs e)
        //{
        //    RiverPause = !RiverPause;
        //    if (RiverPause == false && playBackMode == true)
        //    {
        //        if (PlayBackTimeLenth < 200)
        //        {
        //            PlayBackTimeLenth = 200;
        //        }
        //        PlayBackTimer.Stop();
        //        PlayBackTimer.Close();
        //        PlayBackTimer = new System.Timers.Timer();
        //        PlayBackTimer.Elapsed += new System.Timers.ElapsedEventHandler(PlayBackCenter);
        //        PlayBackTimer.Interval = setPlaybackTimeLength;
        //        PlayBack = new PlayBackDelegate(RefreshPanels);//委托指针指向 SetPosion 函数
        //        ProcessBar.Refresh();
        //        PlayBackTimer.Start();
        //    }
        //}
        Position_Transform PTransform = new Position_Transform();
        Position_Transform PTFM = new Position_Transform();

        Point UperLeftOfDisplayRectangle = new Point(0, 0);      //左上角坐标
        Point LowerRightOfDisplayRectagle = new Point(772, 614);

        private bool bStartEdge = false; //LPJ 2013-5-22

        /// <summary>
        /// Start the first edge measurement.
        /// </summary>
        public void btnStartEdge() //LPJ 2013-5-22
        {
            //iCount = 0;

            bStartEdge = true;

            iStartMeasQ++;

            // Create a ensemble name based on the Site Name and the date and time
            _ensOutputFileName = labelSiteName.Text + "_" + DateTime.Now.ToString(@"yyyyMMdd_HHmmss");

            projectHasStarted = true;
            //hasCreatedProject = true;
            this.Text = Path.Combine(newPath, ProjectFullName);  //LPJ 2013-4-16

            //清空计算的流量数据
            ClearSaveEnsemblesInfo();     //LPJ 2012-9-24
            ClearSaveEnsemblesGPSInfo();  //LPJ 2012-9-24  

            //LPJ 2012-9-26 添加初始化  --start
            //fn = 1;
            //SaveGPSFileNumber = 0;
            //EnsembleNumber = 1;
            MeasTotalNum = 0;
            totalNum = 0;
            fileNum = 0;
            GGAsaveCount = 0; //LPJ 2012-10-10 初始化GPS数据个数
            //WriteAllSettingsToFiles(); //将配置信息写入文件中  //LPJ 2013-5-22 配置信息文件重新考虑是否写入
            //WriteSmartPageToFile(newPath + "\\SysCfg\\Config.cfg"); //LPJ 2013-6-21 将smartPage页中的信息写入
            ////LPJ 2012-9-26 添加初始化  --end

            ////LPJ 2013-8-2 将配置信息保存到lastTimeCfg中
            //File.Copy(newPath + "\\SysCfg\\" + "Config.cfg",
            //       Directory.GetCurrentDirectory() + "\\dp300Data" + "\\LastTimeCfg" + "\\Config.cfg", true);

            #region 保存配置文件
            WriteSmartPageToFile(Path.Combine(newPath, ProjectFullName + ".cfg"));
            //File.Copy(newPath + ".cfg", Directory.GetCurrentDirectory() + "\\dp300Data" +  "\\Config.cfg", true);
            #endregion

            //LPJ 2012-10-10 初始化流量计算参数--start
            RTIdata.Clear();
            //fAccuEast = 0;
            //fAccuNorth = 0;
            //fAccuLength = 0;
            //fGAccVx = 0;
            //fGAccVy = 0;
            //fMeasArea = 0;
            //fMeasRiverWidth = 0;

            //dTopFlow = 0;
            //dMeasuredFlow = 0;
            //dBottomFlow = 0;
            //dLeftFlow = 0; //LPJ 2013-6-5 清除记录
            //dRightFlow = 0;

            arrayListEastLength.Clear();
            arrayListNorthLength.Clear();
            arrayListBottomDepth.Clear();

            leftBank.Clear();
            rightBank.Clear();
            //LPJ 2012-10-10 初始化流量计算参数--end

            //LPJ 2012-10-11 点击开始测流后，清空EnsembleInfoToStore的数据，从现在开始绘制新的流量图---start
            ClearEnsemblesInfoToStore();  //LPJ 2012-10-11
            ClearEnsemblesGPSInfo();      //LPJ 2012-10-11
            //LPJ 2012-10-11 点击开始测流后，清空EnsembleInfoToStore的数据，从现在开始绘制新的流量图---end

            //LPJ 2013-2-21 点击“开始测量”后，弹出“设置起始岸”对话框 --start
            GetEdgeSetting();
            
            SetStartBank setStartBank = new SetStartBank(edgeSetting);

            setStartBank.ShowDialog();
            if (setStartBank.bSetStartBank)
            {
                if (setStartBank.bStartLeftBank)
                {
                    //radioButtonLeftToRight.Checked = true;
                    //comboBoxLeftBankStyle.SelectedIndex = setStartBank.iStartStyle;
                    //numericUpDownLeftBankPara.Value = setStartBank.dStartPara;
                    //numericUpDownLeftDist.Text = setStartBank.strStartDistance;
                    labelStartEdge.Text = Resource1.String226;
                    if (setStartBank.iStartStyle == 0)
                        labelLeftType.Text = Resource1.String221;
                    else if (setStartBank.iStartStyle == 1)
                        labelLeftType.Text = Resource1.String222;
                    else
                        labelLeftType.Text = Resource1.String223;
                    labelLeftRef.Text = SetStartBank.dStartPara.ToString();
                    labelLeftDis.Text = setStartBank.strStartDistance;

                    labelLeftRef.Top = labelLeftType.Top;

                    bStartLeftEdge = true;
                    CurrentEdge = TRANSECT_EDGE_LEFT;
                }
                else
                {
                    //radioButtonRightToLeft.Checked = true;
                    //comboBoxRightBankStyle.SelectedIndex = setStartBank.iStartStyle;
                    //numericUpDownRightBankPara.Value = setStartBank.dStartPara;
                    //numericUpDownRightDist.Text = setStartBank.strStartDistance;

                    labelStartEdge.Text = Resource1.String227;
                    if (setStartBank.iStartStyle == 0)
                        labelRightType.Text = Resource1.String221;
                    else if (setStartBank.iStartStyle == 1)
                        labelRightType.Text = Resource1.String222;
                    else
                        labelRightType.Text = Resource1.String223;
                    labelRightRef.Text = SetStartBank.dStartPara.ToString();
                    labelRightDis.Text = setStartBank.strStartDistance;

                    labelRightRef.Top = labelRightType.Top;

                    bStartLeftEdge = false;
                    
                    CurrentEdge = TRANSECT_EDGE_RIGHT;
                }
                CurrentState = TRANSECT_STATE_EDGE;

                if (labelLeftType.Text == Resource1.String221) //LPJ 2013-6-22
                    EdgeType[0] = 0;
                else if (labelLeftType.Text == Resource1.String222)
                    EdgeType[0] = 1;
                else
                    EdgeType[0] = 2;
                EdgeDistance[0] = double.Parse(labelLeftDis.Text);//FrmEdgeSetting.edgeSet.dLeftDis;
                EdgeReference[0] = double.Parse(labelLeftDis.Text);// FrmEdgeSetting.edgeSet.dLeftRef;
                
                if (labelRightType.Text == Resource1.String221) //LPJ 2013-6-22
                    EdgeType[1] = 0;
                else if (labelRightType.Text == Resource1.String222)
                    EdgeType[1] = 1;
                else
                    EdgeType[1] = 2;                
                EdgeDistance[1] = double.Parse(labelRightDis.Text);// FrmEdgeSetting.edgeSet.dRightDis;
                EdgeReference[1] = double.Parse(labelRightDis.Text);//FrmEdgeSetting.edgeSet.dRightRef;
            }

            //LPJ 2013-2-21 点击“开始测量”后，弹出“设置起始岸”对话框 --end
            bStartMeasQ = true;

            //frmMeasurement = new FrmMeasurement(2); //LPJ 2013-6-18
            //frmMeasurement.ShowDialog(); //LPJ 2013-6-18
            //if (frmMeasurement.bMoving) //LPJ 2013-6-18
            //{
            //    btnMoving(); //LPJ 2013-6-18
            //}


            // QRev
            // Parse the Start Edge value
            // Set to 0.0 if any errors
            double dStartDist = 0.0;
            try
            {
                // Parse the distance
                dStartDist = double.Parse(setStartBank.strStartDistance);
            }
            catch(Exception e)
            {
                // If exception leave as 0.0
                dStartDist = 0.0;
            }

            // QRev
            // Create a QRev Transect
            CreateQRevTransect(_ensOutputFileName + ".ens", edgeSetting, systSet, CommandList);

            // QRev
            // Set all the start edge settings
            SetQRevStartEdgeSettings(bStartLeftEdge,                 // Is starting on left or right side
                                    dStartDist,                      // Start distance
                                    setStartBank.iStartStyle,        // Start Edge Type (rectangular or angled)
                                    SetStartBank.dStartPara,         // Start Coeffienct
                                    edgeSetting.iTopEstimate,        // Top Method
                                    edgeSetting.iBottomEstimate,     // Bottom Method
                                    edgeSetting.dPowerCurveCoeff);   // Power Curve Coeffienct
        }
        public void btnMoving() //LPJ 2013-5-22
        {
            bStartEdge = false;

            // QRev 
            // Stop the QRev Start Edge Counter
            StopQRevStartEdgeCounter(bStartLeftEdge);

            CurrentState = TRANSECT_STATE_MOVING;

            //frmMeasurement = new FrmMeasurement(3); //LPJ 2013-6-18
            //frmMeasurement.ShowDialog(); //LPJ 2013-6-18
            //if (frmMeasurement.bEndEdge) //LPJ 2013-6-18
            //{
            //    btnEndEdge(); //LPJ 2013-6-18
            //}
        }
        private bool bEndEdge = false; //LPJ 2013-5-22
        private bool bStartLeftEdge = true;
        public void btnEndEdge() //LPJ 2013-5-22
        {
            bEndEdge = true;
            //LPJ 2013-2-21 点击“结束测量”后，弹出“设置终止岸”对话框 --start
            GetEdgeSetting();
            SetFinishBank setFinishBank = new SetFinishBank(edgeSetting);
            setFinishBank.ShowDialog();
            if (setFinishBank.bSetFinishBank)
            {
                //LPJ 2013-4-3 --start
                CalculateShoreFlowParam param = new CalculateShoreFlowParam();
                param.RiverDischarge_A = (double)SetFinishBank.dFinishPara; 
                
                //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1 当单位为英制时
                if (!bEnglish2Metric)
                {
                    param.RiverDischargeDraft = projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text),1);
                    param.RiverDischargeDistance = projectUnit.FeetToMeter(double.Parse(setFinishBank.strFinishDistance),1);
                }
                else
                {
                    param.RiverDischargeDraft = double.Parse(labelTransducerDepth.Text);
                    param.RiverDischargeDistance = double.Parse(setFinishBank.strFinishDistance);
                }
               
                param.RiverDischargeInstrument.RiverDischargeBeamAngle = 20;        //ADCP参数
                param.RiverDischargeConditions.RiverDischargeMinNG4 = 1;  //判断GOODBIn条件
                //LPJ 2013-4-3 --end

                if (bStartLeftEdge)
                {
                    //radioButtonLeftToRight.Checked = true;
                    //comboBoxRightBankStyle.SelectedIndex = setFinishBank.iFinishStyle;
                    //numericUpDownRightBankPara.Value = setFinishBank.dFinishPara;
                    //numericUpDownRightDist.Text = setFinishBank.strFinishDistance;

                    if (setFinishBank.iFinishStyle == 0)
                        labelRightType.Text = Resource1.String221;
                    else if (setFinishBank.iFinishStyle == 1)
                        labelRightType.Text = Resource1.String222;
                    else
                        labelRightType.Text = Resource1.String223;
                    labelRightRef.Text = SetFinishBank.dFinishPara.ToString();
                    labelRightDis.Text = setFinishBank.strFinishDistance;

                    labelRightRef.Top = labelRightType.Top;

                    CurrentEdge = TRANSECT_EDGE_RIGHT;
                    
                }
                else
                {
                    //radioButtonLeftToRight.Checked = false;
                    //comboBoxLeftBankStyle.SelectedIndex = setFinishBank.iFinishStyle;
                    //numericUpDownLeftBankPara.Value = setFinishBank.dFinishPara;
                    //numericUpDownLeftDist.Text = setFinishBank.strFinishDistance;

                    if (setFinishBank.iFinishStyle == 0)
                        labelLeftType.Text = Resource1.String221;
                    else if (setFinishBank.iFinishStyle == 1)
                        labelLeftType.Text = Resource1.String222;
                    else
                        labelLeftType.Text = Resource1.String223;
                    labelLeftRef.Text = SetFinishBank.dFinishPara.ToString();
                    labelLeftDis.Text = setFinishBank.strFinishDistance;

                    CurrentEdge = TRANSECT_EDGE_LEFT;
                }
                CurrentState = TRANSECT_STATE_EDGE;

                if (labelLeftType.Text == Resource1.String221) //LPJ 2013-6-22
                    EdgeType[0] = 0;
                else if (labelLeftType.Text == Resource1.String222)
                    EdgeType[0] = 1;
                else
                    EdgeType[0] = 2;
                EdgeDistance[0] = double.Parse(labelLeftDis.Text);//FrmEdgeSetting.edgeSet.dLeftDis;
                EdgeReference[0] = double.Parse(labelLeftDis.Text);//FrmEdgeSetting.edgeSet.dLeftRef;

                if (labelRightType.Text == Resource1.String221) //LPJ 2013-6-22
                    EdgeType[1] = 0;
                else if (labelRightType.Text == Resource1.String222)
                    EdgeType[1] = 1;
                else
                    EdgeType[1] = 2;
                EdgeDistance[1] = double.Parse(labelRightDis.Text);// FrmEdgeSetting.edgeSet.dRightDis;
                EdgeReference[1] = double.Parse(labelRightDis.Text);//FrmEdgeSetting.edgeSet.dRightRef;


            }
            //LPJ 2013-2-21 点击“结束测量”后，弹出“设置终止岸”对话框 --end

            // QRev
            // Parse the Start Edge value
            // Set to 0.0 if any errors
            double dEndDist = 0.0;
            try
            {
                // Parse the distance
                dEndDist = double.Parse(setFinishBank.strFinishDistance);
            }
            catch (Exception e)
            {
                // If exception leave as 0.0
                dEndDist = 0.0;
            }

            // QRev
            // Start the End Edge
            SetQRevEndEdgeSettings(bStartLeftEdge,                      // Start on right or left side
                                    dEndDist,                           // End Edge Distance
                                    setFinishBank.iFinishStyle,         // Edge Type (rectangular or vertical)
                                    SetFinishBank.dFinishPara);         // End Edge Coeffienct
        }

        //JZH 2012-01-15 流量测量按钮
        bool bStartMeasQ = false;
        public int iStartMeasQ = 0;   //LPJ 2012-9-26 增加变量判断点击开始测流的次数，从而确定是否新建项目
      /*
        private void RefreshQPanel()
        {
            //计算岸边平均水深
            double dLeftShoreAvgDepth = 0.0;
            dLeftShoreAvgDepth = CalculateAvgShoreDepth(leftBank) + double.Parse(labelTransducerDepth.Text);

            //计算岸边面积
            double dLeftShoreWidth = double.Parse(labelLeftDis.Text);
            double dLeftShoreCoff = double.Parse(labelLeftRef.Text);
            dGLeftShoreArea = CalculateShoreArea(dLeftShoreAvgDepth, dLeftShoreWidth, dLeftShoreCoff);

            //计算岸边平均水深
            double dRightShoreAvgDepth = 0.0;
            dRightShoreAvgDepth = CalculateAvgShoreDepth(rightBank) + double.Parse(labelTransducerDepth.Text);  //JZH 2012-04-17 

            //计算岸边面积                                    
            double dRightShoreWidth = double.Parse(labelRightDis.Text);
            double dRightShoreCoff = double.Parse(labelRightRef.Text);
            dGRightShoreArea = CalculateShoreArea(dRightShoreAvgDepth, dRightShoreWidth, dRightShoreCoff);

            current_TotalQ = (dLeftFlow + dRightFlow + dTopFlow + dMeasuredFlow + dBottomFlow).ToString("0.000");

            //JZH 2012-04-18 更新流量面板
            //label_TopDiacharge.Text = dTopFlow.ToString("0.00");
            //label_MiddleDischarge.Text = dMeasuredFlow.ToString("0.00");
            //label_BottomeDischarge.Text = dBottomFlow.ToString("0.00");
            //label_LeftBankDischarge.Text = dLeftFlow.ToString("0.00");
            //label_RightBankDischarge.Text = dRightFlow.ToString("0.00");

            current_TopQ = dTopFlow.ToString("0.00"); //LPJ 2013-7-3
            current_MiddleQ = dMeasuredFlow.ToString("0.00");
            current_BottomQ = dBottomFlow.ToString("0.00");
            current_LeftQ = dLeftFlow.ToString("0.00");
            current_RightQ = dRightFlow.ToString("0.00");

            //JZH 2012-04-18 更新导航面板
            float fTotalWidth = Math.Abs(fMeasRiverWidth) + float.Parse(labelLeftDis.Text) + float.Parse(labelRightDis.Text);
            current_RiverWidth = fTotalWidth.ToString("0.00");  //河宽

            double dTotalArea = 0;
            dTotalArea = Math.Abs(fMeasArea) + dGLeftShoreArea + dGRightShoreArea;  //总面积
            current_Area = dTotalArea.ToString("0.00");
            double dMeanTemp = 0;    //平均流向
            if (dGMeanFlowDir < 0)
                dMeanTemp = dGMeanFlowDir / Math.PI * 180 + 360;
            else
                dMeanTemp = dGMeanFlowDir / Math.PI * 180;
            current_MeanFlowDir = dMeanTemp.ToString("0.00");

            double dMeanFlowAverage = 0;  //平均流速
            if (dTotalArea == 0)
                dMeanFlowAverage = 0;
            else
                dMeanFlowAverage = Math.Abs(dLeftFlow + dRightFlow + dTopFlow + dMeasuredFlow + dBottomFlow) / dTotalArea;
            current_MeanFLowVel = dMeanFlowAverage.ToString("0.00");

          //  LV_MeasuredQ_Paint(); //LPJ　2013-5-17
            this.BeginInvoke(RefreshDishargePanel);//LPJ 2013-6-8
            this.BeginInvoke(RefreshNavigation); //LPJ 2013-6-18
            this.BeginInvoke(RefreshOthers);  //LPJ 2013-6-18
        }
        */
     
        //LPJ 2012-5-23 正则判断----start
        public static bool ValidateUserInput(String value, int kind)
        {
            string RegularExpressions = null;
            switch (kind)
            {
                case 1: //数字
                    RegularExpressions = "^[0-9]*$"; break;
                case 2: //整数
                    RegularExpressions = "^-?\\d+$"; break;
                case 3: //正整数
                    RegularExpressions = "^[0-9]*[1-9][0-9]*$"; break;
                case 4: //负整数
                    RegularExpressions = "^-[0-9]*[1-9][0-9]*$"; break;
                case 5: //正整数，0
                    RegularExpressions = "^\\d+$"; break;
                case 6: //负整数，0
                    RegularExpressions = "^((-\\d+)|(0+))$"; break;
                case 7: //浮点数
                    RegularExpressions = "^(-?\\d+)(\\.\\d+)?$"; break;
                case 8: //正浮点数
                    RegularExpressions = "^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"; break;
                case 9: //负浮点数
                    RegularExpressions = "^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"; break;
                case 10: //正浮点数，0
                    RegularExpressions = "^\\d+(\\.\\d+)?$"; break;
                case 11: //负浮点数，0
                    RegularExpressions = "^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"; break;
                case 12:
                    RegularExpressions = @"^([0-9]+|[0-9]+\.{0,1}[0-9]*)$"; break;
                default: break;
            }
            Match m = Regex.Match(value, RegularExpressions);
            if (m.Success) return true; else return false;
        }

        public static void ValidateCharInput(object sender, KeyPressEventArgs e)
        {
            //IsNumber：指定字符串中位于指定位置的字符是否属于数字类别 
            //IsPunctuation：指定字符串中位于指定位置的字符是否属于标点符号类别 
            //IsControl：指定字符串中位于指定位置的字符是否属于控制字符类别 
            if (!Char.IsNumber(e.KeyChar) && !Char.IsPunctuation(e.KeyChar) && !Char.IsControl(e.KeyChar) && (e.KeyChar != 45))
            {
                e.Handled = true;
            }
            else if (Char.IsPunctuation(e.KeyChar))
            {
                if (e.KeyChar == '.')
                {
                    if (((TextBox)sender).Text.LastIndexOf('.') != -1)
                    {
                        e.Handled = true;
                    }
                }
                else if (e.KeyChar == '-')
                {
                    if (((TextBox)sender).Text.Length != 0)
                    {
                        e.Handled = true;
                    }
                }
                else
                {
                    e.Handled = true;
                }
            }

        }

        //LPJ 2012-5-23 添加提示框
        //private JDL.UILib.BalloonTip m_tip = new BalloonTip();
        //int tabpage = -1;
        //int maintabpage = -1;
        private void TxtBox_TextChanged(object sender, EventArgs e)
        {
        }

        private void TxtBox_KeyPress(object sender, KeyPressEventArgs e)
        {
            ValidateCharInput(sender, e);
        }
        //LPJ 2012-5-23 正则判断----end

        //LPJ 2012-5-23 添加提示框---start
        //private void ShowTip(Control ctl, string str)
        //{
        //    m_tip.Visible = true;
        //    BalloonTipIconType icontype = (BalloonTipIconType)3;
        //    Point pos = ctl.PointToScreen(new Point(10, 2));
        //    int x = pos.X;
        //    int y = pos.Y;
        //    this.m_tip.ShowCloseButton = false;
        //    this.m_tip.ShowAt(x, y, "", str, icontype);
        //}
        //private void ShowTip2(JDL.UILib.BalloonTip Tips, Point pnt, string str)
        //{
        //    Tips.Visible = true;
        //    BalloonTipIconType iconType = (BalloonTipIconType)0;
        //    Tips.ShowCloseButton = false;
        //    Tips.ShowAt(pnt.X, pnt.Y, "", str, iconType);
        //}
        //private void ShowTip3(JDL.UILib.BalloonTip Tips, Point pnt, int dis, string str)
        //{
        //    Tips.Visible = true;
        //    BalloonTipIconType icontype = (BalloonTipIconType)0;
        //    Tips.ShowCloseButton = false;
        //    Tips.ShowAt(pnt.X + dis, pnt.Y, "", str, icontype);
        //}
        //LPJ 2012-5-23 添加提示框---end

        private void tabControl4_SelectedIndexChanged(object sender, EventArgs e)
        {
            ResizeControls(); //LPJ 2013-8-5 
        } //LPJ 2012-5-25 不能更改当前tabpage页 --------end

      
        private void tabControl4_KeyDown(object sender, KeyEventArgs e)
        {
            //在这里设置快捷键
           
        }

        //LPJ 2012-06-12 点击串口选项时更新系统串口号 ------end

        delegate void DischargePanelDelegate(); //LPJ 2013-6-8
        DischargePanelDelegate RefreshDishargePanel; //LPJ 2013-6-8

        delegate void NavigationListViewDelegate(); //LPJ 2013-6-18
        NavigationListViewDelegate RefreshNavigation; //LPJ 2013-6-18

        delegate void OthersListViewDelegate(); //LPJ 2013-6-18
        OthersListViewDelegate RefreshOthers; //LPJ 2013-6-18

        delegate void CalDischargeDelegate();
        CalDischargeDelegate CalDischargeRefresh;
        

        #region 将流量信息中的每个item设为全局变量 //LPJ 2013-6-8
        ListViewItem Top_Q = new ListViewItem();
        ListViewItem Middle_Q = new ListViewItem();
        ListViewItem Bottom_Q = new ListViewItem();
        ListViewItem Left_Q = new ListViewItem();
        ListViewItem Right_Q = new ListViewItem();
        ListViewItem total_Q = new ListViewItem();

        ListViewItem itemBoatSpeed = new ListViewItem();
        ListViewItem itemBoatDirection = new ListViewItem();
        ListViewItem itemWaterSpeed = new ListViewItem();
        ListViewItem itemWaterDirection = new ListViewItem();
        ListViewItem itemLength = new ListViewItem();
        ListViewItem itemMSLength = new ListViewItem();
        ListViewItem itemMSDirection = new ListViewItem();
        ListViewItem itemRiverWidth = new ListViewItem();
        ListViewItem itemTotalArea = new ListViewItem();
        ListViewItem itemMeanSpeed = new ListViewItem();
        ListViewItem itemMeanDirection = new ListViewItem();

        ListViewItem itemDate = new ListViewItem(); //LPJ 2013-9-23 将时间分为日期和时间，以能够完整显示
        ListViewItem itemTime = new ListViewItem();
        ListViewItem itemTotalTime = new ListViewItem();
        ListViewItem itemTotalNum = new ListViewItem();
        ListViewItem itemCurrentDepth = new ListViewItem();
        ListViewItem itemLongitude = new ListViewItem();
        ListViewItem itemLatitude = new ListViewItem();
        ListViewItem itemHeading = new ListViewItem();
        ListViewItem itemPitch = new ListViewItem();
        ListViewItem itemRoll = new ListViewItem();
        ListViewItem itemTrueN = new ListViewItem();

        //ListViewItem itemCourseMG_GPS = new ListViewItem();  //LPJ 2015-9-22
        //ListViewItem itemCourseMG_BT = new ListViewItem();   //LPJ 2015-9-22
        //ListViewItem itemDMG_GPS = new ListViewItem();  //LPJ 2015-9-22
        //ListViewItem itemDMG_BT = new ListViewItem();   //LPJ 2015-9-22
        //ListViewItem itemAccuracy = new ListViewItem(); //LPJ2015-10-27 校准精度
        #endregion

        private void LV_Measured_QPaint() //LPJ 2013-6-8 将每次不更改的内容写在这里
        {
            string strUnit = "m";

            //if ("English" == defCfg.DefCfgInf.Unit)
            //if(Resource1.String237==labelUnit.Text)
            if (!bEnglish2Metric)
            {
                //将单位转换为英制
                strUnit = "ft";
            }
            lV_MeasuredQ.Items.Clear(); //LPJ 2013-6-26

            //流量汇总信息
            ListViewGroup Discharge_lvg = new ListViewGroup();
            //Discharge_lvg.Header = "流量信息";
            Discharge_lvg.Header = Resource1.String92;
            Discharge_lvg.HeaderAlignment = HorizontalAlignment.Left;
            this.lV_MeasuredQ.Groups.Add(Discharge_lvg);
            this.lV_MeasuredQ.ShowGroups = true;

            //Top_Q.Text = "顶部流量(m3/s)";
            Top_Q.Text = Resource1.String93 + "(" + strUnit + "3/s)";
            Top_Q.SubItems.Add(current_TopQ);
            Discharge_lvg.Items.Add(Top_Q);
            this.lV_MeasuredQ.Items.Add(Top_Q);

            //Middle_Q.Text = "实测流量(m3/s)";
            Middle_Q.Text = Resource1.String94 + "(" + strUnit + "3/s)";
            Middle_Q.SubItems.Add(current_MiddleQ);
            Discharge_lvg.Items.Add(Middle_Q);
            this.lV_MeasuredQ.Items.Add(Middle_Q);

            //Bottom_Q.Text = "底部流量(m3/s)";
            Bottom_Q.Text = Resource1.String95 + "(" + strUnit + "3/s)";
            Bottom_Q.SubItems.Add(current_BottomQ);
            Discharge_lvg.Items.Add(Bottom_Q);
            this.lV_MeasuredQ.Items.Add(Bottom_Q);

            //Left_Q.Text = "左岸流量(m3/s)";
            Left_Q.Text = Resource1.String96 + "(" + strUnit + "3/s)";
            Left_Q.SubItems.Add(current_LeftQ);
            Discharge_lvg.Items.Add(Left_Q);
            this.lV_MeasuredQ.Items.Add(Left_Q);

            //Right_Q.Text = "右岸流量(m3/s)";
            Right_Q.Text = Resource1.String97 + "(" + strUnit + "3/s)";
            Right_Q.SubItems.Add(current_RightQ);
            Discharge_lvg.Items.Add(Right_Q);
            this.lV_MeasuredQ.Items.Add(Right_Q);

            total_Q.ForeColor = Color.Red; //LPJ 2013-6-7
            //total_Q.Text = "总流量(m3/s)";
            total_Q.Text = Resource1.String98 + "(" + strUnit + "3/s)";
            total_Q.SubItems.Add(current_TotalQ);
            Discharge_lvg.Items.Add(total_Q);
            this.lV_MeasuredQ.Items.Add(total_Q);


        }

        //LPJ 2013-7-3 将流量信息的实时变量放在这里 --start
        private string current_TopQ;
        private string current_MiddleQ;
        private string current_BottomQ;
        private string current_LeftQ;
        private string current_RightQ;
        private string current_TotalQ;

        private string current_BoatSpeed;
        private string current_BoatDirection;
        private string current_WaterSpeed;
        private string current_WaterDirection;
        private string current_Length;
        private string current_DistanceMG;
        private string current_CourseMG;
        private string current_RiverWidth;
        private string current_Area;
        private string current_MeanFLowVel;
        private string current_MeanFlowDir;

        private string current_DataTime;
        private string current_TotalTimelabel;
        private string current_EsambleTotaleNum;
        private string current_Depth;
        private string current_LongitudeText;
        private string current_LatitudeText;
        private string current_WPHeading;
        private string current_WPPitch;
        private string current_WPRoll;
        private string current_TrueNorthText;

        //private string current_CourseMG_GPS;  //LPJ 2015-9-22
        //private string current_CourseMG_BT;   //LPJ 2015-9-22
        //private string current_DMG_BT;
        //private string current_DMG_GPS;
        //private string current_Accuracy; //LPJ 2015-10-27
        //LPJ 2013-7-3 将流量信息的实时变量放在这里 --end

        private void InitDischargeParameter()  //LPJ 2013-8-1 初始化流量信息栏 
        {
            current_TopQ = "-";
            current_MiddleQ = "-";
            current_BottomQ = "-";
            current_LeftQ = "-";
            current_RightQ = "-";
            current_TotalQ = "-";

            current_BoatSpeed = "-";
            current_BoatDirection = "-";
            current_WaterSpeed = "-";
            current_WaterDirection = "-";
            current_Length = "-";
            current_DistanceMG = "-";
            current_CourseMG = "-";
            current_RiverWidth = "-";
            current_Area = "-";
            current_MeanFLowVel = "-";
            current_MeanFlowDir = "-";

            current_DataTime = "-";
            current_TotalTimelabel = "-";
            current_EsambleTotaleNum = "-";
            current_Depth = "-";
            current_LongitudeText = "-";
            current_LatitudeText = "-";
            current_WPHeading = "-";
            current_WPPitch = "-";
            current_WPRoll = "-";
            current_TrueNorthText = "-";

            //current_CourseMG_BT = "-";  //LPJ 2015-9-22
            //current_CourseMG_GPS = "-";
            //current_DMG_BT = "-";
            //current_DMG_GPS = "-";
            //current_Accuracy = "-";
        }

        private void LV_MeasuredDischarge_Paint() //LPJ 2013-6-8 将每次需要更改的内容写在这里
        {
            Top_Q.SubItems[1].Text=current_TopQ;
            Middle_Q.SubItems[1].Text=current_MiddleQ;
            Bottom_Q.SubItems[1].Text=current_BottomQ;
            Left_Q.SubItems[1].Text=current_LeftQ;
            Right_Q.SubItems[1].Text=current_RightQ;
            total_Q.SubItems[1].ForeColor = Color.Red; //LPJ 2013-6-11 将总流量颜色设为红色
            total_Q.SubItems[1].Text=current_TotalQ;

        }

        private void listView_Navigation_Paint() //LPJ 2013-6-18 将导航信息栏每次不更改的内容写在这里
        {
            string strUnit = "m";
            //if ("English" == defCfg.DefCfgInf.Unit)
            //if (Resource1.String237 == labelUnit.Text)
            if (!bEnglish2Metric)
            {
                //将单位转换为英制
                strUnit = "ft";
            }

            listView_Navigation.Items.Clear(); //LPJ 2013-6-26

            //导航信息
            ListViewGroup Navigation_lvg = new ListViewGroup();
            //Navigation_lvg.Header = "导航信息";
            Navigation_lvg.Header = Resource1.String99;
            Navigation_lvg.HeaderAlignment = HorizontalAlignment.Left;
            this.listView_Navigation.Groups.Add(Navigation_lvg);
            this.listView_Navigation.ShowGroups = true;

            itemBoatSpeed.Text = Resource1.String100 + "(" + strUnit + "/s)";// "船速(m/s)";
            itemBoatSpeed.SubItems.Add(current_BoatSpeed);
            Navigation_lvg.Items.Add(itemBoatSpeed);
            this.listView_Navigation.Items.Add(itemBoatSpeed);

            itemBoatDirection.Text = Resource1.String101 + "(Deg)";//"船向(Deg)";
            itemBoatDirection.SubItems.Add(current_BoatDirection);
            Navigation_lvg.Items.Add(itemBoatDirection);
            this.listView_Navigation.Items.Add(itemBoatDirection);

            itemWaterSpeed.Text = Resource1.String102 + "(" + strUnit + "/s)";// "流速(m/s)";
            itemWaterSpeed.SubItems.Add(current_WaterSpeed);
            Navigation_lvg.Items.Add(itemWaterSpeed);
            this.listView_Navigation.Items.Add(itemWaterSpeed);

            itemWaterDirection.Text = Resource1.String103 + "(Deg)";// "流向(Deg)";
            itemWaterDirection.SubItems.Add(current_WaterDirection);
            Navigation_lvg.Items.Add(itemWaterDirection);
            this.listView_Navigation.Items.Add(itemWaterDirection);

            itemLength.Text = Resource1.String104 + "(" + strUnit + ")";// "航迹长度(m)";
            itemLength.SubItems.Add(current_Length);
            Navigation_lvg.Items.Add(itemLength);
            this.listView_Navigation.Items.Add(itemLength);

            itemMSLength.Text = Resource1.String105 + "(" + strUnit + ")";// "直线距离(m)";
            itemMSLength.SubItems.Add(current_DistanceMG);
            Navigation_lvg.Items.Add(itemMSLength);
            this.listView_Navigation.Items.Add(itemMSLength);

            itemMSDirection.Text = Resource1.String106 + "(Deg)";// "直线方向(Deg)";
            itemMSDirection.SubItems.Add(current_CourseMG);
            Navigation_lvg.Items.Add(itemMSDirection);
            this.listView_Navigation.Items.Add(itemMSDirection);

            itemRiverWidth.Text = Resource1.String107 + "(" + strUnit + ")";// "河宽(m)";
            itemRiverWidth.SubItems.Add(current_RiverWidth);
            Navigation_lvg.Items.Add(itemRiverWidth);
            this.listView_Navigation.Items.Add(itemRiverWidth);

            itemTotalArea.Text = Resource1.String108 + "(" + strUnit + "2)"; //"总面积(m2)";
            itemTotalArea.SubItems.Add(current_Area);
            Navigation_lvg.Items.Add(itemTotalArea);
            this.listView_Navigation.Items.Add(itemTotalArea);

            itemMeanSpeed.Text = Resource1.String109 + "(" + strUnit + "/s)"; //"平均流速(m/s)";
            itemMeanSpeed.SubItems.Add(current_MeanFLowVel);
            Navigation_lvg.Items.Add(itemMeanSpeed);
            this.listView_Navigation.Items.Add(itemMeanSpeed);

            itemMeanDirection.Text = Resource1.String110 + "(Deg)"; //"平均流向(Deg)";
            itemMeanDirection.SubItems.Add(current_MeanFlowDir);
            Navigation_lvg.Items.Add(itemMeanDirection);
            this.listView_Navigation.Items.Add(itemMeanDirection);
        }

        private void Navigation_Paint() //LPJ 2013-6-18 将导航信息栏每次需要更改的内容写在这里
        {
            itemBoatSpeed.SubItems[1].Text = current_BoatSpeed;
            itemBoatDirection.SubItems[1].Text = current_BoatDirection;
            itemWaterSpeed.SubItems[1].Text = current_WaterSpeed;
            itemWaterDirection.SubItems[1].Text = current_WaterDirection;
            itemLength.SubItems[1].Text = current_Length;
            itemMSLength.SubItems[1].Text = current_DistanceMG;
            itemMSDirection.SubItems[1].Text = current_CourseMG;
            itemRiverWidth.SubItems[1].Text = current_RiverWidth;
            itemTotalArea.SubItems[1].Text = current_Area;
            itemMeanSpeed.SubItems[1].Text = current_MeanFLowVel;
            itemMeanDirection.SubItems[1].Text = current_MeanFlowDir;
        }

        private void listView_Others_Paint() //LPJ 2013-6-18 将其他信息栏每次不更改的内容写在这里
        {
            string strUnit = "m";
            //if ("English" == defCfg.DefCfgInf.Unit)
            //if (Resource1.String237 == labelUnit.Text)
            if (!bEnglish2Metric)
            {
                //将单位转换为英制
                strUnit = "ft";
            }

            listView_Others.Items.Clear(); //LPJ 2013-6-26

            //其他信息
            ListViewGroup Others_lvg = new ListViewGroup();
            Others_lvg.Header = Resource1.String111; //"其他信息";
            Others_lvg.HeaderAlignment = HorizontalAlignment.Left;
            this.listView_Others.Groups.Add(Others_lvg);
            this.listView_Others.ShowGroups = true;

            string current_Date,current_Time; //LPJ 2013-9-23 将日期和时间分为两行显示
            try
            {
                string[] str = current_DataTime.Split(' ');
                current_Date = str[0];
                current_Time = str[1];
            }
            catch
            {
                current_Date = "-";
                current_Time = "-";
            }

            itemDate.Text = Resource1.String269; //日期
            itemDate.SubItems.Add(current_Date);
            Others_lvg.Items.Add(itemDate);
            this.listView_Others.Items.Add(itemDate);
            
            itemTime.Text = Resource1.String112; //"时间";
            itemTime.SubItems.Add(current_Time);
            Others_lvg.Items.Add(itemTime);
            this.listView_Others.Items.Add(itemTime);

            itemTotalTime.Text = Resource1.String113; //"测量时间";
            itemTotalTime.SubItems.Add(current_TotalTimelabel);
            Others_lvg.Items.Add(itemTotalTime);
            this.listView_Others.Items.Add(itemTotalTime);

            itemTotalNum.Text = Resource1.String114; //"测量总数";
            itemTotalNum.SubItems.Add(current_EsambleTotaleNum);
            Others_lvg.Items.Add(itemTotalNum);
            this.listView_Others.Items.Add(itemTotalNum);

            itemCurrentDepth.Text = Resource1.String115 + "(" + strUnit + ")"; //"当前水深(m)";
            itemCurrentDepth.SubItems.Add(current_Depth);
            Others_lvg.Items.Add(itemCurrentDepth);
            this.listView_Others.Items.Add(itemCurrentDepth);

            itemLongitude.Text = Resource1.String116 + "(Deg)"; //"经度";
            itemLongitude.SubItems.Add(current_LongitudeText);
            Others_lvg.Items.Add(itemLongitude);
            this.listView_Others.Items.Add(itemLongitude);

            itemLatitude.Text = Resource1.String117 + "(Deg)"; //"纬度";
            itemLatitude.SubItems.Add(current_LatitudeText);
            Others_lvg.Items.Add(itemLatitude);
            this.listView_Others.Items.Add(itemLatitude);

            itemHeading.Text = Resource1.String118 + "(Deg)"; //"艏向(Deg)";
            itemHeading.SubItems.Add(current_WPHeading);
            Others_lvg.Items.Add(itemHeading);
            this.listView_Others.Items.Add(itemHeading);


            itemPitch.Text = Resource1.String119 + "(Deg)"; //"纵倾(Deg)";
            itemPitch.SubItems.Add(current_WPPitch);
            Others_lvg.Items.Add(itemPitch);
            this.listView_Others.Items.Add(itemPitch);

            itemRoll.Text = Resource1.String120 + "(Deg)"; //"横摇(Deg)";
            itemRoll.SubItems.Add(current_WPRoll);
            Others_lvg.Items.Add(itemRoll);
            this.listView_Others.Items.Add(itemRoll);

            itemTrueN.Text = Resource1.String121 + "(Deg)"; //"真北(Deg)";
            itemTrueN.SubItems.Add(current_TrueNorthText);
            Others_lvg.Items.Add(itemTrueN);
            this.listView_Others.Items.Add(itemTrueN);

            /*   //LPJ 2015-11-8 校准数据显示
            itemDMG_GPS.Text = "DMG GPS (m)";  //LPJ 2015-9-22 
            itemDMG_GPS.SubItems.Add(current_DMG_GPS);
            Others_lvg.Items.Add(itemDMG_GPS);
            this.listView_Others.Items.Add(itemDMG_GPS);

            itemDMG_BT.Text = "DMG BT (m)";
            itemDMG_BT.SubItems.Add(current_DMG_BT);
            Others_lvg.Items.Add(itemDMG_BT);
            this.listView_Others.Items.Add(itemDMG_BT);

            itemAccuracy.Text = "Accuracy (%)";  //LPJ 2015-10-27 校准精度
            itemAccuracy.SubItems.Add(current_Accuracy);
            Others_lvg.Items.Add(itemAccuracy);
            this.listView_Others.Items.Add(itemAccuracy);

            itemCourseMG_GPS.Text = "CourseMG GPS (Deg)";
            itemCourseMG_GPS.SubItems.Add(current_CourseMG_GPS);
            Others_lvg.Items.Add(itemCourseMG_GPS);
            this.listView_Others.Items.Add(itemCourseMG_GPS);

            itemCourseMG_BT.Text = "CourseMG BT (Deg)";
            itemCourseMG_BT.SubItems.Add(current_CourseMG_BT);
            Others_lvg.Items.Add(itemCourseMG_BT);
            this.listView_Others.Items.Add(itemCourseMG_BT);
             */

        }

        private void Others_Paint() //LPJ 2013-6-18 将其他信息栏每次需要更改的内容写在这里
        {
            try
            {
                string[] str = current_DataTime.Split(' '); //LPJ 2013-9-23
                itemDate.SubItems[1].Text = str[0]; //LPJ 2013-9-23
                itemTime.SubItems[1].Text = str[1]; //LPJ 2013-9-23
            }
            catch
            {
            }

            itemTotalTime.SubItems[1].Text = current_TotalTimelabel;
            itemTotalNum.SubItems[1].Text = current_EsambleTotaleNum;
            itemCurrentDepth.SubItems[1].Text = current_Depth;
            itemLongitude.SubItems[1].Text = current_LongitudeText;
            itemLatitude.SubItems[1].Text = current_LatitudeText;
            itemHeading.SubItems[1].Text = current_WPHeading;
            itemPitch.SubItems[1].Text = current_WPPitch;
            itemRoll.SubItems[1].Text = current_WPRoll;
            itemTrueN.SubItems[1].Text = current_TrueNorthText;

            /*  //LPJ 2015-11-8 校准数据
            itemCourseMG_GPS.SubItems[1].Text = current_CourseMG_GPS; //LPJ 2015-9-22
            itemCourseMG_BT.SubItems[1].Text = current_CourseMG_BT;
            itemDMG_BT.SubItems[1].Text = current_DMG_BT;
            itemDMG_GPS.SubItems[1].Text = current_DMG_GPS;
            itemAccuracy.SubItems[1].Text = current_Accuracy; //LPJ 2015-10-27
             */

        }
        private void tabPage_BoatSpeed_Paint(object sender, PaintEventArgs e) //LPJ 2013-5-18 绘制船速
        {
            //lock (locker)
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, tabPage_BoatSpeed.DisplayRectangle);

                Graphics g = MainBuffer.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                //g.FillRectangle(Brushes.White, this.tabPage_BoatSpeed.ClientRectangle);
                g.FillRectangle(Brushes.White, 0, 0, tabPage_BoatSpeed.Width, tabPage_BoatSpeed.Height); //LPJ 2013-9-24
                Pen pline = new Pen(Color.Black, 1);
                g.DrawRectangle(pline, 50, 5, tabPage_BoatSpeed.Width - 55, tabPage_BoatSpeed.Height - 10);

                //LPJ 2013-5-25 设置参数控制最大值和最小值
                double min, max, unit;
                min = 0;
                max = 0;

                if (BinDataEnsembleNum > 0)
                {
                    //if ("English" == defCfg.DefCfgInf.Unit) //LPJ 2013-5-30 当单位为英制时
                    try //LPJ 2013-8-16
                    {
                        Velocity boatV = new Velocity();
                        double boatspeed = 0;
                        boatspeed = (double)EnsemblesInfoToStore.BoatSpeed[0];
                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-11-21
                        {
                            boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPS[0];
                            boatspeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                        }
                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-11-21
                        {
                            boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPGGA[0];
                            boatspeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                        }
                        else if (Resource1.String233 == labelVesselRef.Text)
                        {
                            boatspeed = 0;
                        }

                        if (boatspeed < 20)
                        {
                            min = boatspeed;
                            max = boatspeed;
                        }
                        for (int i = 0; i < BinDataEnsembleNum; i++)
                        {
                            boatspeed = (double)EnsemblesInfoToStore.BoatSpeed[i];
                            if ("GPS VTG" == labelVesselRef.Text)
                            {
                                boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPS[i];
                                boatspeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)
                            {
                                boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPGGA[i];
                                boatspeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                            }
                            if (boatspeed < 20) //LPJ 2013-5-30 当船速都有效时
                            {
                                if (min > boatspeed)
                                    min = boatspeed;
                                if (max < boatspeed)
                                    max = boatspeed;
                            }
                        }
                    }
                    catch
                    {
                    }
                }
                unit = (max - min) / 5.0;

                //绘制格网
                Pen pgray = new Pen(Color.DarkGray, 0.5f);
                for (int i = 1; i < 6; i++)
                {
                    Point pnt = new Point(12, (int)((i+1) / 6.0f * tabPage_BoatSpeed.Height - 18));
                    Font font = new System.Drawing.Font("Arial Narrow", 12);//字体

                    g.DrawLine(pgray, 50, (tabPage_BoatSpeed.Height - 15.0f) * i / 5.0f, tabPage_BoatSpeed.Width - 5, (tabPage_BoatSpeed.Height - 15.0f) * i / 5.0f);
                    //g.DrawString(((5 - i) / 5.0f).ToString("0.0"), font, Brushes.DarkBlue, pnt);

                    //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                    if (!bEnglish2Metric)
                        g.DrawString((projectUnit.MeterToFeet(min + unit * (5 - i),1)).ToString("0.00"), font, Brushes.DarkBlue, pnt);
                    else
                        g.DrawString((min + unit * (5 - i)).ToString("0.00"), font, Brushes.DarkBlue, pnt); //LPJ 2013-5-25 从最小值到最大值范围内
                }

                Font font1 = new System.Drawing.Font("Arial Narrow", 11); //LPJ 2013-6-13
                Point pnt1 = new Point(13, 0); //LPJ 2013-6-13
                //if (Resource1.String237 == labelUnit.Text)
                if (!bEnglish2Metric)
                    g.DrawString("(ft/s)", font1, Brushes.DarkBlue, pnt1); //LPJ 2013-6-13
                else
                    g.DrawString("(m/s)", font1, Brushes.DarkBlue, pnt1); //LPJ 2013-6-13

                Pen pblue = new Pen(Color.Blue, 2);
                float startY = 0.0f, lastY = 0.0f;
                try
                {
                    for (int i = 0; i < BinDataEnsembleNum; i++)
                    {
                        double yy = 0;
                        try //LPJ 2013-8-16
                        {
                            if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-11-21
                            {
                                Velocity boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPS[i];
                                yy = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                            }
                            else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-11-21
                            {
                                Velocity boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPGGA[i];
                                yy = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                                yy = 0;
                            else
                                yy = (double)EnsemblesInfoToStore.BoatSpeed[i];
                        }
                        catch
                        {
                        }

                        if (i == 0)
                            lastY = (float)yy;
                       
                        if (yy < 20)
                        {
                            startY = (float)yy;
                            float xscale = (float)(tabPage_BoatSpeed.Width - 55) / BinDataEnsembleNum;
                            int yscale = tabPage_BoatSpeed.Height - 15;
                            //  g.DrawLine(pblue, xscale * i + 30, (1 - lastY) * yscale, xscale * (i + 1) + 30, (1 - startY) * yscale);
                            g.DrawLine(pblue, xscale * i + 50, ((float)max - lastY) / (float)(max - min) * yscale+5, xscale * (i + 1) + 50, ((float)max - startY) / (float)(max - min) * yscale+5);

                            lastY = startY;
                        }
                        else //LPJ 2013-6-7
                        {
                            startY = lastY;
                            float xscale = (float)(tabPage_BoatSpeed.Width - 55) / (BinDataEnsembleNum );
                            int yscale = tabPage_BoatSpeed.Height - 10;
                            g.DrawLine(pblue, xscale * i + 50, ((float)max - lastY) / (float)(max - min) * yscale+5, xscale * (i + 1) + 50, ((float)max - startY) / (float)(max - min) * yscale+5);
                        }
                    }
                }
                catch
                {
                }

                MainBuffer.Render(e.Graphics);
                MainBuffer.Dispose();
            }
            catch(Exception ex)
            {
                MessageBox.Show("Boat Speed \r\n" + ex.Message);
            }

        }

        private void tabPage_WaterDirection_Paint(object sender, PaintEventArgs e)  //LPJ 2013-5-18 绘制流速方向图
        {
            //lock (locker)
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, tabPage_WaterDirection.DisplayRectangle);

                Graphics g = MainBuffer.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                g.FillRectangle(Brushes.White, this.tabPage_WaterDirection.ClientRectangle);
                Pen pline = new Pen(Color.Black, 1);
                g.DrawRectangle(pline, 50, 5, tabPage_WaterDirection.Width - 55, tabPage_WaterDirection.Height - 10);

                //绘制格网
                Pen pgray = new Pen(Color.DarkGray, 0.5f);
                for (int i = 1; i < 6; i++)
                {
                    Point pnt = new Point(12, (int)((i+1) / 5.0f * tabPage_WaterDirection.Height - 18));
                    Font font = new System.Drawing.Font("Arial Narrow", 12);//字体

                    g.DrawLine(pgray, 50, (tabPage_WaterDirection.Height - 10.0f) * i / 4.0f, tabPage_WaterDirection.Width - 5, (tabPage_WaterDirection.Height - 10.0f) * i / 4.0f);
                    //g.DrawString((180 - i*90).ToString("0.00"), font, Brushes.DarkBlue, pnt);
                    g.DrawString((360 - i * 90).ToString("00"), font, Brushes.DarkBlue, pnt);
                }
                Font font1 = new System.Drawing.Font("Arial Narrow", 10); //LPJ 2013-6-13
                Point pnt1 = new Point(13, 2); //LPJ 2013-6-13
                g.DrawString(Resource1.String216, font1, Brushes.DarkBlue, pnt1); //LPJ 2013-6-13

                Pen pblue = new Pen(Color.Green, 2);
                float startY = 0.0f, lastY = 0.0f;

                try
                {
                    for (int i = 0; i < BinDataEnsembleNum; i++)
                    {
                        startY = (float)((double)EnsemblesInfoToStore.WaterDir[i]);

                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                            startY = (float)((double)EnsemblesInfoToStore.WaterDir_GPS[i]);
                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                            startY = (float)((double)EnsemblesInfoToStore.WaterDir_GPGGA[i]);
                        else if (Resource1.String233 == labelVesselRef.Text)
                            startY = (float)((double)EnsemblesInfoToStore.WaterDir_Null[i]);

                        float xscale = (float)(tabPage_WaterDirection.Width - 55) / (BinDataEnsembleNum );
                        float yscale = (tabPage_WaterDirection.Height - 15) / 360.0f;
                        try
                        {
                            g.DrawLine(pblue, xscale * i + 50, (360 - lastY) * yscale+5, xscale * (i + 1) + 50, (360 - startY) * yscale+5);
                        }
                        catch
                        {
                        }
                        lastY = startY;
                    }
                }
                catch
                {
                }
                MainBuffer.Render(e.Graphics);
                MainBuffer.Dispose();
            }
            catch(Exception ex)
            {
                MessageBox.Show("Water Direction \r\n" + ex.Message);
            }
        }

        private void tabPage_Pitch_Paint(object sender, PaintEventArgs e)  //LPJ 2013-5-18 绘制Pitch
        {
            //lock (locker)
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, tabPage_Pitch.DisplayRectangle);

                Graphics g = MainBuffer.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                g.FillRectangle(Brushes.White, this.tabPage_Pitch.ClientRectangle);
                Pen pline = new Pen(Color.Black, 1);
                g.DrawRectangle(pline, 50, 5, tabPage_Pitch.Width - 55, tabPage_Pitch.Height - 10);

                //LPJ 2013-5-25 设置参数控制最大值和最小值
                float min, max, unit;
                min = 0;
                max = 1;
                if (BinDataEnsembleNum > 0)
                {
                    try
                    {
                        //在测量模式下，采用EnsemblesInfoToStore中的值
                        if (!playBackMode)
                        {
                            min = (float)EnsemblesInfoToStore.Pitch[0];
                            max = (float)EnsemblesInfoToStore.Pitch[0];
                            for (int i = 0; i < BinDataEnsembleNum; i++)
                            {
                                if (min > (float)EnsemblesInfoToStore.Pitch[i])
                                    min = (float)EnsemblesInfoToStore.Pitch[i];
                                if (max < (float)EnsemblesInfoToStore.Pitch[i])
                                    max = (float)EnsemblesInfoToStore.Pitch[i];
                            }
                        }
                        else  //在测量模式下，采用RTIdata中的值
                        {
                            min = RTIdata[0].A_Pitch;
                            max = RTIdata[0].A_Pitch;
                            for (int i = 0; i < BinDataEnsembleNum; i++)
                            {
                                if (min > RTIdata[i].A_Pitch)
                                    min = RTIdata[i].A_Pitch;
                                if (max < RTIdata[i].A_Pitch)
                                    max = RTIdata[i].A_Pitch;
                            }
                        }
                    }
                    catch
                    {
                    }
                }
                unit = (max - min) / 5.0f;

                //绘制格网
                Pen pgray = new Pen(Color.LightGray, 0.1f);
                for (int i = 1; i < 6; i++)
                {
                    Point pnt = new Point(12, (int)((i+1) / 6.0f * tabPage_Pitch.Height - 18));
                    Font font = new System.Drawing.Font("Arial Narrow", 12);//字体

                    g.DrawLine(pgray, 50, (tabPage_Pitch.Height - 10.0f) * i / 5.0f, tabPage_Pitch.Width - 5, (tabPage_Pitch.Height - 10.0f) * i / 5.0f);
                    //g.DrawString((10 - i * 2).ToString("0.0"), font, Brushes.DarkBlue, pnt);
                    g.DrawString((min + unit * (5 - i)).ToString("0.00"), font, Brushes.DarkBlue, pnt); //LPJ 2013-5-25 从最小值到最大值范围内              
                }

                Font font1 = new System.Drawing.Font("Arial Narrow", 10); //LPJ 2013-6-13
                Point pnt1 = new Point(13, 2); //LPJ 2013-6-13
                g.DrawString(Resource1.String216, font1, Brushes.DarkBlue, pnt1); //LPJ 2013-6-13

                Pen pblue = new Pen(Color.Purple, 2);
                float startY = 0.0f, lastY = 0.0f;

                try
                {
                    for (int i = 0; i < BinDataEnsembleNum; i++)
                    {
                        if (!playBackMode)
                            startY = (float)EnsemblesInfoToStore.Pitch[i];
                        else
                            startY = (float)RTIdata[i].A_Pitch;

                        if (i == 0)
                            lastY = startY;

                        float xscale = (float)(tabPage_Pitch.Width - 55) / (BinDataEnsembleNum );
                        float yscale = tabPage_Pitch.Height - 15;
                        //g.DrawLine(pblue, xscale * i + 30, (10-lastY) * yscale, xscale * (i + 1) + 30, (10-startY) * yscale);
                        g.DrawLine(pblue, xscale * i + 50, ((float)max - lastY) / (float)(max - min) * yscale+5, xscale * (i + 1) + 50, ((float)max - startY) / (float)(max - min) * yscale+5);
                        lastY = startY;
                    }
                }
                catch
                {
                }

                MainBuffer.Render(e.Graphics);
                MainBuffer.Dispose();
            }
            catch(Exception ex)
            {
                MessageBox.Show("Pitch \r\n" + ex.Message);
            }
        }

        private void tabPage_Roll_Paint(object sender, PaintEventArgs e)  //LPJ 2013-5-18 绘制Roll
        {
            //lock (locker)
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, tabPage_Roll.DisplayRectangle);

                Graphics g = MainBuffer.Graphics;
                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                g.FillRectangle(Brushes.White, this.tabPage_Roll.ClientRectangle);
                Pen pline = new Pen(Color.Black, 1);
                g.DrawRectangle(pline, 50, 5, tabPage_Roll.Width - 55, tabPage_Roll.Height - 10);

                //LPJ 2013-5-25 设置参数控制最大值和最小值
                float min, max, unit;
                min = 0;
                max = 1;
                if (BinDataEnsembleNum > 0)
                {
                    try
                    {
                        if (!playBackMode) //在测量模式下
                        {
                            if ((float)EnsemblesInfoToStore.Roll[0] > 0)
                            {
                                min = 180 - (float)EnsemblesInfoToStore.Roll[0];
                                max = 180 - (float)EnsemblesInfoToStore.Roll[0];
                            }
                            else
                            {
                                min = -180 - (float)EnsemblesInfoToStore.Roll[0];
                                max = -180 - (float)EnsemblesInfoToStore.Roll[0];
                            }

                            for (int i = 0; i < BinDataEnsembleNum; i++)
                            {
                                float fRoll = (float)EnsemblesInfoToStore.Roll[i];
                                if (fRoll > 0)
                                    fRoll = 180 - fRoll;
                                else
                                    fRoll = -180 - fRoll;

                                if (min > fRoll)
                                    min = fRoll;
                                if (max < fRoll)
                                    max = fRoll;
                            }
                        }
                        else //在回放模式下
                        {
                            if ((float)RTIdata[0].A_Roll > 0)
                            {
                                min = 180 - (float)RTIdata[0].A_Roll;
                                max = 180 - (float)RTIdata[0].A_Roll;
                            }
                            else
                            {
                                min = -180 - (float)RTIdata[0].A_Roll;
                                max = -180 - (float)RTIdata[0].A_Roll;
                            }

                            for (int i = 0; i < BinDataEnsembleNum; i++)
                            {
                                float fRoll = RTIdata[i].A_Roll;
                                if (fRoll > 0)
                                    fRoll = 180 - fRoll;
                                else
                                    fRoll = -180 - fRoll;

                                if (min > fRoll)
                                    min = fRoll;
                                if (max < fRoll)
                                    max = fRoll;
                            }
                        }
                    }
                    catch
                    {
                    }
                }
                unit = (max - min) / 5.0f;

                //绘制格网
                Pen pgray = new Pen(Color.DarkGray, 0.5f);
                for (int i = 1; i < 6; i++)
                {
                    //Point pnt = new Point(0, (int)(i / 5.0f * tabPage_Roll.Height - 18));
                    Point pnt = new Point(12, (int)((i + 1) / 6.0f * tabPage_Roll.Height - 18));
                    Font font = new System.Drawing.Font("Arial Narrow", 12);//字体

                    g.DrawLine(pgray, 50, (tabPage_Roll.Height - 10.0f) * i / 5.0f, tabPage_Roll.Width - 5, (tabPage_Roll.Height - 10.0f) * i / 5.0f);
                    //g.DrawString((10 - i * 2).ToString("0.0"), font, Brushes.DarkBlue, pnt);
                    g.DrawString((min + unit * (5 - i)).ToString("0.00"), font, Brushes.DarkBlue, pnt); //LPJ 2013-5-25 从最小值到最大值范围内               
                }

                Font font1 = new System.Drawing.Font("Arial Narrow", 10); //LPJ 2013-6-13
                Point pnt1 = new Point(13, 2); //LPJ 2013-6-13

                g.DrawString(Resource1.String216, font1, Brushes.DarkBlue, pnt1); //LPJ 2013-6-13

                Pen pblue = new Pen(Color.Magenta, 2);
                float startY = 0.0f, lastY = 0.0f;
                try
                {
                    for (int i = 0; i < BinDataEnsembleNum; i++)
                    {
                        float fRoll;
                        if (!playBackMode)
                            fRoll = (float)EnsemblesInfoToStore.Roll[i];
                        else
                            fRoll = RTIdata[i].A_Roll;
                        if (fRoll > 0)
                            startY = 180 - fRoll;
                        else
                            startY = -180 - fRoll;

                        if (i == 0)
                            lastY = startY;

                        float xscale = (float)(tabPage_Roll.Width - 55) / (BinDataEnsembleNum);
                        float yscale = tabPage_Roll.Height - 15.0f;
                        //g.DrawLine(pblue, xscale * i+30 , (10.0f - lastY) * yscale, xscale * (i + 1)+30 , (10.0f - startY) * yscale);
                        g.DrawLine(pblue, xscale * i + 50, ((float)max - lastY) / (float)(max - min) * yscale + 5, xscale * (i + 1) + 50, ((float)max - startY) / (float)(max - min) * yscale + 5);
                        lastY = startY;
                    }
                }
                catch
                {
                }
                MainBuffer.Render(e.Graphics);
                MainBuffer.Dispose();
            }
            catch(Exception ex)
            {
                MessageBox.Show("Roll \r\n" + ex.Message);
            }
        }

        private void tabPage_BoatWater_Paint(object sender, PaintEventArgs e)  //LPJ 2013-5-18 船速流速比
        {
            //lock (locker)
            try
            {
                BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
                BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, tabPage_BoatWater.DisplayRectangle);

                Graphics g = MainBuffer.Graphics;

                g.SmoothingMode = SmoothingMode.HighQuality;
                g.PixelOffsetMode = PixelOffsetMode.HighSpeed;

                g.FillRectangle(Brushes.White, this.tabPage_BoatWater.ClientRectangle);

                Pen pline = new Pen(Color.Black, 1);
                g.DrawRectangle(pline, 50, 5, tabPage_BoatWater.Width - 55, tabPage_BoatWater.Height - 10);

                //LPJ 2013-5-25 设置参数控制最大值和最小值
                double min, max, unit;
                min = 0;
                max = 1;
                try
                {
                    if (BinDataEnsembleNum > 0)
                    {
                        double BoatWater = (double)EnsemblesInfoToStore.BoatWater[0];
                        if ("GPS VTG" == labelVesselRef.Text)  //LPJ 2013-11-21
                        {
                            BoatWater = (double)EnsemblesInfoToStore.BoatWater_GPS[0];
                        }
                        else if ("GPS GGA" == labelVesselRef.Text)  //LPJ 2013-11-21
                        {
                            BoatWater = (double)EnsemblesInfoToStore.BoatWater_GPGGA[0];
                        }
                        else if (Resource1.String233 == labelVesselRef.Text)
                            BoatWater = 0;
                        min = BoatWater;
                        max = BoatWater;

                        for (int i = 0; i < BinDataEnsembleNum; i++)
                        {
                            BoatWater = (double)EnsemblesInfoToStore.BoatWater[i];
                            if ("GPS VTG" == labelVesselRef.Text)   //LPJ 2013-11-21
                            {
                                BoatWater = (double)EnsemblesInfoToStore.BoatWater_GPS[i];
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)   //LPJ 2013-11-21
                            {
                                BoatWater = (double)EnsemblesInfoToStore.BoatWater_GPGGA[i];
                            }

                            if (BoatWater < 20)
                            {
                                if (min > BoatWater)
                                    min = BoatWater;
                                if (max < BoatWater)
                                    max = BoatWater;
                            }
                        }

                    }
                }
                catch
                {
                    min = 0;
                    max = 1;
                }
                unit = (max - min) / 5.0;

                //绘制格网
                Pen pgray = new Pen(Color.DarkGray, 0.5f);
                for (int i = 1; i < 6; i++)
                {
                    Point pnt = new Point(12, (int)((i + 1) / 6.0f * tabPage_BoatWater.Height - 20));
                    Font font = new System.Drawing.Font("Arial Narrow", 12);//字体

                    g.DrawLine(pgray, 50, (tabPage_BoatWater.Height - 15.0f) * i / 5.0f + 5, tabPage_BoatWater.Width - 5, (tabPage_BoatWater.Height - 15.0f) * i / 5.0f + 5);
                    //g.DrawString((10-i*2).ToString("0.0"), font, Brushes.DarkBlue, pnt);

                    g.DrawString((min + unit * (5 - i)).ToString("0.0"), font, Brushes.DarkBlue, pnt); //LPJ 2013-5-25 从最小值到最大值范围内

                }

                Pen pblue = new Pen(Color.DarkOrange, 2);
                float startY = 0.0f, lastY = 0.0f;
                try
                {
                    for (int i = 0; i < BinDataEnsembleNum; i++)
                    {
                        if ((double)EnsemblesInfoToStore.BoatSpeed[i] < 20) //LPJ 2013-5-30 当船速有效时
                        {

                            startY = (float)((double)EnsemblesInfoToStore.BoatWater[i]);
                            if ("GPS VTG" == labelVesselRef.Text)  //LPJ 2013-11-21
                            {
                                startY =(float)( (double)EnsemblesInfoToStore.BoatWater_GPS[i]);
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)  //LPJ 2013-11-21
                            {
                                startY = (float)((double)EnsemblesInfoToStore.BoatWater_GPGGA[i]);
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                                startY = 0;

                            float xscale = (float)(tabPage_BoatWater.Width - 55) / (BinDataEnsembleNum);
                            float yscale = tabPage_BoatWater.Height - 15;

                            if (i == 0)
                                lastY = startY;

                            try
                            {
                                //g.DrawLine(pblue, xscale * i + 30, (10 - lastY) * yscale, xscale * (i + 1) + 30, (10 - startY) * yscale);
                                g.DrawLine(pblue, xscale * i + 50, ((float)max - lastY) / (float)(max - min) * yscale + 5, xscale * (i + 1) + 50, ((float)max - startY) / (float)(max - min) * yscale + 5);
                            }
                            catch
                            {
                            }
                            lastY = startY;
                        }
                    }
                }
                catch
                {
                }
                MainBuffer.Render(e.Graphics);
                MainBuffer.Dispose();
            }
            catch (Exception ex)
            {
                MessageBox.Show("Boat Water \r\n" + ex.Message);
            }
        }

        private SerialPort defaultSP;  //LPJ 2013-5-20
        private Queue defaultQueue;    //LPJ 2013-5-20
        //FormConnect connect;           //LPJ 2013-5-20
        private bool detected;         //LPJ 2013-5-20
        public DefaultCfg defCfg;      //LPJ 2013-5-20
        private Units projectUnit = new Units(); //LPJ 2013-5-28 定义一个对象，用于设置单位

        private string defaultADCP_PortName;//, defaultGPS_PortName; //LPJ 2013-6-21为默认的串口号，和波特率设置参数
        private int defaultADCP_Baudrate;//, defaultGPS_Baudrate; //LPJ 2013-6-21为默认的串口号，和波特率设置参数

        private bool CommandConnect()   //LPJ 2013-5-20 连接串口
        {
            defaultSP = new SerialPort("COM1", 115200, Parity.None, 8, StopBits.One);

            /*
            defaultSP.ReadBufferSize = 16 * 65536;
            defaultSP.BaudRate = 115200;
            defaultSP.StopBits = StopBits.One;
            defaultSP.Parity = Parity.None;
            defaultSP.DataBits = 8;
            defaultSP.Handshake = Handshake.None;//_serialPort.Handshake = Handshake.RequestToSend;
            defaultSP.DtrEnable = true;

            //Set the read/write timeouts
            defaultSP.ReadTimeout = 50;
            defaultSP.WriteTimeout = 500;
            */


            defaultQueue = new Queue();
 
            defaultADCP_PortName = "COM1";
            defaultADCP_Baudrate = 115200;

            defaultSP.PortName = defaultADCP_PortName;
            defaultSP.BaudRate = defaultADCP_Baudrate;
            defaultSP.DataReceived += new SerialDataReceivedEventHandler(defaultSP_DataReceived);

            //LPJ 2013-6-20 在连接仪器前，先读取配置文件信息

            if (!GetFileToSmartPage(Directory.GetCurrentDirectory() + "\\dp300Data" + "\\Config.cfg"))  //在测量模式下，文件名为当前路径下的last
            {
                MessageBox.Show(Resource1.String305);
                InitSmartPage();
            }
           
            defaultSP.PortName = defaultADCP_PortName;
            defaultSP.BaudRate = defaultADCP_Baudrate;

            //string cmd = defaultSP.PortName + "," + defaultSP.BaudRate;
            if (ConnectPort())//cmd))
            {
                //LPJ 2013-6-20 连接成功后，直接跳转到smartPage页
                tabControl4.SelectedIndex = 0;
                //   ResizeControls(); //LPJ 2013-8-5 
                ////LPJ 2013-8-5 在这里读取高级配置
            }
            else
            {
                //linkLabelGPSConf.Enabled = false;  //LPJ 2013-8-21
                //linkLabelSettingTime.Enabled = false;   //LPJ 2013-8-21

                ////btnGPSCalibration.Enabled = false; //LPJ 2013-11-15
                //linkLabelHeadingOffset.Enabled = false; //LPJ 2013-11-18
                //linkLabelBeamCheck.Enabled = false;
                //linkLabelCompassCalibration.Enabled = false;
                //linkLabelHeadingOffset.Enabled = false;
                //linkLabelSystemTest.Enabled = false;
                //linkLabelDownload.Enabled = false;
                //linkLabelUpdateFirmware.Enabled = false;

                sp.Close();
                return false;
            }
            return true;
        }
        Configurations.Configuration conf = new Configurations.Configuration();

        private const int TRANSECT_EDGE_LEFT = 0;
        private const int TRANSECT_EDGE_RIGHT = 1;

        private const int TRANSECT_STATE_STOP = 0;
        //private const int TRANSECT_STATE_COMPASSCAL = 1;
        //private const int TRANSECT_STATE_BEDSTATIONARY = 2;
        //private const int TRANSECT_STATE_BEDLOOP = 3;
        //private const int TRANSECT_STATE_SYSTEMTEST = 4;
        private const int TRANSECT_STATE_START = 5;
        private const int TRANSECT_STATE_EDGE = 6;
        private const int TRANSECT_STATE_MOVING = 7;

        string CommandList = "";
        private void SendStandardCommand() //用户模式下发送命令
        {
            string CMD;
            try
            {
                //CMD = "MODERIVER" + '\r';
                //sp.Write(CMD);//set default
                //CommandList += CMD + '\n';
                //Thread.Sleep(150);


                CMD = "CRSMODE " + systSet.iMeasurmentMode.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSVB " + systSet.iVerticalBeam.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSAUTOBIN " + systSet.iAutoBinSize.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSAUTOLAG " + systSet.iAutoLag.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSWPBN " + systSet.iBins.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSWPAI " + systSet.dAveragingInterval.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSMAXDEPTH " + systSet.dMaxMeasurementDepth.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSWPSWITCH " + systSet.dWpSwitchDepth.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSBTSWITCH " + systSet.dBtSwitchDepth.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                if (!bEnglish2Metric)
                {
                    CMD = "CRSXDCRDEPTH " + projectUnit.FeetToMeter(systSet.dTransducerDepth, 1).ToString() + '\r';
                }
                else
                {
                    CMD = "CRSXDCRDEPTH " + systSet.dTransducerDepth.ToString() + '\r';
                }
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CWSSC " + systSet.iWaterTemperatureSource.ToString();
                CMD += "," + systSet.iTransducerDepthSource.ToString();
                CMD += "," + systSet.iSalinitySource.ToString();
                CMD += "," + systSet.iSpeedOfSoundSource.ToString();
                CMD += "\r";
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                if (!bEnglish2Metric)
                {
                    CMD = "CWSS " + projectUnit.FeetToMeter(systSet.dSpeedOfSound, 1).ToString() + '\r';
                }
                else
                {
                    CMD = "CWSS " + systSet.dSpeedOfSound.ToString() + '\r';
                }
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSSALINITY " + systSet.dSalinity.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSTEMP " + systSet.dWaterTemperature.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSBTSNR " + systSet.dBtSNR.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CRSBTCOR " + systSet.dBtCorrelationThreshold.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CHO " + systSet.dHeadingOffset.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "CHS " + systSet.iHeadingRef.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                //labelSiteName.Text = FrmSiteInformation.siteInfo.siteName;
                //labelStationNumber.Text = FrmSiteInformation.siteInfo.stationNumber;
                //labelMeasNumber.Text = FrmSiteInformation.siteInfo.MeasNumber;
                //labelSiteComments.Text = FrmSiteInformation.siteInfo.comments;
                //siteInformation = GetSiteInformation(FrmSiteInformation.siteInfo);

                CMD = "CRSNAME " + labelSiteName.Text + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(500);

                CMD = "CRSNUMBER " + labelStationNumber.Text + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CurrentState = TRANSECT_STATE_START;
                CMD = "CRSTS " + TRANSECT_STATE_START.ToString() + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);

                CMD = "C232B " + systSet.strRS232 + '\r';
                sp.Write(CMD);
                CommandList += CMD + '\n';
                displayprocessbar(4, progressBar1);
                Thread.Sleep(150);
                //sp.Write("C485B " + frmsystemSet.systemSet.strRS485 + '\r');
                //Thread.Sleep(150);
                
                
            }
            catch (System.Exception e)
            {
                MessageBox.Show(e.Message);
            }
            progressBar1.Visible = false;
            progressBar1.Value = 0;

        }

        private bool ConnectPort()//string cmd)  //LPJ 2013-5-21 连接串口
        {
            detected = AutoDetect();

            if (detected) //串口检测在单独的线程上进行
            {
                //连接串口
                sp.PortName = defaultSP.PortName;
                sp.BaudRate = defaultSP.BaudRate;

                defaultSP.Close();
                //connect.Close();
                sp.Open(); //LPJ 2013-7-12
                sp.Write("STOP"+'\r'); //LPJ 2013-7-23 当连接仪器后，先发送STOP
                Thread.Sleep(150);
                return true;
            }
            else
            {
                defaultSP.Close();
                //connect.Close();
                FrmSetCmd setCommand = new FrmSetCmd();
                if (DialogResult.OK == setCommand.ShowDialog())
                {
                    try
                    {
                        defaultSP.PortName = setCommand.ADCPsp.PortName;
                        defaultSP.BaudRate = setCommand.ADCPsp.BaudRate;

                        //cmd = setCommand.ADCPsp.PortName + "," + setCommand.ADCPsp.BaudRate;
                        if (ConnectPort())//cmd))
                        {
                            return true;
                        }
                        else
                            return false;
                    }
                    catch
                    {
                        return false;
                    }
                }
                else
                {
                    setCommand.Close();
                    return false;
                }
            }
        }

        public bool bConnect = false; //LPJ 2013-7-12
        static object lockpack = new object();
        private bool AutoDetect()   //LPJ 2013-5-20 自动连接串口
        {
            if (defaultSP.IsOpen)
            {//该串口已经打开，提示不可用
                MessageBox.Show(Resource1.String286);
                return false;
            }
            else
            {
                try
                {
                    defaultSP.Open();
                    defaultSP.DataReceived -= new SerialDataReceivedEventHandler(defaultSP_DataReceived);
                    defaultSP.Write("STOP" + '\r');
                    Thread.Sleep(150);
                    defaultSP.DiscardInBuffer();
                    defaultSP.DataReceived += new SerialDataReceivedEventHandler(defaultSP_DataReceived);
                }
                catch//(Exception ex)
                {
                    //MessageBox.Show(ex.Message);
                    return false;
                }
                
                defaultSP.Write("FMSHOW" + '\r');
                Thread.Sleep(1000);
                int flag = 1;
                while (flag < 10)
                {
                    //Thread.Sleep(50);
                    if (defaultQueue.Count > 0)
                    {
                        string strpack = "";
                        while (defaultQueue.Count > 0)
                        {
                            ArrayList byteArray = new ArrayList();
                            byteArray.AddRange((byte[])defaultQueue.Dequeue());
                            byte[] pack = new byte[byteArray.Count];

                            for (int i = 0; i < byteArray.Count; i++)
                                pack[i] = (byte)byteArray[i];

                            strpack += Encoding.Default.GetString(pack);
                        }

                        //判读串口读取的内容，如果是ADCP发送BREAK返回的内容，则可得出该串口连接正常
                        if (strpack.Contains("Rowe Technologies Inc"))
                        {
                            bConnect = true; //LPJ 2013-7-12

                            labelSN.Text = defaultSP.PortName; //LPJ 2013-7-12 刷新串口号
                            //在这里提取SN号和固件版本号
                            string[] packet = strpack.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                            for (int i = 0; i < packet.Count(); i++)
                            {
                                if (packet[i].Contains("System Firmware Version"))
                                {
                                    string[] snPacket = packet[i].Split(':');

                                    //例如固件号为：System Firmware Version: 00.02.09 Jun  7 2012 06:24:01
                                    string strFirmWare = ""; //LPJ 2013-10-14 提取固件编号时，将时间的分号间隔划分了，因此需要重新添加上
                                    for (int k = 1; k < snPacket.Count(); k++)
                                    {
                                        if (k < snPacket.Count() - 1)
                                            strFirmWare += snPacket[k] + ":"; //固件版本号
                                        else
                                            strFirmWare += snPacket[k];
                                    }
                                    labelFirmWare.Text = strFirmWare;
                                }
                            }
                            #region 
                            defaultSP.Write("BREAK" + '\r');
                            Thread.Sleep(1000);

                            if (defaultQueue.Count > 0)
                            {
                                strpack = "";
                                while (defaultQueue.Count > 0)
                                {
                                    ArrayList byteArray = new ArrayList();
                                    byteArray.AddRange((byte[])defaultQueue.Dequeue());
                                    byte[] pack = new byte[byteArray.Count];

                                    for (int i = 0; i < byteArray.Count; i++)
                                        pack[i] = (byte)byteArray[i];

                                    strpack += Encoding.Default.GetString(pack);
                                }
                                
                                if (strpack.Contains("Rowe Technologies Inc"))
                                {
                                    packet = strpack.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                                    for (int i = 0; i < packet.Count(); i++)
                                    {
                                        if (packet[i].Contains("RIVER"))
                                        {
                                            string snPacket = packet[i + 1];
                                            labelSystemNumber.Text = snPacket; //仪器类型
                                        }
                                    }
                                }
                            }
                            #endregion

                            #region 发送SN命令  2016-12-14
                            defaultSP.Write("SN" + '\r');
                            Thread.Sleep(1000);

                            if (defaultQueue.Count > 0)
                            {
                                strpack = "";
                                while (defaultQueue.Count > 0)
                                {
                                    ArrayList byteArray = new ArrayList();
                                    byteArray.AddRange((byte[])defaultQueue.Dequeue());
                                    byte[] pack = new byte[byteArray.Count];

                                    for (int i = 0; i < byteArray.Count; i++)
                                        pack[i] = (byte)byteArray[i];

                                    strpack += Encoding.Default.GetString(pack);
                                }

                                if (strpack.Contains("SN"))  //LPJ 2016-12-14 显示仪器SN号
                                {
                                    string[] snPacket =strpack.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                                    labelInstrumentSN.Text = snPacket[1];
                                }
                            }
                            #endregion


                            return true;
                        }
                    }
                    flag++;
                }
                return false;
            }
        }
        private void defaultSP_DataReceived(object sender, SerialDataReceivedEventArgs e)  //LPJ 2013-5-20
        {
            lock (lockpack)
            {
                byte[] packet = new byte[defaultSP.BytesToRead];
                defaultSP.Read(packet, 0, packet.Length);
                defaultQueue.Enqueue(packet);
            }
        }

        List<float> fAverageX = new List<float>(); //LPJ 2013-7-3 该变量用于保存所有ensemble数据的X、Y平均流速
        List<float> fAverageY = new List<float>(); //LPJ 2013-7-3

        List<float> fAverageX_GPS = new List<float>(); //LPJ 2013-7-31 该变量用于保存所有ensemble数据的X、Y平均流速
        List<float> fAverageY_GPS = new List<float>(); //LPJ 2013-7-31

        List<float> fAverageX_GPGGA = new List<float>(); //LPJ 2013-7-31 该变量用于保存所有ensemble数据的X、Y平均流速
        List<float> fAverageY_GPGGA = new List<float>(); //LPJ 2013-7-31

        List<float> fAverageX_Null = new List<float>(); //LPJ 2013-12-3 该变量用于保存所有ensemble数据的X、Y平均流速
        List<float> fAverageY_Null = new List<float>(); //LPJ 2013-12-3

        private void AutoSizeGPS(PointF pnt) //LPJ 2013-6-3 航迹自动缩放
        {
            #region
           /*
            Point p = new Point();

            p.X = (int)(pnt.X / MouseWheelScale + ((float)MainGPSWidth / 2 + DragLengthX));
            p.Y = (int)(pnt.Y / MouseWheelScale + ((float)MainGPSHeight / 2 + DragLengthY));
            Rectangle r = new Rectangle(5, 5, panelGPSTrack.Width - 10, panelGPSTrack.Height - 10);
          
            if (!r.Contains(p))
            {
                DragLengthX = 0;
                DragLengthY = 0;
               
                p.X = (int)(pnt.X / MouseWheelScale + (float)MainGPSWidth / 2);
                p.Y = (int)(pnt.Y / MouseWheelScale + (float)MainGPSHeight / 2);
               
                if (!r.Contains(p))
                {
                    if (MouseWheelScale < 5)
                    {
                        MouseWheelScale++;
                    }
                    else
                    {
                        MouseWheelScale += 2;
                    }
                }
            }
            */
            #endregion

            Point p = new Point();

            p.X = (int)(pnt.X / MouseWheelScale + ((float)MainGPSWidth / 2 + DragLengthX));
            p.Y = (int)(pnt.Y / MouseWheelScale + ((float)MainGPSHeight / 2 + DragLengthY));
            Rectangle r = new Rectangle(5, 5, panelGPSTrack.Width - 10, panelGPSTrack.Height - 10);

            while (!r.Contains(p))
            {
                p.X = (int)(pnt.X / MouseWheelScale + ((float)MainGPSWidth / 2));
                p.Y = (int)(pnt.Y / MouseWheelScale + ((float)MainGPSHeight / 2));
                if (MouseWheelScale < 5)
                {
                    MouseWheelScale++;
                }
                else
                {
                    MouseWheelScale += 2;
                }
            }

        }

        private PointF TransToMapPoint(PointF pt)
        {
            PointF RealStartPointToStore = new PointF();
          
            RealStartPointToStore.X = pt.X;
            RealStartPointToStore.Y = pt.Y;
            return (RealStartPointToStore);
        }

        public DischargeSummary.Report report; //LPJ 2013-5-30
        public DischargeSummary.BasicMessage bMessage; //LPJ 2013-5-31
      
        private void GetDischarge(ref DischargeSummary.Report rep) //LPJ 2013-5-30 计算汇总流量
        {
            if (RTIdata.Count > 0)
            {
                CalDischarge calDischarge = new CalDischarge();
                //FrmChangeMode frmChangeMode = new FrmChangeMode(defCfg);

                //conf = frmChangeMode.GetConfiguration();//获取配置信息

                //获取流量配置信息
                if (labelTopEstimate.Text == Resource1.String33) 
                    conf.TopMode = 0;
                else if (labelTopEstimate.Text == Resource1.String224)
                    conf.TopMode = 1;
                else
                    conf.TopMode = 2;

                if (labelBottomEstimate.Text == Resource1.String33)
                    conf.BottomMode = 0;
                else
                    conf.BottomMode = 1;
                try
                {
                    conf.PowerCoff = float.Parse(labelPowerCurveCoeff.Text);
                }
                catch
                {
                    conf.PowerCoff = 0.1667f;
                }

                //conf.TopMode = comboBoxTopMode.SelectedIndex; //LPJ 2013-6-22
                //conf.BottomMode = comboBoxBottomMode.SelectedIndex;
                //conf.PowerCoff= (float)numericUpDownE.Value;
                //if (radioButtonLeftToRight.Checked)
                if (bStartLeftEdge)
                    conf.LeftToRight = true;  //0 代表左岸 1 代表右岸
                else
                    conf.LeftToRight = false;
                conf.ShoreEnsembleNumber = 10;

                //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1
                try
                {
                    float dTransducerDepth, dLeftDis, dRightDis;
                    try
                    {
                        dTransducerDepth = float.Parse(labelTransducerDepth.Text);
                    }
                    catch
                    {
                        dTransducerDepth = 0.1f;
                    }

                    try
                    {
                        dLeftDis = float.Parse(labelLeftDis.Text);
                    }
                    catch
                    {
                        dLeftDis = 0;
                    }
                    try
                    {
                        dRightDis = float.Parse(labelRightDis.Text);
                    }
                    catch
                    {
                        dRightDis = 0;
                    }
                   

                    if (!bEnglish2Metric)
                    {
                        conf.DraftInWater = (float)projectUnit.FeetToMeter(dTransducerDepth, 1);
                        conf.LeftDist = (float)projectUnit.FeetToMeter(dLeftDis, 1);
                        conf.RightDist = (float)projectUnit.FeetToMeter(dRightDis, 1);
                        bMessage.textTransducerDepth = (float)projectUnit.FeetToMeter(dTransducerDepth, 1);

                    }
                    else
                    {
                        conf.DraftInWater = dTransducerDepth;
                        conf.LeftDist = dLeftDis;
                        conf.RightDist = dRightDis;
                        bMessage.textTransducerDepth = dTransducerDepth;
                    }
                }
                catch
                {
                }

                //conf.LeftBankStyle= comboBoxLeftBankStyle.SelectedIndex;
                if (labelLeftType.Text == Resource1.String221)
                    conf.LeftBankStyle = 0;
                else if (labelLeftType.Text == Resource1.String222)
                    conf.LeftBankStyle = 1;
                else
                    conf.LeftBankStyle = 2;
                try
                {
                    conf.LeftBankPara = float.Parse(labelLeftRef.Text);
                }
                catch
                {
                    conf.LeftBankPara = 0.35f;
                }
               
                conf.LeftBankPings = dLeftShorePings;
               // conf.RightBankStyle = comboBoxRightBankStyle.SelectedIndex;
                if (labelRightType.Text == Resource1.String221) //LPJ 2013-6-22
                    conf.RightBankStyle = 0;
                else if (labelRightType.Text == Resource1.String222)
                    conf.RightBankStyle = 1;
                else
                    conf.RightBankStyle = 2;
                try
                {
                    conf.RightBankPara = float.Parse(labelRightRef.Text);
                }
                catch
                {
                    conf.RightBankPara = 0.35f;
                }
               
                conf.RightBankPings = dRightShorePings;
                conf.WPBinNum = (int)cells; //LPJ 2013-6-24
                conf.WPBinSize = cellSize;//LPJ 2013-6-24

                int iHeadingRef,iVesselRef;
                if (labelHeadingRef.Text == Resource1.String230)
                    iHeadingRef = 0;
                else
                    iHeadingRef = 1;

                if (labelVesselRef.Text == Resource1.String232)
                    iVesselRef = 0;
                else if (labelVesselRef.Text == "GPS VTG")
                    iVesselRef = 1;
                else if (labelVesselRef.Text == "GPS GGA")
                    iVesselRef = 2; 
                else
                    iVesselRef = 3;

                //rep = calDischarge.CalFlow(RTIdata, EnsembleNumOfAllFiles, conf, dLeftShorePings, dRightShorePings,
                //    iVesselRef, EnsemblesInfoToStore.GPS_VTGbuffer, iHeadingRef, EnsemblesInfoToStore.GPS_HDT, fHeadingOffset); //计算流量汇总数据
                rep = calDischarge.CalFlow(RTIdata, EnsembleNumOfAllFiles, conf, dLeftShorePings, dRightShorePings,
                  iVesselRef, EnsemblesInfoToStore.BoatV_GPS,EnsemblesInfoToStore.BoatV_GPGGA, iHeadingRef, EnsemblesInfoToStore.GPS_HDT, fHeadingOffset); //计算流量汇总数据 //LPJ 2013-11-18
                
                int x = PathStr.LastIndexOf("\\");
                rep.filepath = PathStr.Substring(0, x); //文件路径  ....//PlaybackData
                //x = rep.filepath.LastIndexOf("\\");
                //rep.fileName = rep.filepath.Substring(x + 1, rep.filepath.Length - x - 1);
                rep.fileName = PathStr.Substring(x + 1, PathStr.Length - x - 1);  //LPJ 2017-5-17 数据文件名

                //LPJ 2013-5-31 --start
                bMessage.filepath = rep.filepath; //LPJ 2017-5-17
                //bMessage.filepath = rep.filepath.Substring(0, rep.filepath.LastIndexOf("\\"));
                bMessage.textBinNum = (int)cells;
                bMessage.textBinSize =cellSize;

                bMessage.textBlankSize = BlankSize; //LPJ 2013-9-29
                bMessage.textWaterSalinity = fSalinity;  //LPJ 2013-9-29
                bMessage.textWaterXmt = WaterAvgNum;   //LPJ 2013-9-29

                //bMessage.textBlankSize = float.Parse(textBlankSize.Text);  //LPJ 2013-6-22
                //bMessage.textWaterSalinity = float.Parse(textWaterSalinity.Text); //LPJ 2013-6-22
                //bMessage.textWaterXmt = float.Parse(textWaterAvgNum.Text);
                
                bMessage.year = RTIdata[0].YYYY;
                bMessage.month = RTIdata[0].MM;
                bMessage.day = RTIdata[0].DD;

                bMessage.starthour = RTIdata[0].HH;
                bMessage.startmin = RTIdata[0].mm;
                bMessage.startsec = RTIdata[0].SS;
                bMessage.endhour = RTIdata[RTIdata.Count - 1].HH;
                bMessage.endmin = RTIdata[RTIdata.Count - 1].mm;
                bMessage.endsec = RTIdata[RTIdata.Count - 1].SS;
                //LPJ 2013-5-31 --end

            }
            
        } //

     
        ToolTip dataPageTooltip = new ToolTip(); 
        private void ShowDataPageTips()    // LPJ 2013-6-3 显示提示
        {
            dataPageTooltip.SetToolTip(this.label125, Resource1.String195);
            dataPageTooltip.SetToolTip(this.BtmCorrelationlistView,Resource1.String196);
            dataPageTooltip.SetToolTip(this.WaterCorrelationlistView, Resource1.String197);
            dataPageTooltip.SetToolTip(this.EarthGdPnglistView, Resource1.String198);
            dataPageTooltip.SetToolTip(this.BeamGdPnglistView, Resource1.String199);
        }

        private void DP300_Windows_Load(object sender, EventArgs e)
        {
            ShowDataPageTips();
            ResizeControls(); //LPJ 2013-6-24

            textBoxHelpTips.Text = Resource1.String19 + "\r\n\r\n" + Resource1.String217 + "\r\n\r\n" + Resource1.String218;

            getCheckednumber();  //-RMa 12/01/2020

        }

        private void btnSpeedFlow_Click(object sender, EventArgs e) //LPJ 2013-6-7 减速
        {
            PlayBackTimer.Stop();
            //if (dFlagRefreshTime >0)
            //{
            //    PlayBackTimeLenth = 1000;
            //    PlayBackTimer.Interval = PlayBackTimeLenth;
            //    dFlagRefreshTime = dFlagRefreshTime - 2;
            //    if (dFlagRefreshTime < 0)
            //        dFlagRefreshTime = 0;
            //}
            //else
            //{
            //    PlayBackTimeLenth = PlayBackTimeLenth * 2;
            //    PlayBackTimer.Interval = PlayBackTimeLenth;
            //    dFlagRefreshTime = 0;
            //}

            PlayBackTimeLenth *= 2;
            PlayBackTimer.Interval = PlayBackTimeLenth;

            if(!bPlaybackStop) //LPJ 2013-11-19
            PlayBackTimer.Start();
        }

        private void btnSpeedFast_Click(object sender, EventArgs e) //LPJ 2013-6-7 加速
        {
            PlayBackTimer.Stop();

            //if (PlayBackTimeLenth <= 1000) //当加速的速度
            //{
            //    PlayBackTimeLenth = 1000;
            //    PlayBackTimer.Interval = PlayBackTimeLenth;
            //    dFlagRefreshTime = dFlagRefreshTime + 2;
            //}
            //else
            //{
            //    dFlagRefreshTime = 0;
            //    PlayBackTimeLenth = PlayBackTimeLenth / 2;
            //    PlayBackTimer.Interval = PlayBackTimeLenth;
            //}

            PlayBackTimeLenth /= 2;
            if (PlayBackTimeLenth < 200)
                PlayBackTimeLenth = 200;
            PlayBackTimer.Interval = PlayBackTimeLenth;

            if(!bPlaybackStop) //LPJ 2013-11-19
            PlayBackTimer.Start();
        }

        #region comments
        private void EarthWaterlistView_MouseMove(object sender, MouseEventArgs e)
        {
            //地球坐标系下流速
            //labelComments.Text= Resource1.String200;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String200;
        }

        private void InstrmtWaterlistView_MouseMove(object sender, MouseEventArgs e)
        {
            //仪器坐标系下流速
            //labelComments.Text = Resource1.String201;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String201;
        }

        private void BeamWaterlistView_MouseMove(object sender, MouseEventArgs e)
        {
            //波束方向的流速
            //labelComments.Text = Resource1.String202;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String202;
        }

        private void tabPage1_MouseMove(object sender, MouseEventArgs e)
        {
            //地球坐标系下底跟踪速度
            //labelComments.Text = Resource1.String203;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String203;
        }

        private void tabPage2_MouseMove(object sender, MouseEventArgs e)
        {
            //仪器坐标系下底跟踪速度
            //labelComments.Text = Resource1.String204;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String204;
        }

        private void tabPage3_MouseMove(object sender, MouseEventArgs e)
        {
            //波束方向上的底跟踪速度
            //labelComments.Text = Resource1.String205;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String205;
        }

        private void EarthGdPnglistView_MouseMove(object sender, MouseEventArgs e)
        {
            //地球坐标系下的测流的pings良好数
            //labelComments.Text = Resource1.String206;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String206;
        }

        private void BeamGdPnglistView_MouseMove(object sender, MouseEventArgs e)
        {
            //测流（束）pings良好
            //labelComments.Text = Resource1.String207;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String207;
        }

        private void BEGdPngListview_MouseMove(object sender, MouseEventArgs e)
        {
            //底（地）pings良好
            //labelComments.Text = Resource1.String208;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String208;
        }

        private void BIGPnglistView_MouseMove(object sender, MouseEventArgs e)
        {
            //底（仪器）pings良好
            //labelComments.Text = Resource1.String209;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String209;
        }

        private void BBGPnglistView_MouseMove(object sender, MouseEventArgs e)
        {
            //底（束）pings良好
            //labelComments.Text = Resource1.String210;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String210;
        }

        private void WaterCorrelationlistView_MouseMove(object sender, MouseEventArgs e)
        {
            //测流相关性
            //labelComments.Text = Resource1.String211;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String211;
        }

        private void BtmCorrelationlistView_MouseMove(object sender, MouseEventArgs e)
        {
            //底跟踪相关性
            //labelComments.Text = Resource1.String212;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String212;
        }

        private void WaterAmplitudelistView_MouseMove(object sender, MouseEventArgs e)
        {
            //测流强度
            //labelComments.Text = Resource1.String213;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String213;
        }

        private void BtmAmplitudelistView_MouseMove(object sender, MouseEventArgs e)
        {
            //底跟踪强度
            //labelComments.Text = Resource1.String214;
            textBox1.Text = Resource1.String19 + "\r\n" + Resource1.String214;
        }
        #endregion

        private void panelGPSTrack_Paint(object sender, PaintEventArgs e) //LPJ 2013-6-9 绘制航迹图
        {
            BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;//获取当前绘图主缓冲区上下文
            BufferedGraphics MainBuffer;
            MainBuffer = currentContext.Allocate(e.Graphics, panelGPSTrack.DisplayRectangle);
         
            //设置双缓冲的图形缓冲区：使用指定的e.Graphics像素格式，创建指定大小panelTrackDisplayer.DisplayRectangle的图形缓冲区
            using (Graphics g1 = MainBuffer.Graphics)
            {
                //g1.SmoothingMode = SmoothingMode.HighQuality; //LPJ 2013-7-4
                //g1.PixelOffsetMode = PixelOffsetMode.HighSpeed; //LPJ 2013-7-4
               
                g1.FillRectangle(Brushes.White, 0, 0, panelGPSTrack.Width, panelGPSTrack.Height);
                g1.DrawRectangle(Pens.Black, 0, 0, panelGPSTrack.Width-5, panelGPSTrack.Height-1); //LPJ 2013-9-24
                        
                try
                {
                    //DrawGPSTrack(g);
                    MainGPSWidth = panelGPSTrack.Width;
                    MainGPSHeight = panelGPSTrack.Height;

                    Bitmap Bitmap = new Bitmap(pictureBox5.Image); //LPJ 2013-6-11

                    MaxDisplayHeight = MainGPSHeight;

                    CurrentDisplayUnit = (float)MainGPSWidth / 16;  //LPJ 2013-5-23

                    CurrentDisplayTop = panelGPSTrack.ClientRectangle.Top; //LPJ 2013-6-9
                    CurrentDisplayLeft = panelGPSTrack.ClientRectangle.Left;

                    scaleMultiple = (float)MainGPSHeight / MaxDisplayHeight;

                    //拖动积累量
                    DragLengthX *= (scaleMultiple / PreviousMultiple);//改变窗口大小后，相应更新拖动积累量的值//Modified 2011-11-15 cancel
                    DragLengthY *= (scaleMultiple / PreviousMultiple);//Modified 2011-11-15 cancel
                    PreviousMultiple = scaleMultiple;//Modified 2011-11-15 cancel

                    float OrignX = 0;
                    float OrignY = 0;

                    //g1.DrawImage(Bitmap, 5, 5); //draw North arrow
                    g1.DrawImage(Bitmap, 5, 5, 20, 20);

                    Font font1 = new Font("Arial", 9);
                    if (!playBackMode)
                    {
                        #region
                        if (!bEnglish2Metric)
                        {
                            if ("GPS VTG" == labelVesselRef.Text)//LPJ 2016-8-15
                            {
                                g1.DrawString("GPS VTG (ft)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)
                            {
                                g1.DrawString("GPS GGA (ft)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                            {
                                g1.DrawString("Null (ft)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else
                                g1.DrawString("Bottom Track (ft)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                        }
                        else
                        {
                            if ("GPS VTG" == labelVesselRef.Text)//LPJ 2016-8-15
                            {
                                g1.DrawString("GPS VTG (m)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else if ("GPS GGA" == labelVesselRef.Text)
                            {
                                g1.DrawString("GPS GGA (m)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else if (Resource1.String233 == labelVesselRef.Text)
                            {
                                g1.DrawString("Null (m)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                            }
                            else
                                g1.DrawString("Bottom Track (m)", font1, Brushes.Black, new PointF(10, panelGPSTrack.Height - 30));
                        }
                        #endregion
                    }  
                    else
                    { 
                        #region 图例  
                        string strTitle = "Track";
                        if (!bEnglish2Metric)
                        {
                            strTitle = Resource1.String313 + "(ft)";
                        }
                        else
                        {
                            strTitle = Resource1.String313 + "(m)";
                        }
                        if (bGPSVTGTrack && bBottomTrack && bGPSGGATrack)
                        {
                            g1.DrawRectangle(Pens.Black, new Rectangle(5, panelGPSTrack.Height - 90, 120, 80));
                            g1.DrawString(strTitle, font1, Brushes.Black, new PointF(25, panelGPSTrack.Height - 87));

                            g1.DrawLine(new Pen(Brushes.DarkBlue, 2), new Point(15, panelGPSTrack.Height - 60), new Point(55, panelGPSTrack.Height - 60));
                            g1.DrawString(Resource1.String232, font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 67));

                            g1.DrawLine(new Pen(Brushes.DarkRed, 2), new Point(15, panelGPSTrack.Height - 40), new Point(55, panelGPSTrack.Height - 40));
                            g1.DrawString("GPS VTG", font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 47));

                            g1.DrawLine(new Pen(Brushes.Purple, 2), new Point(15, panelGPSTrack.Height - 20), new Point(55, panelGPSTrack.Height - 20));
                            g1.DrawString("GPS GGA", font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 27));
                        }
                        else if (!bGPSVTGTrack && !bBottomTrack&&!bGPSGGATrack)
                        {
                            g1.DrawRectangle(Pens.Black, new Rectangle(5, panelGPSTrack.Height - 30, 120, 20));
                            g1.DrawString(strTitle, font1, Brushes.Black, new PointF(25, panelGPSTrack.Height - 27));
                        }
                        else if ((bGPSGGATrack && !bBottomTrack && !bGPSVTGTrack) || (bGPSVTGTrack && !bBottomTrack && !bGPSGGATrack) || (bBottomTrack && !bGPSVTGTrack && !bGPSGGATrack))
                        {
                            g1.DrawRectangle(Pens.Black, new Rectangle(5, panelGPSTrack.Height - 50, 120, 40));
                            g1.DrawString(strTitle, font1, Brushes.Black, new PointF(25, panelGPSTrack.Height - 47));

                            string strLine = Resource1.String232;
                            Brush brush = Brushes.DarkBlue;
                            if (bGPSVTGTrack)
                            {
                                strLine = "GPS VTG";
                                brush = Brushes.DarkRed;
                            }
                            else if (bGPSGGATrack)
                            {
                                strLine = "GPS GGA";
                                brush = Brushes.Purple;
                            }
                            g1.DrawLine(new Pen(brush, 2), new Point(15, panelGPSTrack.Height - 20), new Point(55, panelGPSTrack.Height - 20));
                            g1.DrawString(strLine, font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 27));

                        }
                        else
                        {
                            string strLine1 = Resource1.String232, strLine2 = "GPS VTG";
                            Brush brush1 = Brushes.DarkBlue, brush2 = Brushes.DarkRed;
                            if (!bGPSVTGTrack)
                            {
                                strLine2 = "GPS GGA";
                                brush2 = Brushes.Purple;
                            }
                            else if (!bBottomTrack)
                            {
                                strLine1 = "GPS GGA";
                                brush1 = Brushes.Purple;
                            }

                            g1.DrawRectangle(Pens.Black, new Rectangle(5, panelGPSTrack.Height - 70, 120, 60));
                            g1.DrawString(strTitle, font1, Brushes.Black, new PointF(25, panelGPSTrack.Height - 67));

                            g1.DrawLine(new Pen(brush1, 2), new Point(15, panelGPSTrack.Height - 40), new Point(55, panelGPSTrack.Height - 40));
                            g1.DrawString(strLine1, font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 47));

                            g1.DrawLine(new Pen(brush2, 2), new Point(15, panelGPSTrack.Height - 20), new Point(55, panelGPSTrack.Height - 20));
                            g1.DrawString(strLine2, font1, Brushes.Black, new PointF(60, panelGPSTrack.Height - 27));
                        }  
                        #endregion
                    }
                     
                    font1.Dispose();

                    using (Pen GreenPen = new Pen(Color.DarkGray, 1))
                    {
                        using (Font font = new Font("Arial", 8))//画中心经纬度及距离标值所用字体
                        {
                            //鼠标在边缘或手动移动时，画面水平移动距离除以单位刻度的商,代表的是画面流过的线条个数
                            int nX = (int)(DragLengthX) / (int)CurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面水平移动距离除以单位刻度的余数，代表的是尚未产生最新线条时已经流过的距离
                            int lX = (int)(DragLengthX) % (int)CurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面竖直移动距离除以单位刻度的商
                            int nY = (int)(DragLengthY) / (int)CurrentDisplayUnit;
                            //鼠标在边缘或手动移动时，画面竖直移动距离除以单位刻度的余数
                            int lY = (int)(DragLengthY) % (int)CurrentDisplayUnit;

                            bool DrawOrignX = false;

                            for (int i = 0; i <= 16; i++)//画竖线
                            {
                                //由顶端到低端，依次向下画横线，如果检测到画线的位置已经超出了显示区下端，则结束本次画面绘制
                                if (lX + CurrentDisplayUnit * i > MainGPSWidth)  //LPJ 2013-5-23
                                {
                                    break;
                                }

                                //float NumX = 10 * (i - 8 - nX) * MouseWheelScale;    //JZH 2012-04-17 改变比例尺大小
                                float NumX = 1 * (i - 8 - nX) * MouseWheelScale; 
                                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                                if (!bEnglish2Metric)
                                {
                                    NumX = (float)(projectUnit.MeterToFeet(NumX, 1));
                                }

                                //float NumX = (10 * (i - 8 - nX) * MouseWheelScale) / scaleMultiple;  //LPJ 2013-5-28
                                string NumXStr = NumX.ToString("0.00");
                                SizeF NumXSize = g1.MeasureString(NumXStr, font);
                                float NumXLength = NumXSize.Width;//字符串长度（像素）
                                //标定横坐标
                                {
                                    g1.DrawString(NumXStr, font, Brushes.Gray,
                                        CurrentDisplayLeft + lX + CurrentDisplayUnit * i - NumXLength / 2,
                                        CurrentDisplayTop);
                                }

                                if (i == nX + 8)  //纵轴线:nX==0,即第四根线；nX==1，即第五根线，... ...
                                {
                                    //标出经度值 
                                    DrawOrignX = true;
                                    OrignX = CurrentDisplayLeft + lX + CurrentDisplayUnit * i;

                                    g1.DrawString("S", font, Brushes.Blue,
                                        OrignX, CurrentDisplayTop + MainGPSHeight - 1.5f * font.Height);

                                    //VerticalFont
                                    GreenPen.DashStyle = DashStyle.Solid;  //实线
                                }
                                else
                                {
                                    GreenPen.DashStyle = DashStyle.Dot;    //点线形式
                                }

                                float fX1, fY2;
                                fX1 = CurrentDisplayLeft + lX + CurrentDisplayUnit * i;
                                fY2 = CurrentDisplayTop + MainGPSHeight;
                                //画竖线
                                g1.DrawLine(GreenPen, fX1, CurrentDisplayTop, fX1, fY2);
                            }

                            //绘图区中心线两侧所显示的的线条个数
                            int SideHNum = (int)(MainGPSHeight / CurrentDisplayUnit) / 2;
                            //使初始绘图区中心始终为纵横两条线的交点
                            int AllHNum = 2 * SideHNum + 1;
                            //上侧最后一条横线到绘图区顶端之间的距离
                            float SmallHeight = MainGPSHeight / 2 - SideHNum * CurrentDisplayUnit;

                            bool DrawOrignY = false;

                            //画横线，使初始绘图区中心始终为纵横两条线的交点
                            for (int j = 0; j <= AllHNum; j++)
                            {
                                //由顶端到低端，依次向下画横线，如果检测到画线的位置已经超出了显示区下端，则结束本次画面绘制
                                if (lY + SmallHeight + CurrentDisplayUnit * j > MainGPSHeight)
                                {
                                    break;
                                }
                                //float NumY = 10 * (j - SideHNum - nY) * MouseWheelScale;    //JZH 2012-04-17 改变比例尺大小
                                float NumY = 1 * (j - SideHNum - nY) * MouseWheelScale; 
                                //float NumY = (10 * (j - SideHNum - nY) * MouseWheelScale) / scaleMultiple;  //LPJ 2013-5-28
                                //Modified 2011-11-21, negate X asix mark. When Mr Qi start the program, he set the X for North pointing right, and Y for East pointing down
                                NumY *= -1;

                                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                                if (!bEnglish2Metric)
                                {
                                    NumY = (float)(projectUnit.MeterToFeet(NumY, 1));
                                }

                                string NumYStr = NumY.ToString("0.00");
                                SizeF NumYSize = g1.MeasureString(NumYStr, font);
                                float NumYHeight = NumYSize.Height;
                                //标定纵坐标
                                if (displayBtmTrack)  //LPJ 2012-7-2 修改 
                                {
                                    g1.DrawString(NumYStr, font, Brushes.Gray,
                                        CurrentDisplayLeft,
                                        CurrentDisplayTop + lY + SmallHeight + CurrentDisplayUnit * j - NumYHeight / 2);
                                }

                                if (j == nY + SideHNum) //横轴线
                                {
                                    //画纬度值:
                                    //SizeF size = g1.MeasureString(SailTrackYpzn.ToString() + 'N', font);
                                    SizeF size = g1.MeasureString("E", font);
                                    float length = size.Width;
                                    DrawOrignY = true;
                                    OrignY = CurrentDisplayTop + lY + SmallHeight + CurrentDisplayUnit * j;

                                    g1.DrawString("E", font, Brushes.Blue,
                                        CurrentDisplayLeft + MainGPSWidth - length, OrignY);

                                    GreenPen.DashStyle = DashStyle.Solid;  //实线
                                }
                                else
                                {
                                    GreenPen.DashStyle = DashStyle.Dot;    //点线形式
                                }
                                float fY1, fX2;
                                fY1 = CurrentDisplayTop + lY + SmallHeight + CurrentDisplayUnit * j;
                                fX2 = CurrentDisplayLeft + MainGPSWidth;
                                //画横线
                                g1.DrawLine(GreenPen, CurrentDisplayLeft, fY1, fX2, fY1);
                            }
                            if (DrawOrignX && DrawOrignY)
                            {
                                Pen n = new Pen(Color.Green, 2);
                                Rectangle rg = new Rectangle((int)(OrignX - 4), (int)(OrignY - 4), 8, 8);
                                g1.DrawEllipse(n, rg); 
                                //g1.FillEllipse(Brushes.GreenYellow, OrignX - 3f, OrignY - 3f, 6f, 6f);
                            }

                            //LPJ 2013-5-23
                            //g1.FillEllipse(Brushes.Red, OrignX - 8f, OrignY - 8f,
                            //    16 * SailTrackMouseWheelScale, 16 * SailTrackMouseWheelScale);
                            //g1.FillEllipse(Brushes.Yellow, OrignX - 4f, OrignY - 4f,
                            //    8 * SailTrackMouseWheelScale, 8 * SailTrackMouseWheelScale);


                            //由于每次都是从（CurrentDisplayTop+SmallHeight）处开始往下绘制画横线，
                            //故要补充绘制（CurrentDisplayTop+SmallHeight）以上的部分：
                            if (lY + SmallHeight >= CurrentDisplayUnit)
                            {
                                //准备画的线是标定为0的那根线向上数第(SideHNum + (nY+1))根
                                //float NumY = 100 * (0 - SideHNum - nY - 1) * MouseWheelScale;//LPJ 2013-6-3
                                float NumY = 10 * (0 - SideHNum - nY - 1) * MouseWheelScale;
                                  
                                //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
                                if (!bEnglish2Metric)
                                {
                                    NumY = (float)(projectUnit.MeterToFeet(NumY, 1));
                                }

                                string NumYStr = NumY.ToString("0.00");
                                SizeF NumYSize = g1.MeasureString(NumYStr, font);
                                float NumYHeight = NumYSize.Height;
                                //标定纵坐标
                                g1.DrawString(NumYStr, font, Brushes.LightGray,
                                    CurrentDisplayLeft,
                                    CurrentDisplayTop + lY + SmallHeight - CurrentDisplayUnit - NumYHeight / 2);
                                //画横线
                                float fY1, fX2;
                                fY1=CurrentDisplayTop + lY + SmallHeight - CurrentDisplayUnit;
                                fX2=CurrentDisplayLeft + MainGPSWidth;
                                g1.DrawLine(GreenPen, CurrentDisplayLeft, fY1, fX2, fY1);
                            }
                        }
                        GreenPen.Dispose(); //LPJ 2013-7-4
                    }

                       
                    float scaleFactor = MouseWheelScale / scaleMultiple;
                    Matrix matrix = new Matrix();//定义一个做几何变换的对象

                    // SailTrackmatrix.Translate((float)panelWidth / 2 + SailTrackDragLengthX, (float)panelHeight / 2 + SailTrackDragLengthY);//缩放中心设为绘图区中心
                    //matrix.Translate(MainGPSWidth / 2 + 60 + DragLengthX, DragLengthY + 205 + MainGPSHeight / 2);//缩放中心设为绘图区中心 //LPJ 2013-5-23
                    matrix.Translate(MainGPSWidth / 2 + DragLengthX, DragLengthY + MainGPSHeight / 2);
                    matrix.Scale(scaleMultiple / MouseWheelScale, scaleMultiple / MouseWheelScale);

                    g1.Transform = matrix;//Modified 2011-11-15 cancel


                    if (playBackMode)
                    {
                        GPSdataCount = BinDataEnsembleNum;   //Modified 2011-9-13
                    }
                    else
                    {
                        GPSdataCount = totalNum;
                    }

                    if (TrackStop)
                    {
                        ComputeXYposition((string)GGAsave[GGAsaveCount - 1]);  //playback and record //LPJ 2013-7-2 cancel
                        return;
                    }

                    //Modified 2011-9-24 here
                    PointF PtStart = new PointF(0, 0);
                    PointF tempP = new PointF(0, 0);
                    PointF VP = new PointF(0, 0);
                    Point saveLastPoint = new Point(0, 0);

                    if (GPSdataCount >= 2)
                    {
                        if (!playBackMode) //record mode
                        {
                            if (TrackPause)
                            {
                                GPSdataCount = PausePoint;
                            }

                            //Modified 2011-9-18 to prevent overrun
                            if (GPSdataCount < GGAsaveCount) //LPJ 2013-8-2 这里直接跳出？？？？？？？？？？？？？？
                            {
                                return;
                            }

                            //LPJ 2013-9-13  在采集模式时，起始点始终为第一个采集数据点 --start
                            GPSdisplayStartPoint = 0;
                            PtStart.X = 0;
                            PtStart.Y = 0;

                            /*
                            if (GGAsaveCount < GPSdisplayLength)  //当回放模式时，GPSdisplayLength为5000，实时采集为500
                            {
                                GPSdisplayStartPoint = 0;
                                PtStart.X = 0;
                                PtStart.Y = 0;
                            }
                            else
                            {
                                GPSdisplayStartPoint = GGAsaveCount - GPSdisplayLength;
                                PtStart = UTMpointSave[GPSdisplayStartPoint];
                                //StartLongitude = GPS_longitude; //Modified 2011-11-8
                            }*/
                            //LPJ 2013-9-13  在采集模式时，起始点始终为第一个采集数据点 --start

                            int PrevGoodEnsembleNoOffset = 0;  //JZH 2012-04-18  底跟踪前一个有效单元的偏移                     
                            bool GetFirstGoodEnsemble = true;  //JZH 2012-04-18  采集到第一个有效单元
                            float AccEast = 0; //JZH 2012-04-18  底跟踪东向累积量
                            float AccNorth = 0; //JZH 2012-04-18 底跟踪北向累积量
                            int PrevGoodEnsemblePos = 0; //JZH 2012-04-18 前一个底跟踪有效单元位置
                            float fLastSecond = 0;    //JZH 2012-06-14 上一个有效的Ensemble时间

                            PointF tempPnt = TransToMapPoint(tempP); ; //LPJ 2013-7-4
                            PointF[] TempPnts = new PointF[BinDataEnsembleNum + 1]; //LPJ 2013-7-10 将航迹线用折线来绘制
                            int icounts = 0; //LPJ 2013-7-10 
                            Pen bluePen = new Pen(Brushes.Blue, (int)(1.5 * MouseWheelScale)); //LPJ 2013-8-2

                            for (int i = GPSdisplayStartPoint; i < GGAsaveCount; i++) //Modified 2011-9-17
                            {
                                {
                                    if (i == 0)
                                    {
                                        UTMpoint.X = 0;  //
                                        UTMpoint.Y = 0;

                                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                        if ("GPS VTG" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                        }//LPJ 2013-7-31
                                        else if ("GPS GGA" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                                fBoatVx = 0;
                                                fBoatVy = 0;
                                        }

                                        if(Math.Abs( fBoatVx) > 20 || Math.Abs( fBoatVy) > 20)
                                        //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                                        {
                                            //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                                            GetFirstGoodEnsemble = false;
                                        }
                                        else  //JZH 2012-06-14 改正导航航迹计算
                                        {
                                            GetFirstGoodEnsemble = true;
                                            fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[0];
                                            PrevGoodEnsemblePos = 0;
                                        }

                                        TempPnts[icounts++] = TransToMapPoint(PtStart); //LPJ 2013-7-10
                                    }
                                    else
                                    {
                                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                                        float fBoatVx_Prev, fBoatVy_Prev;
                                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                                        fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX;
                                        fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY;
                                        if ("GPS VTG" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VX;
                                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VY;
                                        }//LPJ 2013-7-31
                                        else if ("GPS GGA" == labelVesselRef.Text)
                                        {
                                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VX;
                                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VY;
                                        }
                                        else if (Resource1.String233 == labelVesselRef.Text)
                                        {
                                            fBoatVx = 0;
                                            fBoatVy = 0;
                                            fBoatVx_Prev = 0;
                                            fBoatVy_Prev = 0;
                                        }

                                        if( Math.Abs( fBoatVx) < 20 && Math.Abs( fBoatVy) < 20)
                                        //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX < 20 && ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY < 20)
                                        {
                                            if (GetFirstGoodEnsemble)
                                            {
                                                //float LEast = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VX) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);   //JZH 2012-06-14
                                                //float LNorth = (1.0f) * 0.5f * (float)(((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY + ((Velocity)EnsemblesInfoToStore.BoatVelocity[i]).VY) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14

                                                float LEast = (1.0f) * 0.5f * (float)(fBoatVx_Prev + fBoatVx) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);   //JZH 2012-06-14
                                                float LNorth = (1.0f) * 0.5f * (float)(fBoatVy_Prev + fBoatVy) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14

                                                AccEast += LEast;
                                                AccNorth += LNorth;
                                                //JZH 2012-04-17 支持自动缩放
                                                //float fTransAccEast = AccEast / 10 * CurrentDisplayUnit;
                                                //float fTransAccNorth = AccNorth / 10 * CurrentDisplayUnit;
                                                float fTransAccEast = AccEast / 1 * CurrentDisplayUnit;
                                                float fTransAccNorth = AccNorth / 1 * CurrentDisplayUnit;

                                                UTMpoint.X = (int)fTransAccEast; //JZH 2012-04-17
                                                UTMpoint.Y = (int)fTransAccNorth;

                                                PrevGoodEnsembleNoOffset = 0;
                                                PrevGoodEnsemblePos = i;
                                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14

                                            }
                                            else
                                            {
                                                GetFirstGoodEnsemble = true;
                                                PrevGoodEnsemblePos = i;
                                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14
                                            }
                                        }
                                        else
                                        {
                                            PrevGoodEnsembleNoOffset++;

                                        }

                                    }
                                    tempP.X = UTMpoint.X;
                                    tempP.Y = UTMpoint.Y;
                                    tempP.Y *= -1;
                                }

                                tempPnt = TransToMapPoint(tempP); //LPJ 2013-7-10
                                //PointF VPnt = TransToMapPoint(VP);  //LPJ 2013-7-10

                                if ((i % setAveragePoints) == 0 && i > setAveragePoints)
                                {
 
                                    float AVX = AverageVXsave[i];
                                    float AVY = AverageVYsave[i];

                                    if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        AVX = AverageVXsave_GPS[i];
                                        AVY = AverageVXsave_GPS[i];
                                    }
                                    else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-7-31
                                    {
                                        AVX = AverageVXsave_GPGGA[i];
                                        AVY = AverageVXsave_GPGGA[i];
                                    }
                                    else if (Resource1.String233 == labelVesselRef.Text)
                                    {
                                        AVX = AverageVXsave_Null[i];
                                        AVY = AverageVXsave_Null[i];
                                    }
                                        
                                    VP.Y = tempP.Y - AVY * AverageScale * MouseWheelScale / 8; //LPJ 2013-8-6
                                    VP.X = tempP.X + AVX * AverageScale * MouseWheelScale / 8; //LPJ 2013-8-6

                                    //流速矢量线 //LPJ 2013-6-4
                                        
                                    //Velocity Vector Line
                                    if ((float)EnsemblesInfoToStore.bottomDepth[i] > 0.01f) //LPJ 2013-9-22 当水深有效时，绘制流速矢量线
                                        g1.DrawLine(bluePen, tempPnt, VP); //g1.DrawLine(bluePen, tempPnt, VPnt);
                                }
                                TempPnts[icounts++] = tempPnt; //LPJ 2013-7-10
                                PtStart = tempP;
                            }
                            Pen TrackPen = new Pen(Brushes.Red, 4 * MouseWheelScale);
                            g1.DrawLines(TrackPen, TempPnts); //LPJ 2013-7-10 
                            TrackPen.Dispose(); //LPJ 2013-7-4

                            //LPJ 2013-5-23
                            //g1.FillEllipse(Brushes.Red, tempP.X - 2, tempP.Y - 2, 4 * MouseWheelScale, 4 * MouseWheelScale); //(-1 * originSize / 2) * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale, originSize * SailTrackMouseWheelScale);
                            Pen n = new Pen(Color.Red, 2 * MouseWheelScale);
                            Rectangle rg = new Rectangle((int)(tempPnt.X - 4 * MouseWheelScale), (int)(tempPnt.Y - 4 * MouseWheelScale), (int)(8 * MouseWheelScale), (int)(8 * MouseWheelScale));
                            g1.DrawEllipse(n, rg); 
                            //g1.FillEllipse(Brushes.Red, tempPnt.X, tempPnt.Y, 8 * MouseWheelScale, 8 * MouseWheelScale);
                            AutoSizeGPS(tempP);
                        }
                        else //playbackmode  //Modified 2011-11-27, try display every setAveragePoints
                        {
                            if (TrackOverPlay == true)
                            {
                                return;
                            }
                            if (TrackPause)
                            {
                                GPSdataCount = PausePoint;
                            }

                            //JZH 2012-01-04 新版代码
                            if (BinDataEnsembleNum < GPSdisplayLength)
                            {
                                GPSdisplayStartPoint = 0;
                                PtStart.X = 0; //LPJ 2013-5-23
                                PtStart.Y = 0;
                            }
                            else
                            {
                                GPSdisplayStartPoint = BinDataEnsembleNum - GPSdisplayLength;
                                PtStart = (Point)EnsemblesInfoToStore.UTMpoint[GPSdisplayStartPoint];

                            }

                            if (bBottomTrack)
                                OnDrawTrackBT_GPS(g1, EnsemblesInfoToStore, 1, GPSdisplayStartPoint, BinDataEnsembleNum, PtStart, ref tempP, VP); //LPJ 2016-10-21  底跟踪航迹
                            if (bGPSVTGTrack)
                                OnDrawTrackBT_GPS(g1, EnsemblesInfoToStore, 2, GPSdisplayStartPoint, BinDataEnsembleNum, PtStart, ref tempP, VP); //LPJ 2016-10-21  GPS VTG航迹
                            if (bGPSGGATrack)
                                OnDrawTrackBT_GPS(g1, EnsemblesInfoToStore, 3, GPSdisplayStartPoint, BinDataEnsembleNum, PtStart, ref tempP, VP); //LPJ 2016-10-21  GPS GGA航迹

                            //LPJ 2013-6-3 自动缩放
                            AutoSizeGPS(tempP);
                            //panelGPSTrack.Refresh();
                        }
                    }
                }
                catch //(Exception ex) //LPJ 2013-6-11
                {
                    //MessageBox.Show(ex.Message + " in panelGPSTrack_Paint");
                }

                MainBuffer.Render(e.Graphics);
                g1.Dispose();
                MainBuffer.Dispose();

            }
           
        }

        private void panelGPSTrack_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                TragCursorChangeToTrag = false;
            }
        }

        private bool TragCursorChangeToTrag = false;
        private PointF DragStartPoint;
        private void panelGPSTrack_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                DragStartPoint = e.Location;
                TragCursorChangeToTrag = true;
            }
        }

        private void panelGPSTrack_MouseMove(object sender, MouseEventArgs e)
        {
            if (TragCursorChangeToTrag)
            {
                DragEndPoint = e.Location;
                DragLengthX += DragEndPoint.X - DragStartPoint.X;
                DragLengthY += DragEndPoint.Y - DragStartPoint.Y;

                float leftX = DragLengthX; // -(panelWidth / 2);
                leftX -= (MainGPSWidth * -1) / 2;
                float topY = DragLengthY;
                topY = MainGPSHeight + topY;

                DragStartPoint = e.Location;
                if (playBackMode == true) //Modified 2011-9-15
                {
                    PlayBackTimer.Stop();
                    panelGPSTrack.Refresh();

                    if(!bPlaybackStop) //LPJ 2013-11-19
                    PlayBackTimer.Start();
                }
                else
                {
                    panelGPSTrack.Refresh();
                }
            }
        }

        /// <summary>
        /// 绘制底跟踪和GPS的航迹
        /// </summary>
        /// <param name="g1"></param>
        /// <param name="EnsemblesInfoToStore"></param>
        /// <param name="iBT">底跟踪或GPS，当iBT=1，为底跟踪</param>
        /// <param name="iStartEnsembleID">起始样本号</param>
        /// <param name="iTotalEnsembles">总样本数</param>
        /// <param name="PtStart">起始点</param>
        /// <param name="tempP"></param>
        /// <param name="VP">流速矢量</param>
        private void OnDrawTrackBT_GPS(Graphics g1, EnsemblesInfo EnsemblesInfoToStore, int iBT, int iStartEnsembleID, int iTotalEnsembles, PointF PtStart, ref PointF tempP, PointF VP) //LPJ 2016-9-23 将GPS和底跟踪绘制在一起
        {
            try
            {
                PointF[] TempPnts = new PointF[iTotalEnsembles + 1];

                int PrevGoodEnsembleNoOffset = 0;  //JZH 2012-04-18  底跟踪前一个有效单元的偏移                     
                bool GetFirstGoodEnsemble = true;  //JZH 2012-04-18  采集到第一个有效单元
                float AccEast = 0; //JZH 2012-04-18  底跟踪东向累积量
                float AccNorth = 0; //JZH 2012-04-18 底跟踪北向累积量
                int PrevGoodEnsemblePos = 0; //JZH 2012-04-18 前一个底跟踪有效单元位置
                float fLastSecond = 0;    //JZH 2012-06-14 上一个有效的Ensemble时间

                PointF tempPnt = TransToMapPoint(tempP); //LPJ 2013-7-4
                int icounts = 0; //LPJ 2013-7-10 
                Point UTMpoint = new Point(0, 0); //LPJ 2014-12-24 将UTMpoint设为局部变量

                Pen VelocityPen, TrackPen;
                if (1 == iBT)
                {
                    VelocityPen = new Pen(Brushes.Blue, (int)(1.5 * MouseWheelScale)); //LPJ 2013-8-2
                    TrackPen = new Pen(Brushes.DarkBlue, 4 * MouseWheelScale); //LPJ 2013-7-10 将航迹图中的航迹改为红色
                }
                else if (2 == iBT)
                {
                    VelocityPen = new Pen(Brushes.Brown, (int)(1.5 * MouseWheelScale));
                    TrackPen = new Pen(Brushes.DarkRed, 4 * MouseWheelScale);
                }
                else
                {
                    VelocityPen = new Pen(Brushes.Purple, (int)(1.5 * MouseWheelScale));
                    TrackPen = new Pen(Brushes.Purple, 4 * MouseWheelScale);
                }

                for (int i = iStartEnsembleID; i < iTotalEnsembles; i++)  //LPJ 2014-4-8 确保subsystem的总数一致
                {
                    #region
                    if (i == 0)
                    {
                        UTMpoint.X = 0;  //LPJ 2013-5-23
                        UTMpoint.Y = 0; //

                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                        if (2 == iBT)
                        {
                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                        }//LPJ 2013-7-31
                        else if (3 == iBT)
                        {
                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                        }
                        //else if (Resource1.String233 == labelVesselRef.Text)
                        //{
                        //    fBoatVx = 0;
                        //    fBoatVy = 0;
                        //}

                        if (Math.Abs(fBoatVx) > 20 || Math.Abs(fBoatVy) > 20)
                        //if (((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX > 20 || ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY > 20)
                        {
                            //FirstGoodEnsembleNoOffset++; //起始数据组不是有效底跟踪数据
                            GetFirstGoodEnsemble = false;
                        }
                        else  //JZH 2012-06-14 修正导航航迹计算
                        {
                            GetFirstGoodEnsemble = true;
                            fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[0];
                            PrevGoodEnsemblePos = 0;

                        }

                        TempPnts[icounts++] = TransToMapPoint(PtStart); //LPJ 2013-7-10
                    }
                    else
                    {
                        float fBoatVx, fBoatVy; //LPJ 2013-7-31
                        float fBoatVx_Prev, fBoatVy_Prev;
                        fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VX;
                        fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatVelocity[i])).VY;
                        fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VX;
                        fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatVelocity[PrevGoodEnsemblePos]).VY;
                        if (2 == iBT)
                        {
                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VX;
                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPS[i])).VY;
                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VX;
                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPS[PrevGoodEnsemblePos]).VY;
                        }//LPJ 2013-7-31
                        else if (3 == iBT)
                        {
                            fBoatVx = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VX;
                            fBoatVy = ((Velocity)(EnsemblesInfoToStore.BoatV_GPGGA[i])).VY;
                            fBoatVx_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VX;
                            fBoatVy_Prev = ((Velocity)EnsemblesInfoToStore.BoatV_GPGGA[PrevGoodEnsemblePos]).VY;
                        }
                        //else if (Resource1.String233 == labelVesselRef.Text)
                        //{
                        //    fBoatVx = 0;
                        //    fBoatVy = 0;
                        //    fBoatVx_Prev = 0;
                        //    fBoatVy_Prev = 0;
                        //}

                        if (Math.Abs(fBoatVx) < 20 && Math.Abs(fBoatVy) < 20)
                        {
                            if (GetFirstGoodEnsemble)
                            {
                                float LEast = (1.0f) * 0.5f * (float)(fBoatVx_Prev + fBoatVx) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14
                                float LNorth = (1.0f) * 0.5f * (float)(fBoatVy_Prev + fBoatVy) * ((float)EnsemblesInfoToStore.RecivedTime[i] - fLastSecond);  //JZH 2012-06-14

                                AccEast += LEast;
                                AccNorth += LNorth;
                                //JZH 2012-04-17 支持自动缩放
                                //float fTransAccEast = AccEast / 10 * CurrentDisplayUnit;
                                //float fTransAccNorth = AccNorth / 10 * CurrentDisplayUnit;
                                float fTransAccEast = AccEast / 1 * CurrentDisplayUnit;
                                float fTransAccNorth = AccNorth / 1 * CurrentDisplayUnit;
                                UTMpoint.X = (int)fTransAccEast; //JZH 2012-04-17  
                                UTMpoint.Y = (int)fTransAccNorth;

                                PrevGoodEnsembleNoOffset = 0;
                                PrevGoodEnsemblePos = i;
                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14

                            }
                            else
                            {
                                //FirstGoodEnsembleNoOffset++;
                                GetFirstGoodEnsemble = true;
                                PrevGoodEnsemblePos = i;
                                fLastSecond = (float)EnsemblesInfoToStore.RecivedTime[i];  //JZH 2012-06-14
                            }
                        }
                        else
                        {
                            PrevGoodEnsembleNoOffset++;

                        }

                    }
                    tempP.X = UTMpoint.X;
                    tempP.Y = UTMpoint.Y;
                    tempP.Y *= -1;

                    //JZH 2011-01-05  暂时先计算平均流速， 以后直接在记录原始数据时候改正？
                    float AverageVY = 0;
                    float AverageVX = 0;
                    //float AverageDepth = 0;

                    AverageVX = fAverageX[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过
                    AverageVY = fAverageY[i]; //LPJ 2013-7-3 平均流速在开始载入数据时已经计算过

                    if (2 == iBT) //LPJ 2013-7-31
                    {
                        AverageVX = fAverageX_GPS[i];
                        AverageVY = fAverageY_GPS[i];
                    }
                    else if (3 == iBT) //LPJ 2013-7-31
                    {
                        AverageVX = fAverageX_GPGGA[i];
                        AverageVY = fAverageY_GPGGA[i];
                    }
                    //else if (Resource1.String233 == labelVesselRef.Text)
                    //{
                    //    AverageVX = fAverageX_Null[i];
                    //    AverageVY = fAverageY_Null[i];
                    //}

                    float scaleMouseWheel = AverageScale * MouseWheelScale / 8; //LPJ 2013-7-4

                    VP.Y = tempP.Y - AverageVY * scaleMouseWheel; //LPJ 2013-6-9 
                    VP.X = tempP.X + AverageVX * scaleMouseWheel;  //LPJ 2013-6-9
                    //VP.X = tempP.X + AVX * AverageScale; //(float)EnsemblesInfoToStore.VYstore[i] * setAverageScale;

                    tempPnt = TransToMapPoint(tempP);
                    PointF VPnt = TransToMapPoint(VP);

                    if ((float)EnsemblesInfoToStore.bottomDepth[i] > 0.01f)   //LPJ 2013-9-22 当底跟踪无效时，不用绘制流速矢量线
                        g1.DrawLine(VelocityPen, tempPnt, VPnt);

                    TempPnts[icounts++] = tempPnt; //LPJ 2013-7-10
                  
                    PtStart = tempP;
                    #endregion
                }

                g1.DrawLines(TrackPen, TempPnts); //LPJ 2013-7-10 

                Pen n = new Pen(Color.Blue, MouseWheelScale);
                Rectangle rg = new Rectangle((int)(tempPnt.X - 4 * MouseWheelScale), (int)(tempPnt.Y - 4 * MouseWheelScale), (int)(8 * MouseWheelScale), (int)(8 * MouseWheelScale));
                g1.DrawEllipse(n, rg);
                n.Dispose();
            }
            catch
            {
            }
        }


        private void RefreshListViewHeader(ListView listviewSummary, bool bEnglish2Metric) //LPJ 2013-8-2 将单位放在listView的标题栏
        {
            if (bEnglish2Metric)
            {
                listviewSummary.Columns[0].Text = Resource1.String260;
                listviewSummary.Columns[1].Text = Resource1.String261;
                listviewSummary.Columns[2].Text = Resource1.String262;
                listviewSummary.Columns[3].Text = Resource1.String113;

               
                listviewSummary.Columns[4].Text = Resource1.String107 + "(m)";
                listviewSummary.Columns[5].Text = Resource1.String108 + "(m2)"; 
                listviewSummary.Columns[6].Text = Resource1.String98 + "(m3/s)";
                listviewSummary.Columns[7].Text = Resource1.String109 + "(m/s)";

                listviewSummary.Columns[8].Text = Resource1.String110 + "(Deg)";
                listviewSummary.Columns[9].Text = Resource1.String105 + "(m)";
                listviewSummary.Columns[10].Text = Resource1.String106 + "(Deg)";
                listviewSummary.Columns[11].Text = Resource1.String104 + "(m)";

                listviewSummary.Columns[12].Text = Resource1.String93 + "(m3/s)";
                listviewSummary.Columns[13].Text = Resource1.String95 + "(m3/s)";
                listviewSummary.Columns[14].Text = Resource1.String96 + "(m3/s)";
                listviewSummary.Columns[15].Text = Resource1.String97 + "(m3/s)";
                listviewSummary.Columns[16].Text = Resource1.String94 + "(m3/s)";

            }
            else
            {
                listviewSummary.Columns[0].Text = Resource1.String260;
                listviewSummary.Columns[1].Text = Resource1.String261;
                listviewSummary.Columns[2].Text = Resource1.String262;
                listviewSummary.Columns[3].Text = Resource1.String113;

                listviewSummary.Columns[4].Text = Resource1.String107 + "(ft)";
                listviewSummary.Columns[5].Text = Resource1.String108 + "(ft2)"; 
                listviewSummary.Columns[6].Text = Resource1.String98 + "(ft3/s)";
                listviewSummary.Columns[7].Text = Resource1.String109 + "(ft/s)";

                listviewSummary.Columns[8].Text = Resource1.String110 + "(Deg)";
                listviewSummary.Columns[9].Text = Resource1.String105 + "(ft)";
                listviewSummary.Columns[10].Text = Resource1.String106 + "(Deg)";
                listviewSummary.Columns[11].Text = Resource1.String104 + "(ft)";

                listviewSummary.Columns[12].Text = Resource1.String93 + "(ft3/s)";
                listviewSummary.Columns[13].Text = Resource1.String95 + "(ft3/s)";
                listviewSummary.Columns[14].Text = Resource1.String96 + "(ft3/s)";
                listviewSummary.Columns[15].Text = Resource1.String97 + "(ft3/s)";
                listviewSummary.Columns[16].Text = Resource1.String94 + "(ft3/s)";
            }
        }

        delegate void RefreshSummaryDelegate();
        RefreshSummaryDelegate RefreshSummaryList;
        private List<string[]> summaryData=new List<string[]>(); //LPJ 2013-7-26 该变量用于存储汇总的数据

        private void ListView_Summary_Paint() //LPJ 2013-6-19 添加汇总List
        {
            //LPJ 2013-8-8 更新显示的单位
            RefreshListViewHeader(listView_Summary, bEnglish2Metric);

            //LPJ 2013-6-19 分别针对实时测量和回放采用不同的汇总方式
            //if 实时测量模式，则将上一个半测回的数据进行汇总，即当点击停止后，判断是否有该测回数据，若有，则添加至list中
            if (!playBackMode)
            {
                if (iStartMeasQ > 0)
                {
                    ListViewItem items = new ListViewItem();
                    items.Text = Path.Combine(newPath, ProjectFullName); //文件名
                    items.SubItems.Add(current_DataTime); //开始日期
                    items.SubItems.Add(current_DataTime); //开始时间
                    items.SubItems.Add(current_TotalTimelabel); //测量时间

                    items.SubItems.Add(current_RiverWidth); //河宽
                    items.SubItems.Add(current_Area); //总面积  
                    items.SubItems.Add(current_TotalQ); //总流量 //LPJ 2013-8-8
                    items.SubItems.Add(current_MeanFLowVel); //平均流速
                    items.SubItems.Add(current_MeanFlowDir); //平均流向
                    items.SubItems.Add(current_DistanceMG); //直线距离
                    items.SubItems.Add(current_CourseMG); //直线方向
                    items.SubItems.Add(current_Length); //测量长度
                    items.SubItems.Add(current_TopQ); //顶部流量
                    items.SubItems.Add(current_BottomQ); //底部流量
                    items.SubItems.Add(current_LeftQ); //左岸流量
                    items.SubItems.Add(current_RightQ); //右岸流量
                    items.SubItems.Add(current_MiddleQ); //实测流量

                    this.listView_Summary.Items.Add(items);

                    //LPJ 2013-7-26 将汇总数据添加到List中
                    string[] sDataSummary=new string[13];
                    
                    sDataSummary[0]=current_RiverWidth;
                    sDataSummary[1]=current_Area;
                    sDataSummary[2]=current_TotalQ;
                    sDataSummary[3]=current_MeanFLowVel;
                    sDataSummary[4]=current_MeanFlowDir;
                    sDataSummary[5]=current_DistanceMG;
                    sDataSummary[6]=current_CourseMG;
                    sDataSummary[7]=current_Length;
                    sDataSummary[8]=current_TopQ;
                    sDataSummary[9]=current_BottomQ;
                    sDataSummary[10]=current_LeftQ;
                    sDataSummary[11]=current_RightQ;
                    sDataSummary[12]=current_MiddleQ;
                    summaryData.Add(sDataSummary);
                    //LPJ 2013-7-26 将汇总数据添加到List中

                    try
                    {
                        //LPJ 2013-7-23 计算平均值及方差，并将其显示出来 --start
                        //当listView_Summary.Items的总数大于3时，先清除最后三行,（最后三行为平均值、标准差及误差），然后再计算
                        //int counts = listView_Summary.Items.Count;
                        int summaryCounts = listView_Summary.Items.Count;
                        if (summaryCounts > 3)
                        {
                            for (int i = summaryCounts - 1; i >= 0; i--)
                            {
                                if (listView_Summary.Items[i].Text == "")
                                {
                                    listView_Summary.Items.RemoveAt(i);
                                }
                            }
                        }

                        //counts = listView_Summary.Items.Count;
                        int counts = summaryData.Count();
                        double[] Mean = new double[13];
                        double[] StdDev = new double[13];
                        double[] Cov = new double[13];

                        for (int i = 0; i < 13; i++)
                        {
                            Mean[i] = 0;
                            StdDev[i] = 0;
                            Cov[i] = 0;
                        }

                        for (int i = 0; i < counts; i++)
                        {
                            //ListViewItem items0 = new ListViewItem();
                            //items0 = listView_Summary.Items[i];
                            //for (int j = 0; j < 13; j++)
                            //{
                            //    Mean[j] += double.Parse(items0.SubItems[j + 4].Text) / counts;
                            //}
                            string[] strSummary = new string[13];
                            strSummary = summaryData[i];

                            for (int j = 0; j < 13; j++)
                            {
                                Mean[j] += double.Parse(strSummary[j]) / counts;
                            }

                        }

                        for (int i = 0; i < counts; i++)
                        {
                            //ListViewItem items0 = new ListViewItem();
                            //items0 = listView_Summary.Items[i];
                            //for (int j = 0; j < 13; j++)
                            //    StdDev[j] += Math.Pow(double.Parse(items0.SubItems[j + 4].Text) - Mean[j], 2) / counts;

                            string[] strSummary = new string[13];
                            strSummary = summaryData[i];
                            for (int j = 0; j < 13; j++)
                            {
                                StdDev[j] += Math.Pow(double.Parse(strSummary[j]) - Mean[j], 2) / counts;
                            }

                        }

                        for (int i = 0; i < 13; i++)
                        {
                            StdDev[i] = Math.Sqrt(StdDev[i]);
                        }

                        for (int i = 0; i < 13; i++)
                        {
                            if (Math.Abs(Mean[i]) > 1e-9)
                                Cov[i] = StdDev[i] / Mean[i];
                        }

                        AddToSummaryList(Mean, Resource1.String253);
                        AddToSummaryList(StdDev, Resource1.String254);
                        AddToSummaryList(Cov, Resource1.String255);
                        //LPJ 2013-7-23 计算平均值及方差，并将其显示出来 --end

                        #region 当误差超限标红 //LPJ 2017-1-3
                        for (int i = 0; i < counts; i++)
                        {
                            try
                            {
                                listView_Summary.Items[i].ForeColor = Color.Black;
                                string[] strSummary = new string[13];
                                strSummary = summaryData[i];
                                if (Math.Abs((Mean[2] - double.Parse(strSummary[2])) / Mean[2]) > 0.05)
                                {
                                    listView_Summary.Items[i].ForeColor = Color.Red;
                                }
                            }
                            catch
                            {
                            }
                        }
                        #endregion
                    }
                    catch
                    {
                    }
                }
            }
            else
            {
                try
                {
                    GetDischarge(ref report); //LPJ 2013-7-1 一次计算全部流量信息

                    ListViewItem SummaryItems = new ListViewItem();
                    SummaryItems.Text = report.fileName; //文件名
                    SummaryItems.SubItems.Add(report.startDate); //开始日期
                    SummaryItems.SubItems.Add(report.startTime); //开始时间
                    SummaryItems.SubItems.Add(report.Duration); //测量时间
                    //if (Resource1.String237 == labelUnit.Text)
                  /*  if (!bEnglish2Metric)
                    {
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.TotalQ, 3).ToString("0.00") + "(ft3/s)"); //总流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.WaterWidth, 1).ToString("0.00") + "(ft)"); //河宽
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.Area, 2).ToString("0.00") + "(ft2)"); //总面积
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.AverageVel, 1).ToString("0.00") + "(ft/s)"); //平均流速
                        SummaryItems.SubItems.Add(report.MeanCourse.ToString("0.00") + "(Deg)"); //平均流向
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.DistanceMG, 1).ToString("0.00") + "(ft)"); //直线距离
                        SummaryItems.SubItems.Add(report.CourseMG.ToString("0.00") + "(Deg)"); //直线方向
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.Length, 1).ToString("0.00") + "(ft)"); //测量长度
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.TopQ, 3).ToString("0.00") + "(ft3/s)"); //顶部流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.BottomQ, 3).ToString("0.00") + "(ft3/s)"); //底部流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.LeftQ, 3).ToString("0.00") + "(ft3/s)"); //左岸流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.RightQ, 3).ToString("0.00") + "(ft3/s)"); //右岸流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.MiddleQ, 3).ToString("0.00") + "(ft3/s)"); //实测流量

                      
                    }
                    else
                    {
                        SummaryItems.SubItems.Add(report.TotalQ.ToString("0.00") + "(m3/s)"); //总流量
                        SummaryItems.SubItems.Add(report.WaterWidth.ToString("0.00") + "(m)"); //河宽
                        SummaryItems.SubItems.Add(report.Area.ToString("0.00") + "(m2)"); //总面积
                        SummaryItems.SubItems.Add(report.AverageVel.ToString("0.00") + "(m/s)"); //平均流速
                        SummaryItems.SubItems.Add(report.MeanCourse.ToString("0.00") + "(Deg)"); //平均流向
                        SummaryItems.SubItems.Add(report.DistanceMG.ToString("0.00") + "(m)"); //直线距离
                        SummaryItems.SubItems.Add(report.CourseMG.ToString("0.00") + "(Deg)"); //直线方向
                        SummaryItems.SubItems.Add(report.Length.ToString("0.00") + "(m)"); //测量长度
                        SummaryItems.SubItems.Add(report.TopQ.ToString("0.00") + "(m3/s)"); //顶部流量
                        SummaryItems.SubItems.Add(report.BottomQ.ToString("0.00") + "(m3/s)"); //底部流量
                        SummaryItems.SubItems.Add(report.LeftQ.ToString("0.00") + "(m3/s)"); //左岸流量
                        SummaryItems.SubItems.Add(report.RightQ.ToString("0.00") + "(m3/s)"); //右岸流量
                        SummaryItems.SubItems.Add(report.MiddleQ.ToString("0.00") + "(m3/s)"); //实测流量

                    }*/

                    if (!bEnglish2Metric)
                    {
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.WaterWidth, 1).ToString("0.00") ); //河宽
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.Area, 2).ToString("0.00") ); //总面积 
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.TotalQ, 3).ToString("0.00")); //总流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.AverageVel, 1).ToString("0.00") ); //平均流速
                        SummaryItems.SubItems.Add(report.MeanCourse.ToString("0.00") ); //平均流向
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.DistanceMG, 1).ToString("0.00")); //直线距离
                        SummaryItems.SubItems.Add(report.CourseMG.ToString("0.00") ); //直线方向
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.Length, 1).ToString("0.00")); //测量长度
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.TopQ, 3).ToString("0.00") ); //顶部流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.BottomQ, 3).ToString("0.00")); //底部流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.LeftQ, 3).ToString("0.00") ); //左岸流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.RightQ, 3).ToString("0.00")); //右岸流量
                        SummaryItems.SubItems.Add(projectUnit.MeterToFeet(report.MiddleQ, 3).ToString("0.00")); //实测流量
                    }
                    else
                    {
                        SummaryItems.SubItems.Add(report.WaterWidth.ToString("0.00") ); //河宽
                        SummaryItems.SubItems.Add(report.Area.ToString("0.00")); //总面积
                        SummaryItems.SubItems.Add(report.TotalQ.ToString("0.00")); //总流量
                        SummaryItems.SubItems.Add(report.AverageVel.ToString("0.00") ); //平均流速
                        SummaryItems.SubItems.Add(report.MeanCourse.ToString("0.00")); //平均流向
                        SummaryItems.SubItems.Add(report.DistanceMG.ToString("0.00")); //直线距离
                        SummaryItems.SubItems.Add(report.CourseMG.ToString("0.00") ); //直线方向
                        SummaryItems.SubItems.Add(report.Length.ToString("0.00") ); //测量长度
                        SummaryItems.SubItems.Add(report.TopQ.ToString("0.00")); //顶部流量
                        SummaryItems.SubItems.Add(report.BottomQ.ToString("0.00") ); //底部流量
                        SummaryItems.SubItems.Add(report.LeftQ.ToString("0.00") ); //左岸流量
                        SummaryItems.SubItems.Add(report.RightQ.ToString("0.00") ); //右岸流量
                        SummaryItems.SubItems.Add(report.MiddleQ.ToString("0.00") ); //实测流量

                    }

                    this.listView_Summary.Items.Clear();
                    this.listView_Summary.Items.Add(SummaryItems);

                }
                catch
                {
                }
            } 
        }

        private void RefreshListViewSummary(int iUnit) //LPJ 2013-8-8 更新汇总的单位
        {
            //LPJ 2013-8-8 更新显示的单位
            RefreshListViewHeader(listView_Summary, bEnglish2Metric);

            int iCount=listView_Summary.Items.Count;
            float[] fListViewSummary=new float[13*iCount];
            string[] strListViewSummary=new string[4*iCount];
 
            //将ListView中的值提取出来
            int iData=0;
            int iStr=0;
            for (int i = 0; i < iCount; i++)
            {
                for (int j = 0; j < 17; j++)
                {
                    if (j < 4)
                    {
                        strListViewSummary[iStr] = listView_Summary.Items[i].SubItems[j].Text;
                        iStr++;
                    }
                    else
                    {
                        fListViewSummary[iData] = float.Parse(listView_Summary.Items[i].SubItems[j].Text);
                        iData++;
                    }
                }
            }

            for (int i = 0; i < iCount; i++)
            {
                listView_Summary.Items[i].SubItems.Clear();
            }
               
            //将全部的数值进行替换
            iData=0;
            iStr=0;
            if (iUnit == 0) //新设置的单位为公制
            {
                for (int i = 0; i < iCount; i++)
                {
                    for (int j = 0; j < 17; j++)
                    {
                        if (j == 0)
                        {
                            listView_Summary.Items[i].Text = strListViewSummary[iStr];
                            iStr++;
                        }
                        else if (j < 4)
                        {
                            listView_Summary.Items[i].SubItems.Add(strListViewSummary[iStr]);
                            iStr++;
                        }
                        else
                        {
                            switch (j)
                            {
                                case 4:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 5:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 2).ToString("0.00"));
                                    break;
                                case 6:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 3).ToString("0.00"));
                                    break;
                                case 7:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 8:
                                    listView_Summary.Items[i].SubItems.Add(fListViewSummary[iData].ToString());
                                    break;
                                case 9:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 10:
                                    listView_Summary.Items[i].SubItems.Add(fListViewSummary[iData].ToString());
                                    break;
                                case 11:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                default:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.FeetToMeter(fListViewSummary[iData], 3).ToString("0.00"));
                                    break;
                            }
                            iData++;
                        }
                    }
                }
            }
            else if (iUnit == 1) //新设置的单位为英制,将公制转为英制
            {
                for (int i = 0; i < iCount; i++)
                {
                    for (int j = 0; j < 17; j++)
                    {
                        if (j == 0)
                        {
                            listView_Summary.Items[i].Text = strListViewSummary[iStr];
                            iStr++;
                        }
                        else if (j < 4)
                        {
                            listView_Summary.Items[i].SubItems.Add(strListViewSummary[iStr]);
                            iStr++;
                        }
                        else
                        {
                            switch (j)
                            {
                                case 4:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 5:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 2).ToString("0.00"));
                                    break;
                                case 6:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 3).ToString("0.00"));
                                    break;
                                case 7:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 8:
                                    listView_Summary.Items[i].SubItems.Add(fListViewSummary[iData].ToString());
                                    break;
                                case 9:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                case 10:
                                    listView_Summary.Items[i].SubItems.Add(fListViewSummary[iData].ToString());
                                    break;
                                case 11:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 1).ToString("0.00"));
                                    break;
                                default:
                                    listView_Summary.Items[i].SubItems.Add(projectUnit.MeterToFeet(fListViewSummary[iData], 3).ToString("0.00"));
                                    break;
                            }
                            iData++;
                        }
                    }
                }
            }
            
        }

        private void AddToSummaryList(double[] listData,string name) //LPJ 2013-7-23 将汇总的数据写入summary中
        {
            ListViewItem items0 = new ListViewItem();
            items0.Text = "";
            items0.SubItems.Add("");
            items0.SubItems.Add("");
            items0.SubItems.Add(name); 
            for (int i = 0; i < 13; i++)
            {
                items0.SubItems.Add(listData[i].ToString("0.00"));
            }
            this.listView_Summary.Items.Add(items0);
        }

        public bool bEnglish2Metric = true; //LPJ 2013-7-1 该变量用于设置单位，当单位从公制转为英制，该值为false；当单位从英制转为公制，该值为true
        private void linkLabelUnit_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            int iLastUnit; //LPJ 2013-7-1 定义变量用于标记是否单位进行了修改
            //LPJ 2013-6-20 修改单位
            int iunit; //从smartPage页获取配置
            //if (Resource1.String237 == labelUnit.Text)
            if (!bEnglish2Metric)
                iunit = 1;
            else
                iunit = 0;
            iLastUnit = iunit;
            FrmUnit frmsetUnit = new FrmUnit(iunit);

            if (DialogResult.OK == frmsetUnit.ShowDialog())
            {
                if (0 == frmsetUnit.iUnit)
                    labelUnit.Text = Resource1.String236;
                else
                    labelUnit.Text = Resource1.String237;

            }

            if (iLastUnit != frmsetUnit.iUnit)//单位被修改了
            {
                if (frmsetUnit.iUnit == 0) //新设置的单位为公制
                {
                    //将英制转为公制
                    bEnglish2Metric = true;
                    //smartPage中的数据全部改为公制
                    label4.Text = "(m)";
                    label5.Text = "(m)";
                    label9.Text = "(m)";

                    try
                    {
                        labelTransducerDepth.Text = projectUnit.FeetToMeter(double.Parse(labelTransducerDepth.Text), 1).ToString("0.00");
                    }
                    catch
                    {}

                    try
                    {
                        labelLeftDis.Text = projectUnit.FeetToMeter(double.Parse(labelLeftDis.Text), 1).ToString("0.00");
                    }
                    catch
                    {}

                    try
                    {
                        labelRightDis.Text = projectUnit.FeetToMeter(double.Parse(labelRightDis.Text), 1).ToString("0.00");
                    }
                    catch
                    { }

                    RefreshListViewSummary(0); //LPJ 2013-8-8 
                }
                else if (frmsetUnit.iUnit == 1) //新设置的单位为英制,将公制转为英制
                {
                    bEnglish2Metric = false;
                    //将左右岸距离，换能器入水深度，
                    label4.Text = "(ft)";
                    label5.Text = "(ft)";
                    label9.Text = "(ft)";

                    try
                    {
                        labelTransducerDepth.Text = projectUnit.MeterToFeet(double.Parse(labelTransducerDepth.Text), 1).ToString("0.000");
                    }
                    catch
                    {}

                    try
                    {
                        labelLeftDis.Text = projectUnit.MeterToFeet(double.Parse(labelLeftDis.Text), 1).ToString("0.000");
                    }
                    catch
                    {}

                    try
                    {
                        labelRightDis.Text = projectUnit.MeterToFeet(double.Parse(labelRightDis.Text), 1).ToString("0.000");
                    }
                    catch
                    {}

                    RefreshListViewSummary(1); //LPJ 2013-8-8 
                }
            }

            //更新
            LV_Measured_QPaint();
            listView_Navigation_Paint();
            listView_Others_Paint();

            //if (Resource1.String237 == labelUnit.Text) //LPJ 2013-6-26
            if (!bEnglish2Metric)
            {
                label3.Text = "(ft)";
            }
            else
            {
                label3.Text = "(m)";
            }



            //LPJ 2013-6-24 refresh Summary List

            //LPJ 2014-3-14当回放时，该功能才可用
            if (playBackMode)
                this.BeginInvoke(RefreshSummaryList);//LPJ 2013-11-21
            this.BeginInvoke(CalDischargeRefresh); //LPJ 2013-7-1
            this.BeginInvoke(RefreshDishargePanel); //LPJ 2013-7-1
            this.BeginInvoke(RefreshNavigation); //LPJ 2013-7-1
            this.BeginInvoke(RefreshOthers); //LPJ 2013-7-1
        }

        /// <summary>
        /// Rico
        /// Open the Site Information Dialog.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void linkLabelSiteInfor_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            //LPJ 2013-6-20 修改站信息
            SiteInformation site;
            //site.siteName = labelSiteName.Text;
            //site.stationNumber = labelStationNumber.Text;
            //site.MeasNumber = labelMeasNumber.Text;
            //site.comments = labelSiteComments.Text;

            // Get the currently stored site information
            site = GetSiteInformation(siteInformation);

            // Populate the dialog and display
            FrmSiteInformation frmsiteInfor = new FrmSiteInformation(site);
            if (DialogResult.OK == frmsiteInfor.ShowDialog())
            {
                // Get the information from the dialog and set the values
                labelSiteName.Text = frmsiteInfor.siteInfo.siteName;
                labelStationNumber.Text = frmsiteInfor.siteInfo.stationNumber;
                labelMeasNumber.Text = frmsiteInfor.siteInfo.MeasNumber;
                labelSiteComments.Text = frmsiteInfor.siteInfo.comments;

                // Set the new site information
                siteInformation = GetSiteInformation(frmsiteInfor.siteInfo);
            }
        }

        /// <summary>
        /// Rico
        /// Store the Site Information.
        /// </summary>
        private SiteInformation siteInformation = new SiteInformation();


        private SiteInformation GetSiteInformation(SiteInformation site)
        {
            SiteInformation siteInfo = new SiteInformation();

            siteInfo.siteName = site.siteName;
            siteInfo.stationNumber = site.stationNumber;
            siteInfo.MeasNumber = site.MeasNumber;
            siteInfo.comments = site.comments;

            siteInfo.FieldParty = site.FieldParty;
            siteInfo.ProcessedBy = site.ProcessedBy;
            siteInfo.DeploymentType = site.DeploymentType;

            siteInfo.BoatMotor = site.BoatMotor;
            siteInfo.MeasLocation = site.MeasLocation;

            siteInfo.InsideGageH = site.InsideGageH;
            siteInfo.OutsideGageH = site.OutsideGageH;
            siteInfo.GageHChange = site.GageHChange;
            siteInfo.RatingDischarge = site.RatingDischarge;
            siteInfo.IndexV = site.IndexV;
            siteInfo.RatingNumber = site.RatingNumber;
            siteInfo.RatedArea = site.RatedArea;
            siteInfo.WaterTemp = site.WaterTemp;
            siteInfo.MagnVariationMethod = site.MagnVariationMethod;
            siteInfo.MeasurementRating = site.MeasurementRating;
            //siteInfo.ControlCode1 = site.ControlCode1;
            //siteInfo.ControlCode2 = site.ControlCode2;
            //siteInfo.ControlCode3 = site.ControlCode3;

            return siteInfo;

        }
        
        /// <summary>
        /// Rico
        /// Get the System configuation.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void linkLabelSystemConf_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            //FrmSystemConf.SystemConf sysconf;
            //sysconf.FirmwareVersion=labelFirmWare.Text;
            //sysconf.SystemNumber = labelSystemNumber.Text;

            //FrmSystemConf frmsystemConf = new FrmSystemConf(sysconf);
            //if (DialogResult.OK == frmsystemConf.ShowDialog())
            //{
            //    labelFirmWare.Text = frmsystemConf.systemConf.FirmwareVersion;
            //    labelSystemNumber.Text = frmsystemConf.systemConf.SystemNumber;
            //}
        }
        

        public int iVesselSpeedRef = 0; //LPJ 2016-8-18 船速参考

        /// <summary>
        /// Rico
        /// Store the System configuration settings.
        /// </summary>
        SystemSetting systSet = new SystemSetting(); //从配置文件中读取参数，并将其写入smartPage中

        private void SystemSetting()
        {
            sp.DataReceived -= new SerialDataReceivedEventHandler(sp_DataReceived);

            // Set the COM ports and Baud rates
            systSet.sAdcpPort = sp.PortName;
            systSet.sAdcpBaud = sp.BaudRate;
            systSet.bGPSConnect = bGPSConnect;
            if(bGPSConnect)
            {
                systSet.sGpsPort = GPS_sp.PortName;
                systSet.sGpsBaud = GPS_sp.BaudRate;
            }
            else
            {
                systSet.sGpsPort = "";
                systSet.sGpsBaud = 0;
            }

            systSet.firmware = labelFirmWare.Text;

            if (labelHeadingRef.Text == Resource1.String230)
                systSet.iHeadingRef = 0;
            else
                systSet.iHeadingRef = 1;

            int iLastHeadingRef = systSet.iHeadingRef; //LPJ 2016-8-16
            double fLastHeadingOffset = systSet.dHeadingOffset; //LPJ 2017-5-15 

            if (labelVesselRef.Text == Resource1.String232)
                systSet.iSpeedRef = 0;
            else if (labelVesselRef.Text == "GPS VTG")
                systSet.iSpeedRef = 1;
            else if (labelVesselRef.Text == "GPS GGA")
                systSet.iSpeedRef = 3;
            else
                systSet.iSpeedRef = 2;

            try
            {
                systSet.dSalinity = double.Parse(labelSalinity.Text);  //LPJ 2014-6-16
            }
            catch
            {
                systSet.dSalinity = 0;
            }
            try
            {
                systSet.dHeadingOffset = double.Parse(label_Headingoffset.Text); //LPJ 2014-6-16
            }
            catch
            {
                systSet.dHeadingOffset = 0;
            }
            try
            {
                systSet.dTransducerDepth = double.Parse(labelTransducerDepth.Text);
            }
            catch
            {
                systSet.dTransducerDepth = 0.1;
            }

            try
            {
                //systSet.dSpeedOfSound = systSet.dSpeedOfSound;
            }
            catch
            {
                systSet.dSpeedOfSound = 1500.0;
            }

            if (!bEnglish2Metric)
                systSet.bEnglishUnit = true;
            else
                systSet.bEnglishUnit = false;

            frmsystemSet = new FrmSystemSetting(sp, ref systSet);

            if (!playBackMode)
                sp.Close();

            string BSlist = "";

            

            if (DialogResult.OK == frmsystemSet.ShowDialog(ref systSet, ref BSlist))
            {
                sp.Close();
                sp.Open();

                CommandList = "";
                progressBar1.Value = 0;
                progressBar1.Visible = true;

                // Set cursor as hourglass
                Cursor.Current = Cursors.WaitCursor;
                // Set cursor as default arrow
                //Cursor.Current = Cursors.Default;

                try
                {
                    string CMD = "STOP" + '\r';
                    sp.Write(CMD);
                    Thread.Sleep(150);
                    int count = 0;
                    while (!ReceiveBufferString.Contains("STOP") && count < 5)
                    {
                        sp.Write("STOP" + '\r');
                        Thread.Sleep(150);
                        count++;
                    }

                    var reader = new StringReader(BSlist);
                    string cmd = reader.ReadLine();
                    while (cmd != null)
                    {
                        try
                        {
                            if (cmd != "")
                            {
                                cmd += '\r';
                                sp.Write(cmd);
                                CommandList += cmd + '\n';
                                displayprocessbar(4, progressBar1);
                                Thread.Sleep(150);
                            }

                        }
                        catch { }
                        try
                        {
                            cmd = reader.ReadLine();
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show(ex.Message);
                        }
                    }

                    SendStandardCommand();

                    CMD = "CSAVE\r";
                    sp.Write(CMD);
                    CommandList += CMD + '\n';
                    Thread.Sleep(1000);

                    //CMD = "START\r";
                    //sp.Write(CMD);
                }
                catch { }

                progressBar1.Value = 100;

                textBoxCommandSet.Text = CommandList;

                if (!playBackMode)
                    sp.Close();

                CommandsInitialized = true;
                switch (systSet.iHeadingRef)
                {
                    case 0:
                        {
                            labelHeadingRef.Text = "None";
                            break;
                        }
                    case 1:
                        {
                            labelHeadingRef.Text = Resource1.String230;
                            break;
                        }
                    case 2:
                        {
                            labelHeadingRef.Text = Resource1.String231;
                            break;
                        }

                    default:
                        break;
                }
                switch (systSet.iSpeedRef)
                {
                    case 0:
                        {
                            labelVesselRef.Text = Resource1.String232;
                            break;
                        }
                    case 1:
                        {
                            labelVesselRef.Text = "GPS VTG";
                            break;
                        }
                    case 3:
                        {
                            labelVesselRef.Text = "GPS GGA";
                            break;
                        }
                    case 2:
                        {
                            labelVesselRef.Text = Resource1.String233;
                            break;
                        }
                    default:
                        break;
                }
                switch (systSet.iMeasurmentMode)
                {
                    case 0:
                        labelMeasMode.Text = "NONE";
                        break;
                    case 1:
                        labelMeasMode.Text = "Low Frequency";
                        break;
                    case 2:
                        labelMeasMode.Text = "High Frequency";
                        break;
                    case 3:
                        labelMeasMode.Text = "Auto Frequency";
                        break;
                }
                labelTransducerDepth.Text = systSet.dTransducerDepth.ToString();
                labelSalinity.Text = systSet.dSalinity.ToString();
                label_Headingoffset.Text = systSet.dHeadingOffset.ToString(); //LPJ 2014-6-16
                fHeadingOffset = systSet.dHeadingOffset; //LPJ 2016-8-12

                iVesselSpeedRef = systSet.iSpeedRef; //LPJ 2016-8-18 船速参考
            }
            

            sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);

            if (!playBackMode)
            {
                try
                {
                    sp.Close();
                    sp.Open();
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                }
            }
            if (playBackMode)
            {
                if ((iLastHeadingRef != systSet.iHeadingRef) || (Math.Abs(fHeadingOffset - fLastHeadingOffset) >= 0.00000001))//LPJ 2016-8-16 当回放模式时，艏向参考更改时，更新数据 //LPJ 2017-5-15 当艏向偏差更改了，更新数据
                {
                    RefreshHDT();
                }
            }

            if (playBackMode)
                this.BeginInvoke(RefreshSummaryList); //LPJ 2013-11-21
            this.BeginInvoke(CalDischargeRefresh); //LPJ 2013-11-21
            this.BeginInvoke(RefreshDishargePanel); //LPJ 2013-11-21
            this.BeginInvoke(RefreshNavigation); //LPJ 2013-11-21
            this.BeginInvoke(RefreshOthers); //LPJ 2013-11-21

            // Set cursor as default arrow
            Cursor.Current = Cursors.Default;
        }
        private void linkLabelSystemSetting_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            SystemSetting();
            

        }
        

        /// <summary>
        /// Rico
        /// Edge Settings.
        /// </summary>
        EdgeSetting edgeSetting;
        private void GetEdgeSetting() //LPJ 2013-6-21
        {
            edgeSetting = new EdgeSetting();
            //if (labelUnit.Text == Resource1.String237) //LPJ 2013-7-1 增加单位判断
            if (!bEnglish2Metric)
            {
                edgeSetting.bEnglishUnit = true;
            }
            else
            {
                edgeSetting.bEnglishUnit = false;
            }

            if (labelTopEstimate.Text == Resource1.String33)
                edgeSetting.iTopEstimate = 0;
            else if (labelTopEstimate.Text == Resource1.String224)
                edgeSetting.iTopEstimate = 1;
            else
                edgeSetting.iTopEstimate = 2;

            if (labelBottomEstimate.Text == Resource1.String33)
                edgeSetting.iBottomEstimate = 0;
            else 
                edgeSetting.iBottomEstimate = 1;
            try
            {
                edgeSetting.dPowerCurveCoeff = double.Parse(labelPowerCurveCoeff.Text);
            }
            catch
            {
                edgeSetting.dPowerCurveCoeff = 0.1667;
            }

            if (labelStartEdge.Text == Resource1.String226)
            {
                bStartLeftEdge = true;
                edgeSetting.bStartLeft = true;
                
            }
            else
            {
                bStartLeftEdge = false;
                edgeSetting.bStartLeft = false;
                
            }
            try
            {
                edgeSetting.dLeftDis = double.Parse(labelLeftDis.Text);
            }
            catch
            {
                edgeSetting.dLeftDis = 0;
            }

            try
            {
                edgeSetting.dRightDis = double.Parse(labelRightDis.Text);
            }
            catch
            {
                edgeSetting.dRightDis = 0;
            }

            if (labelLeftType.Text == Resource1.String221)
                edgeSetting.iLeftType = 0;
            else if (labelLeftType.Text == Resource1.String222)
                edgeSetting.iLeftType = 1;
            else
                edgeSetting.iLeftType = 2;

            try
            {
                edgeSetting.dLeftRef = double.Parse(labelLeftRef.Text);
            }
            catch
            {
                edgeSetting.dLeftRef = 0.35;
            }

            if (labelRightType.Text == Resource1.String221)
                edgeSetting.iRightType = 0;
            else if (labelRightType.Text == Resource1.String222)
                edgeSetting.iRightType = 1;
            else
                edgeSetting.iRightType = 2;

            try
            {
                edgeSetting.dRightRef = double.Parse(labelRightRef.Text);
            }
            catch
            {
                edgeSetting.dRightRef = 0.35;
            }
            
        }
        private void linkLabelEdgeSetting_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            GetEdgeSetting();

            FrmEdgeSetting frmedgeSet = new FrmEdgeSetting(edgeSetting);
            if (DialogResult.OK == frmedgeSet.ShowDialog())
            {
                switch (FrmEdgeSetting.edgeSet.iTopEstimate)
                {
                    case 0:
                        {
                            labelTopEstimate.Text = Resource1.String33;
                            break;
                        }
                    case 1:
                        {
                            labelTopEstimate.Text = Resource1.String224;
                            break;
                        }
                    case 2:
                        {
                            labelTopEstimate.Text = Resource1.String225;
                            break;
                        }
                    default:
                        break;
                }
                switch (FrmEdgeSetting.edgeSet.iBottomEstimate)
                {
                    case 0:
                        {
                            labelBottomEstimate.Text = Resource1.String33;
                            break;
                        }
                    case 1:
                        {
                            labelBottomEstimate.Text = Resource1.String224;
                            break;
                        }
                    default:
                        break;
                }
                labelPowerCurveCoeff.Text = FrmEdgeSetting.edgeSet.dPowerCurveCoeff.ToString();

                //CurrentState = TRANSECT_STATE_EDGE;
                if (FrmEdgeSetting.edgeSet.bStartLeft)
                {
                    bStartLeftEdge = true;
                    labelStartEdge.Text = Resource1.String226;
                    CurrentEdge = TRANSECT_EDGE_LEFT;
                }
                else
                {
                    bStartLeftEdge = false;
                    labelStartEdge.Text = Resource1.String227;
                    CurrentEdge = TRANSECT_EDGE_RIGHT;
                }
                labelLeftDis.Text = FrmEdgeSetting.edgeSet.dLeftDis.ToString();

                EdgeType[0] = FrmEdgeSetting.edgeSet.iLeftType;
                EdgeDistance[0] = FrmEdgeSetting.edgeSet.dLeftDis;
                EdgeReference[0] = FrmEdgeSetting.edgeSet.dLeftRef;
                EdgeType[1] = FrmEdgeSetting.edgeSet.iRightType;
                EdgeDistance[1] = FrmEdgeSetting.edgeSet.dRightDis;
                EdgeReference[1] = FrmEdgeSetting.edgeSet.dRightRef;

                switch (FrmEdgeSetting.edgeSet.iLeftType)
                {
                    case 0:
                        {
                            labelLeftType.Text = Resource1.String221;
                            break;
                        }
                    case 1:
                        {
                            labelLeftType.Text = Resource1.String222;
                            break;
                        }
                    case 2:
                        {
                            labelLeftType.Text = Resource1.String223;
                            break;
                        }
                    default:
                        break;
                }
                labelLeftRef.Text = FrmEdgeSetting.edgeSet.dLeftRef.ToString(); //LPJ 2013-11-19

                labelRightDis.Text = FrmEdgeSetting.edgeSet.dRightDis.ToString();

                labelLeftRef.Top = labelLeftType.Top;

                

                switch (FrmEdgeSetting.edgeSet.iRightType)
                {
                    case 0:
                        {
                            labelRightType.Text = Resource1.String221;
                            break;
                        }
                    case 1:
                        {
                            labelRightType.Text = Resource1.String222;
                            break;
                        }
                    case 2:
                        {
                            labelRightType.Text = Resource1.String223;
                            break;
                        }
                    default:
                        break;
                }
                labelRightRef.Text = FrmEdgeSetting.edgeSet.dRightRef.ToString(); //LPJ 2013-11-19
                labelRightRef.Top = labelRightType.Top;

                //LPJ 2013-6-24 refresh Summary List
                if (playBackMode)
                {
                    listView_Summary.Refresh();  //LPJ 2015-12-31 重新计算汇总结果
                    this.BeginInvoke(RefreshSummaryList);
                }
                this.BeginInvoke(CalDischargeRefresh); //LPJ 2013-7-1
                this.BeginInvoke(RefreshDishargePanel); //LPJ 2013-7-1
                this.BeginInvoke(RefreshNavigation); //LPJ 2013-7-1
                this.BeginInvoke(RefreshOthers); //LPJ 2013-7-1
            }
        }

        #region QRev Project and Transect Logic

        public void CreateNewProjectPath()
        {
            DateTime dt = DateTime.Now;
            string datePatt = @"yyyyMMdd_HHmmss";

            // Create a project name based on the Site Name and the date and time
            ProjectFullName = labelSiteName.Text + "_" + dt.ToString(datePatt);

            // Get the project default folder path
            var folderPath = RttProject.GetDefaultFolderPath();
            
            
            // Combine the default folder path for the project and the project name
            // This will create a folder for each project
            folderPath = Path.Combine(folderPath, ProjectFullName);

            // Create the Folder if it does not exist
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }

            // Create the project path based on the folder path and project name
            //newPath = Path.Combine(folderPath, ProjectFullName);
            newPath = folderPath;
        }

        /// <summary>
        /// Create a QRev Transect.  Give the file name
        /// for the transect.
        /// 
        /// The file name is the file with the recorded ensemble data.
        /// </summary>
        /// <param name="ensFileName">Ensemble file name.</param>
        /// <param name="edgeSet">Edge Setting used for this transect.</param>
        /// <param name="systemSet">System Settings Used for this transect.</param>
        /// <param name="cmdList">List of commands used for the transect.</param>
        public void CreateQRevTransect(string ensFileName, EdgeSetting edgeSet, SystemSetting systemSet, string cmdList)
        {
            _qrevTransect = new TransectConfig();
            _qrevTransect.AddFile(ensFileName);
            _qrevTransect.SetEdgeSettings(edgeSetting);
            _qrevTransect.SetSystemSettings(systSet);
            _qrevTransect.SetCommandList(CommandList);

            // Reset the Edge Count values
            _qrevStartEnsCount = 0;
            _bIsQRevStartCounter = false;
            _qrevEndEnsCount = 0;
            _bIsQRevEndCounter = false;
            _qrevMovingEnsCount = 0;
        }

        /// <summary>
        /// Start the Ensemble counter for the start edge.
        /// Then set the edge settings to the transect.
        /// </summary>
        /// <param name="isStartLeft">Flag if the transect starts on the left or right.</param>
        /// <param name="startDist">Start distance.</param>
        /// <param name="startType">Start contour Type.  Rectangluar or Angled.</param>
        /// <param name="startCoeff">Start coeffienct.</param>
        /// <param name="topMethod">Top method used to calculate Q.</param>
        /// <param name="bottomMethod">Bottom Method to calcualte Q.</param>
        /// <param name="powerCurveCoeff">Power Curve Coefficent for Top method.</param>
        public void SetQRevStartEdgeSettings(bool isStartLeft, double startDist, int startType, decimal startCoeff, int topMethod, int bottomMethod, double powerCurveCoeff)
        {
            // Start the QRev Start Edge Counter
            StartQRevStartEdgeCounter();

            // Set the start edge settings to the transect
            _qrevTransect.SetStartEdgeSettings(isStartLeft,         // Is starting on left or right side
                                                startDist,          // Start distance
                                                startType,          // Start Edge Type (rectangular or angled)
                                                startCoeff,         // Start Coeffienct
                                                topMethod,          // Top Method
                                                bottomMethod,       // Bottom Method
                                                powerCurveCoeff);   // Power Curve Coeffienct

        }

        /// <summary>
        /// Set the End Edge Settings.
        /// </summary>
        /// <param name="isStartLeft">Check which edge was start.</param>
        /// <param name="endDist">End distance.</param>
        /// <param name="endType">End Edge Type.</param>
        /// <param name="endCoeff">End Edge Coeffienct.</param>
        public void SetQRevEndEdgeSettings(bool isStartLeft, double endDist, int endType, decimal endCoeff)
        {
            // Start counting the edge ensembles
            StartQRevEndEdgeCounter();

            // Set the edge settings
            _qrevTransect.SetEndEdgeSettings(isStartLeft, endDist, endType, endCoeff);
        }

        /// <summary>
        /// Start the Start Edge counter.  This will
        /// keep track of the number of ensembles in the
        /// start edge.
        /// </summary>
        public void StartQRevStartEdgeCounter()
        {
            // Reset the counter and turn it on
            _qrevStartEnsCount = 0;
            _bIsQRevStartCounter = true;
        }

        /// <summary>
        /// Stop the Start Edge counting and set the value to the
        /// transect.
        /// </summary>
        /// <param name="isStartLeft">Did the transect start on the right or left.</param>
        public void StopQRevStartEdgeCounter(bool isStartLeft)
        {
            // Set the flag to stop
            _bIsQRevStartCounter = false;

            // Pass the value to the transect
            _qrevTransect.SetStartEdgeEnsCount(isStartLeft, _qrevStartEnsCount);
        }

        /// <summary>
        /// Start the End Edge counter.  This will
        /// keep track of the nubmer of ensembles in the
        /// end edge.
        /// </summary>
        public void StartQRevEndEdgeCounter()
        {
            // Reset the counter and turn it on
            _qrevEndEnsCount = 0;
            _bIsQRevEndCounter = true;
        }

        public void StopQRevEndEdgeCounter(bool isStartLeft)
        {
            // Set the flag to stop
            _bIsQRevEndCounter = false;

            // Pass the value to the transect
            _qrevTransect.SetEndEdgeEnsCount(isStartLeft, _qrevEndEnsCount);
        }

        /// <summary>
        /// Create the QRev Project file.
        /// This will generate a unique project name
        /// using the date and time.
        /// </summary>
        public void CreateQRevProject(string siteName)
        {
            DateTime dt = DateTime.Now;

            // Create the project name
            string projectName = "RTI_QRev_" + ProjectFullName;

            // Get the project default folder path
            //var folderPath = RttProject.GetDefaultFolderPath();

            // Combine the default folder path for the project and the project name
            // This will create a folder for each project
            //folderPath = Path.Combine(folderPath, ProjectFullName);

            // Create the project with the folder path and project name
            //_qrevProject = new RttProject(folderPath, projectName);
            _qrevProject = new RttProject(newPath, projectName);
        }

        /// <summary>
        ///  Add the latest QRev Transect to the project.
        ///  A new transect will be created later.
        /// </summary>
        public void AddQRevTransectToProject()
        {
            // Add the transect to the project
            _qrevProject.AddTransect(_qrevTransect);

            // Write the latest project file
            SaveQRevProjectFile();
        }

        /// <summary>
        /// Rico
        /// Write the QRev Project file.  This project
        /// file is used to playback the data in QRev.
        /// </summary>
        public void SaveQRevProjectFile()
        {
            // Save all the settings to the project
            _qrevProject.SaveProject(siteInformation, systSet, labelInstrumentSN.Text, labelSystemNumber.Text);
        }

        #endregion

        /// <summary>
        /// Rico
        /// Write the settings to the configuration file.
        /// </summary>
        /// <param name="fileName"></param>
        private void WriteSmartPageToFile(string fileName) //LPJ 2013-6-20 将smartPage页中的所有设置写入配置文件
        {
            // Write the QRev Project File
            SaveQRevProjectFile();

            //File.WriteAllText(fileName, "Language " + "" + "\r\n"); //将语言单独写一个configuration
            File.WriteAllText(fileName, "ADCP_PortName " + sp.PortName + "\r\n");
            File.AppendAllText(fileName, "ADCP_BaudRate " + sp.BaudRate + "\r\n");

            if (bGPSConnect)
                File.AppendAllText(fileName, "GPS_Connect 1" + "\r\n");//LPJ 2013-9-25 当连接GPS为true，否则为false
            else
                File.AppendAllText(fileName, "GPS_Connect 0" + "\r\n");
            File.AppendAllText(fileName, "GPS_SerialPort " + GPS_sp.PortName + "\r\n");
            File.AppendAllText(fileName, "GPS_Baudrate " + GPS_sp.BaudRate + "\r\n");


            //if (labelUnit.Text == Resource1.String236)
            if (bEnglish2Metric)
                File.AppendAllText(fileName, "Unit 0" + "\r\n");
            else
                File.AppendAllText(fileName, "Unit 1" + "\r\n");
            //File.AppendAllText(fileName, "Unit " + labelUnit.Text + "\r\n");
 
            #region write site information to file
            //File.AppendAllText(fileName, "SiteName " + labelSiteName.Text + "\r\n");
            //File.AppendAllText(fileName, "StationNumber " +labelStationNumber.Text +"\r\n");
            //File.AppendAllText(fileName, "MeasurementNumber " + labelMeasNumber.Text + "\r\n");
            //File.AppendAllText(fileName, "Comments " + labelSiteComments.Text + "\r\n");
           
            // Write the site information to the file
            WriteSiteInformationToFile(fileName, siteInformation);
            #endregion

            //File.AppendAllText(fileName, "SerialNumber " +labelsn +"\r\n");
            File.AppendAllText(fileName, "FirmwareVersion " + labelFirmWare.Text+"\r\n");
            File.AppendAllText(fileName, "InstrumentSN " + labelInstrumentSN.Text + "\r\n");  //LPJ  2016-12-14
            File.AppendAllText(fileName, "SystemNumber " + labelSystemNumber.Text+"\r\n");

            //if (labelFlowRef.Text == Resource1.String228) //LPJ 2013-7-24 cancel
            //    File.AppendAllText(fileName, "FlowReference 0"  + "\r\n");
            //else
            //    File.AppendAllText(fileName, "FlowReference 1" + "\r\n");
            //File.AppendAllText(fileName, "FlowReference " + labelFlowRef.Text+"\r\n");
            if (labelVesselRef.Text == Resource1.String232)
                File.AppendAllText(fileName, "VesselSpeedReference 0" + "\r\n");
            else if (labelVesselRef.Text == Resource1.String233)
                File.AppendAllText(fileName, "VesselSpeedReference 2" + "\r\n");
            else if(labelVesselRef.Text =="GPS VTG")
                File.AppendAllText(fileName, "VesselSpeedReference 1" + "\r\n");
            else
                File.AppendAllText(fileName, "VesselSpeedReference 3" + "\r\n");
            //File.AppendAllText(fileName, "VesselSpeedReference " + labelVesselRef.Text+"\r\n");

            if (labelHeadingRef.Text == Resource1.String230)
                File.AppendAllText(fileName, "HeadingReference 0"  + "\r\n");
            else
                File.AppendAllText(fileName, "HeadingReference 1" + "\r\n");
            
            File.AppendAllText(fileName, "HeadingOffset " + label_Headingoffset.Text + "\r\n"); //LPJ 2014-6-16
            File.AppendAllText(fileName, "Salinity " + labelSalinity.Text + "\r\n"); //LPJ 2014-6-16
            File.AppendAllText(fileName, "TransducerDepth " + labelTransducerDepth.Text + "\r\n");
            
            if (labelTopEstimate.Text == Resource1.String33)
                File.AppendAllText(fileName, "TopMode 0 "  + "\r\n");
            else if (labelTopEstimate.Text == Resource1.String224)
                File.AppendAllText(fileName, "TopMode 1 " + "\r\n");
            else
                File.AppendAllText(fileName, "TopMode 2 " + "\r\n");
          
            if (labelBottomEstimate.Text == Resource1.String33)
                File.AppendAllText(fileName, "BottomMode 0 " + "\r\n");
            else
                File.AppendAllText(fileName, "BottomMode 1 " + "\r\n");
          
            File.AppendAllText(fileName, "PowerCoff " + labelPowerCurveCoeff.Text + "\r\n");

            if (labelStartEdge.Text == Resource1.String226)
                File.AppendAllText(fileName, "StartBank 0"  + "\r\n");
            else
                File.AppendAllText(fileName, "StartBank 1" + "\r\n");
            //File.AppendAllText(fileName, "StartBank " + labelStartEdge.Text + "\r\n"); //在测量结束后，将左右岸信息再重新写入
            File.AppendAllText(fileName, "LeftBankDist " + labelLeftDis.Text + "\r\n");

            if (labelLeftType.Text == Resource1.String221)
                File.AppendAllText(fileName, "LeftBankStyle 0 " +  "\r\n");
            else if (labelLeftType.Text == Resource1.String222)
                File.AppendAllText(fileName, "LeftBankStyle 1 " + "\r\n");
            else
                File.AppendAllText(fileName, "LeftBankStyle 2 " +  "\r\n");

            
            File.AppendAllText(fileName, "LeftBankCoff " + labelLeftRef.Text + "\r\n");
            File.AppendAllText(fileName, "LeftBankPings " + dLeftShorePings.ToString() + "\r\n");
            File.AppendAllText(fileName, "RightBankDist " + labelRightDis.Text + "\r\n");

            if (labelRightType.Text == Resource1.String221)
                File.AppendAllText(fileName, "RightBankStyle 0 " + "\r\n");
            else if (labelRightType.Text == Resource1.String222)
                File.AppendAllText(fileName, "RightBankStyle 1 " + "\r\n");
            else
                File.AppendAllText(fileName, "RightBankStyle 2 " + "\r\n");
            //File.AppendAllText(fileName, "RightBankStyle " + labelRightType.Text + "\r\n");
            File.AppendAllText(fileName, "RightBankCoff " + labelRightRef.Text + "\r\n");
            File.AppendAllText(fileName, "RightBankPings " + dRightShorePings.ToString() + "\r\n"); //LPJ 2013-5-29 将右岸平均呯数写入配置文件中

            WriteStandardModeToFile(fileName); //lpj 2013-7-30
        }

        private void WriteSiteInformationToFile(string fileName, SiteInformation site)
        {
            File.AppendAllText(fileName, "SiteName " + site.siteName + "\r\n");
            File.AppendAllText(fileName, "StationNumber " + site.stationNumber + "\r\n");
            File.AppendAllText(fileName, "MeasurementNumber " + site.MeasNumber + "\r\n");

            File.AppendAllText(fileName, "FieldParty " + site.FieldParty + "\r\n"); 
            File.AppendAllText(fileName, "ProcessedBy " + site.ProcessedBy + "\r\n");
            File.AppendAllText(fileName, "DeploymentType " + site.DeploymentType + "\r\n");
            File.AppendAllText(fileName, "BoatMotor " + site.BoatMotor + "\r\n");
            File.AppendAllText(fileName, "MeasLocation " + site.MeasLocation + "\r\n");

            File.AppendAllText(fileName, "InsideGageH " + site.InsideGageH + "\r\n");
            File.AppendAllText(fileName, "OutsideGageH " + site.OutsideGageH + "\r\n");
            File.AppendAllText(fileName, "GageHChange " + site.GageHChange + "\r\n");
            File.AppendAllText(fileName, "RatingDischarge " + site.RatingDischarge + "\r\n");
            File.AppendAllText(fileName, "IndexV " + site.IndexV + "\r\n");

            File.AppendAllText(fileName, "RatingNumber " + site.RatingNumber + "\r\n");
            File.AppendAllText(fileName, "RatedArea " + site.RatedArea + "\r\n");
            File.AppendAllText(fileName, "WaterTemp " + site.WaterTemp + "\r\n");
            File.AppendAllText(fileName, "MagnVariationMethod " + site.MagnVariationMethod + "\r\n");
            File.AppendAllText(fileName, "MeasurementRating " + site.MeasurementRating + "\r\n");

            //File.AppendAllText(fileName, "ControlCode1 " + site.ControlCode1 + "\r\n");
            //File.AppendAllText(fileName, "ControlCode2 " + site.ControlCode2 + "\r\n");
            //File.AppendAllText(fileName, "ControlCode3 " + site.ControlCode3 + "\r\n");
         
            File.AppendAllText(fileName, "Comments " + site.comments + "\r\n");

        }

        private void WriteStandardModeToFile(string fileName) //主要用于将高级模式的参数写入last配置中，在回放文件中不用显示该配置
        {
            File.AppendAllText(fileName, CommandList);
        }
        private bool GetFileToGPS(string fileName) //LPJ 2014-7-29 从GPS文件中提取坐标
        {
            CDecodeGPS decodeGPS = new CDecodeGPS();
            if (File.Exists(fileName))
            {
                StreamReader sr = new StreamReader(fileName);
                string cmd = sr.ReadLine();
                int i=0;
                while (cmd != null)
                {
                    if (cmd.Contains("GPGGA"))
                    {
                        decodeGPS.GPSNMEA_decode(cmd, "GPGGA", ref GPS_GGAbuffer);
                        GGAsave[i++] = GPS_GGAbuffer;

                        EnsemblesInfoToStore.GPS_GGAbuffer.Add(GPS_GGAbuffer);
                        ComputeXYposition(GPS_GGAbuffer);
                        EnsemblesInfoToStore.UTMpoint.Add(UTMpoint);
                        EnsemblesInfoToStore.GPS_latitude.Add(GPS_FloatLatitude);
                        EnsemblesInfoToStore.GPS_longitude.Add(GPS_FloatLongitude);
                      
                        EnsemblesInfoToStore.VXstore.Add(VXstore);
                        //AverageVXsave[GGAsaveCount] = VXstore;
                        EnsemblesInfoToStore.VYstore.Add(VYstore);
                        //AverageVYsave[GGAsaveCount] = VYstore;

                        totalNum++;
                        GGAsaveCount++;
                    }
                    else if (cmd.Contains("GPHDT"))
                    {
                        decodeGPS.GPSNMEA_decode(cmd, "GPHDT", ref GPS_HDTbuffer);
                        EnsemblesInfoToStore.GPS_HDTbuffer.Add(GPS_HDTbuffer);

                        float GPSHDT=0;
                        decodeGPS.GPS_HDTdecode(GPS_HDTbuffer, ref GPSHDT);

                        EnsemblesInfoToStore.GPS_HDT.Add(GPSHDT.ToString());  
                    }
                    else if (cmd.Contains("GPVTG"))
                    {
                        decodeGPS.GPSNMEA_decode(cmd, "GPVTG", ref GPS_VTGbuffer);  
                        EnsemblesInfoToStore.GPS_VTGbuffer.Add(GPS_VTGbuffer);

                        float ve = 0, vn = 0;
                        float GPS_boatspeed = 0;
                        double GPS_angle = 0;
                        decodeGPS.GPS_VTGdecode(GPS_VTGbuffer, ref GPS_boatspeed, ref GPS_angle, ref ve, ref vn);

                        EnsemblesInfoToStore.gpsShipSpeed.Add(GPS_boatspeed.ToString());

                    }
                    else if (cmd.Contains("HEROT"))
                    {
                        decodeGPS.GPSNMEA_decode(cmd, "HEROT", ref GPS_ROTbuffer);
                        EnsemblesInfoToStore.GPS_ROTbuffer.Add(GPS_ROTbuffer);
                    }
                    //else if (cmd.Contains("VXVY"))
                    //    decodeGPS.GPSNMEA_decode(cmd, "VXVY", ref GPS);

                    cmd = sr.ReadLine();
                }

                try
                {
                    if (System.Math.Abs((float)(EnsemblesInfoToStore.GPS_latitude[0]) - StartLatitude) > 10.0 || System.Math.Abs((float)(EnsemblesInfoToStore.GPS_longitude[0]) - StartLongitude) > 10.0)
                    {
                        StartLatitude = (float)(EnsemblesInfoToStore.GPS_latitude[0]);
                        StartLongitude = (float)(EnsemblesInfoToStore.GPS_longitude[0]);
                        ComputeLatLongGridText(StartLatitude, StartLongitude);
                    }
                }
                catch
                {
                }

                return true;
            }
            else
            {
                return false;
            }
        }
        private bool GetFileToSmartPage(string fileName)//LPJ 2013-6-20 读取配置文件，并更新smartPage页
        {
            if (File.Exists(fileName))
            {
                textBoxSmartPageFile.Text = "";
                try
                {
                    StreamReader sr = new StreamReader(fileName);
                    string cmd = sr.ReadLine();
                    
                    string[] cmdPart = new string[2];
                    while (cmd != null)
                    {
                        textBoxSmartPageFile.Text += cmd + "\r\n";
                        cmdPart = cmd.Split(' ');
                        switch (cmdPart[0])
                        {
                            case "ADCP_PortName":
                                {
                                    defaultADCP_PortName = cmdPart[1];
                                    labelSN.Text = defaultADCP_PortName;
                                    break;
                                }
                            case "ADCP_BaudRate":
                                {
                                    defaultADCP_Baudrate = int.Parse(cmdPart[1]);
                                    break;
                                }
                            case "GPS_SerialPort":
                                {
                                    //defaultGPS_PortName = cmdPart[1];
                                    break;
                                }
                            case "GPS_Baudrate":
                                {
                                    //defaultGPS_Baudrate = int.Parse(cmdPart[1]);
                                    break;
                                }

                            case "GPS_Connect":  //LPJ 2013-9-25
                                {
                                    if (playBackMode)
                                    {
                                        if (1 == int.Parse(cmdPart[1]))
                                            bGPSConnect = true;
                                        else
                                            bGPSConnect = false;
                                    }
                                    break;
                                }

                            case "Unit":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                    {
                                        bEnglish2Metric = true;
                                        labelUnit.Text = Resource1.String236;
                                    }
                                    else
                                    {
                                        bEnglish2Metric = false;
                                        labelUnit.Text = Resource1.String237;
                                    }
                                    break;
                                    //labelUnit.Text = cmdPart[1];
                                    //break;
                                }
                            case "SiteName":
                                {
                                    labelSiteName.Text = cmdPart[1];
                                    siteInformation.siteName = cmdPart[1];
                                    break;
                                }
                            case "StationNumber":
                                {
                                    labelStationNumber.Text = cmdPart[1];
                                    siteInformation.stationNumber = cmdPart[1];
                                    break;
                                }
                            case "MeasurementNumber":
                                {
                                    labelMeasNumber.Text = cmdPart[1];
                                    siteInformation.MeasNumber = cmdPart[1];
                                    break;
                                }
                            case "FieldParty":
                                {
                                    siteInformation.FieldParty = cmdPart[1];
                                    break;
                                }
                            case "ProcessedBy":
                                {
                                    siteInformation.ProcessedBy = cmdPart[1];
                                    break;
                                }
                            case "DeploymentType":
                                {
                                    siteInformation.DeploymentType = int.Parse(cmdPart[1]);
                                    break;
                                }
                            case "BoatMotor":
                                {
                                    siteInformation.BoatMotor = cmdPart[1];

                                    break;
                                }
                            case "MeasLocation":
                                {
                                    siteInformation.MeasLocation = cmdPart[1];
                                    break;
                                }
                            case "InsideGageH":
                                {
                                    siteInformation.InsideGageH = cmdPart[1];
                                    break;
                                }
                            case "OutsideGageH":
                                {
                                    siteInformation.OutsideGageH = cmdPart[1];
                                    break;
                                }
                            case "GageHChange":
                                {
                                    siteInformation.GageHChange = cmdPart[1];
                                    break;
                                }
                            case "RatingDischarge":
                                {
                                    siteInformation.RatingDischarge = cmdPart[1];
                                    break;
                                }
                            case "IndexV":
                                {
                                    siteInformation.IndexV = cmdPart[1];
                                    break;
                                }
                            case "RatingNumber":
                                {
                                    siteInformation.RatingNumber = cmdPart[1];
                                    break;
                                }
                            case "RatedArea":
                                {
                                    siteInformation.RatedArea = cmdPart[1];
                                    break;
                                }
                            case "WaterTemp":
                                {
                                    siteInformation.WaterTemp = cmdPart[1];
                                    break;
                                }
                            case "MagnVariationMethod":
                                {
                                    siteInformation.MagnVariationMethod = int.Parse(cmdPart[1]);
                                    break;
                                }
                            case "MeasurementRating":
                                {
                                    siteInformation.MeasurementRating = int.Parse(cmdPart[1]);
                                    break;
                                }
                            //case "ControlCode1":
                            //        {
                            //            siteInformation.ControlCode1 = int.Parse(cmdPart[1]);
                            //            break;
                            //        }
                            //case "ControlCode2":
                            //        {
                            //            siteInformation.ControlCode2 = int.Parse(cmdPart[1]);
                            //            break;
                            //        }
                            //case "ControlCode3":
                            //        {
                            //            siteInformation.ControlCode3 = int.Parse(cmdPart[1]);
                            //            break;
                            //        }
                            case "Comments":
                                {
                                    labelSiteComments.Text = cmdPart[1];
                                    break;
                                }
                            case "FirmwareVersion":
                                {
                                    try
                                    {
                                        for (int i = 1; i < cmdPart.Count(); i++)
                                        {
                                            labelFirmWare.Text += " " + cmdPart[i];
                                        }
                                    }
                                    catch
                                    {
                                    }
                                    break;
                                }
                            case "InstrumentSN":  //LPJ 2016-12-14
                                {
                                    labelInstrumentSN.Text = cmdPart[1];
                                    break;
                                }
                            case "SystemNumber":
                                {
                                    labelSystemNumber.Text = cmdPart[1];
                                    break;
                                }
                            //case "FlowReference": //LPJ 2013-7-24 cancel
                            //    {
                            //        if (int.Parse(cmdPart[1]) == 0)
                            //            labelFlowRef.Text = Resource1.String228;
                            //        else
                            //            labelFlowRef.Text = Resource1.String229;                                   
                            //        break;
                            //        //labelFlowRef.Text = cmdPart[1];
                            //    }
                            case "VesselSpeedReference":
                                {
                                    iVesselSpeedRef = int.Parse(cmdPart[1]);

                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelVesselRef.Text = Resource1.String232;
                                    else if (int.Parse(cmdPart[1]) == 1)
                                        labelVesselRef.Text = "GPS VTG";
                                    else if (int.Parse(cmdPart[1]) == 3)
                                        labelVesselRef.Text = "GPS GGA";
                                    else
                                        labelVesselRef.Text = Resource1.String233;
                                    break;
                                }
                            case "HeadingReference":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelHeadingRef.Text = Resource1.String230;
                                    else
                                        labelHeadingRef.Text = Resource1.String231;
                                    break;
                                }
                            case "Salinity":
                                {
                                    labelSalinity.Text = cmdPart[1];
                                    break;
                                }
                            case "HeadingOffset":
                                {
                                    label_Headingoffset.Text = cmdPart[1];
                                    fHeadingOffset = double.Parse(cmdPart[1]);
                                    break;
                                }
                            case "TransducerDepth":
                                {
                                    labelTransducerDepth.Text = cmdPart[1];
                                    break;
                                }
                            
                            case "TopMode":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelTopEstimate.Text = Resource1.String33;
                                    else if (int.Parse(cmdPart[1]) == 1)
                                        labelTopEstimate.Text = Resource1.String224;
                                    else
                                        labelTopEstimate.Text = Resource1.String225;
                                    break;

                                }
                            case "BottomMode":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelBottomEstimate.Text = Resource1.String33;
                                    else
                                        labelBottomEstimate.Text = Resource1.String224;
                                    break;
                                }
                            case "PowerCoff":
                                {
                                    labelPowerCurveCoeff.Text = cmdPart[1];
                                    break;
                                }
                            case "StartBank":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                    {
                                        labelStartEdge.Text = Resource1.String226;
                                        bStartLeftEdge = true;
                                    }
                                    else
                                    {
                                        labelStartEdge.Text = Resource1.String227;
                                        bStartLeftEdge = false;
                                    }
                                    break;
                                }
                            case "LeftBankDist":
                                {
                                    labelLeftDis.Text = cmdPart[1];
                                    break;
                                }
                            case "LeftBankStyle":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelLeftType.Text = Resource1.String221;
                                    else if (int.Parse(cmdPart[1]) == 1)
                                        labelLeftType.Text = Resource1.String222;
                                    else
                                        labelLeftType.Text = Resource1.String223;
                                    break;
                                }
                            case "LeftBankCoff":
                                {
                                    labelLeftRef.Text = cmdPart[1];
                                    labelLeftRef.Top = labelLeftType.Top;
                                    break;
                                }
                            case "LeftBankPings":
                                {
                                    dLeftShorePings = int.Parse(cmdPart[1]);
                                    break;
                                }
                            case "RightBankDist":
                                {
                                    labelRightDis.Text = cmdPart[1];
                                    break;
                                }
                            case "RightBankStyle":
                                {
                                    if (int.Parse(cmdPart[1]) == 0)
                                        labelRightType.Text = Resource1.String221;
                                    else if (int.Parse(cmdPart[1]) == 1)
                                        labelRightType.Text = Resource1.String222;
                                    else
                                        labelRightType.Text = Resource1.String223;
                                    break;
                                }
                            case "RightBankCoff":
                                {
                                    labelRightRef.Text = cmdPart[1];
                                    labelRightRef.Top = labelRightType.Top;
                                    break;
                                }
                            case "RightBankPings":
                                {
                                    dRightShorePings = int.Parse(cmdPart[1]);
                                    break;
                                }
                            case "CRSMODE":
                                {
                                    switch (int.Parse(cmdPart[1]))
                                    {
                                        case 0:
                                            labelMeasMode.Text = "OFF";
                                            break;
                                        case 1:
                                            labelMeasMode.Text = "Low Frequency";
                                            break;
                                        case 2:
                                            labelMeasMode.Text = "High Frequency";
                                            break;
                                        case 3:
                                            labelMeasMode.Text = "Auto Frequency";
                                            break;
                                    }
                                    break;
                                }
                            case "CRSSALINITY":
                                {
                                    fSalinity = float.Parse(cmdPart[1]);
                                    break;
                                }

                            default:
                                break;
                        }
                        cmd = sr.ReadLine();
                    }
                }
                catch
                {
                }

                LV_Measured_QPaint();  //LPJ 2013-8-22 更新流量汇总栏
                listView_Navigation_Paint(); //LPJ 2013-8-22
                listView_Others_Paint();  //LPJ 2013-8-22

                if (!bEnglish2Metric)   //LPJ 2013-8-22
                {
                    label3.Text = "(ft)";
                    label4.Text = "(ft)";
                    label5.Text = "(ft)";
                    label9.Text = "(ft)";
                }
                else
                {
                    label3.Text = "(m)";
                    label4.Text = "(m)";
                    label5.Text = "(m)";
                    label9.Text = "(m)";
                }
            }
            else
                return false;
            return true;

        }

        private void InitSmartPage()
        {
            bEnglish2Metric = true;
            labelUnit.Text = Resource1.String236;

            #region site information
            labelSiteName.Text = "Pan-Comm";
            /*
                                    siteInformation.siteName = cmdPart[1];
                               
                                    labelStationNumber.Text = cmdPart[1];
                                    siteInformation.stationNumber = cmdPart[1];
                               
                                    labelMeasNumber.Text = cmdPart[1];
                                    siteInformation.MeasNumber = cmdPart[1];
                               
                                    siteInformation.FieldParty = cmdPart[1];
                                 
                                    siteInformation.ProcessedBy = cmdPart[1];
                                 
                                    siteInformation.DeploymentType = int.Parse(cmdPart[1]);
                                
                                    siteInformation.BoatMotor = cmdPart[1];

                                    siteInformation.MeasLocation = cmdPart[1];
                               
                                    siteInformation.InsideGageH = cmdPart[1];
                              
                                    siteInformation.OutsideGageH = cmdPart[1];
                              
                                    siteInformation.GageHChange = cmdPart[1];
                           
                                    siteInformation.RatingDischarge = cmdPart[1];
                              
                                    siteInformation.IndexV = cmdPart[1];
                               
                                    siteInformation.RatingNumber = cmdPart[1];
                                
                                    siteInformation.RatedArea = cmdPart[1];
                               
                                    siteInformation.WaterTemp = cmdPart[1];
                               
                                    siteInformation.MagnVariationMethod = int.Parse(cmdPart[1]);
                                  
                                    siteInformation.MeasurementRating = int.Parse(cmdPart[1]);
                                
                                    labelSiteComments.Text = cmdPart[1];
                              */
            #endregion

            labelVesselRef.Text = "Bottom Tracking";// Resource1.String232;
            labelHeadingRef.Text = Resource1.String230;
            fHeadingOffset = 0;
            labelSalinity.Text = "0";
            label_Headingoffset.Text = "0";
            labelTransducerDepth.Text = "0.0";
            labelMeasMode.Text = "Auto Frequency";// Resource1.String234;
            labelTopEstimate.Text = Resource1.String33;
            labelBottomEstimate.Text = Resource1.String33;
            labelPowerCurveCoeff.Text = "0.1667";
            labelStartEdge.Text = Resource1.String226;
            bStartLeftEdge = true;
            labelLeftDis.Text = "0";
            labelLeftType.Text = Resource1.String221;
            labelLeftRef.Text = "";
            dLeftShorePings = 10;
            labelRightDis.Text = "0";
            labelRightType.Text = Resource1.String221;
            labelRightRef.Text = "";
            dRightShorePings = 10;
            BlankSize = 0.0f;
            fSalinity = 0;
        }

        private void linkLabelGPSConf_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            //配置GPS
            FrmSetGPSConnect gpsConnect = new FrmSetGPSConnect();
            if (DialogResult.OK == gpsConnect.ShowDialog())
            {
                GPS_sp.PortName = gpsConnect.GPSsp.PortName;
                GPS_sp.BaudRate = gpsConnect.GPSsp.BaudRate;
                if (GPS_sp.IsOpen)
                {
                    bGPSConnect = false;
                    MessageBox.Show(Resource1.String42);
                }
                else
                {
                    bGPSConnect = true;
                    //GPS_sp.Open();
                }
            }
            else
            {
                bGPSConnect = false;
            }
        }

        private void DP300_Windows_Resize(object sender, EventArgs e)
        {
            ResizeControls(); //LPJ 2013-6-24
        }
        private void ResizeControls() //LPJ 2013-6-24 根据屏幕大小，设置控件位置及大小
        {
            int MainWidth = this.Width - tabControlFuTu.Width-10;
            int MainHeight = this.Height * 3 / 4;

            tabControl4.Height = this.Height; //LPJ 2017-3-3

            labelMainPanelFigure.Location = new Point(MainWidth / 2 - labelMainPanelFigure.Width / 2, 2);
            label3.Location = new Point(20,1);

            panel17.Width = this.Width - panel34.Width;
            panel17.Height = this.Height;

            panel23.Width = this.Width - panel34.Width;
            panel23.Height = this.Height;


            panel20.Height = this.Height - 20;
            tabControlFuTu.Height = this.Height - 20;

            panelFlowPix.Height =MainHeight;
            panelFlowPix.Width = MainWidth;
            panelFlowPix.Location = new Point(0, 0);
            panel21.Height = panelFlowPix.Height-1;
            panel21.Width = panelFlowPix.Width-1;
            panel21.Location = new Point(0, 0);

            MainPanel.Height = (MainHeight - 35) / 2;
            MainPanel.Width = MainWidth-10;
            MainPanel.Location = new Point(10, 20);

            panelGPSTrack.Height = (MainHeight - 35) / 2;
            panelGPSTrack.Width = MainWidth-10;
            panelGPSTrack.Location = new Point(10, 22 + (MainHeight - 35) / 2);
            panel16.Location = new Point(40, MainPanel.Height - panel16.Height - 5);
            // label8.Location = new Point(50, panelGPSTrack.Height - 30); //LPJ 2013-6-26
            label8.Visible = false; //LPJ 2013-6-26

            HPRDisplayerPanel.Location =new Point(0, MainHeight);
            panel1.Width = this.Width - tabControlFuTu.Width - HPRDisplayerPanel.Width - 90;
            panel1.Location = new Point(HPRDisplayerPanel.Width + 5, MainHeight + 2);
            btnSpeedFast.Location = new Point(HPRDisplayerPanel.Width + 5 + panel1.Width + btnSpeedSlow.Width + 2, MainHeight + 2);
            btnSpeedSlow.Location = new Point(HPRDisplayerPanel.Width + 5 + panel1.Width, MainHeight + 2);

            panel18.Location = new Point(HPRDisplayerPanel.Width + 5, MainHeight + panel1.Height + 2);
            //if (playBackMode)
            //    panel18.Height = this.Height / 4 - 20 - panel1.Height;
            //else
            panel18.Height = this.Height / 4 - 30 - panel1.Height;
            panel18.Width = this.Width - tabControlFuTu.Width - HPRDisplayerPanel.Width - 17;
            tabControl11.Height = panel18.Height - 1;
            tabControl11.Width = panel18.Width - 1;
            listView_Summary.Height = panel18.Height - 25;
            listView_Summary.Width = panel18.Width - 8;

            int iHeight = 180;
            lV_MeasuredQ.Height = iHeight;
            lV_MeasuredQ.Width = tabPage43.Width;
            lV_MeasuredQ.Location = new Point(0, 0);
            listView_Navigation.Height = (tabControlFuTu.Height - iHeight-10) / 2;
            listView_Navigation.Width = tabPage43.Width;
            listView_Navigation.Location = new Point(0, lV_MeasuredQ.Height - 1);
            listView_Others.Height = tabControlFuTu.Height - iHeight - (tabControlFuTu.Height - iHeight-10) / 2 - 25;
            listView_Others.Width = tabPage43.Width;
            listView_Others.Location = new Point(0, iHeight + (tabControlFuTu.Height - iHeight-10) / 2 - 1);

            lV_MeasuredQ.Columns[0].Width = 110;
            lV_MeasuredQ.Columns[1].Width = lV_MeasuredQ.Width - 120;
            listView_Navigation.Columns[0].Width = 100;
            listView_Navigation.Columns[1].Width = listView_Navigation.Width - 110;
            listView_Others.Columns[0].Width = 100;
            listView_Others.Columns[1].Width = listView_Others.Width - 110;

            tabControl_FuTu_WP.Location = new Point(0, 0); //LPJ 2013-11-19
            panel22.Location = new Point(0, 15);   //LPJ 2013-11-19
            panel24.Location = new Point(0, 15);    //LPJ 2013-11-19

            panel22.Height = tabControlFuTu.Height - 200;
            panel24.Height = tabControlFuTu.Height - 200;

            panel_W_A.Height = panel22.Height-5;
            panel_W_C.Height = panel22.Height-5;
            //panel_W_A.Width = 23;
            //panel_W_C.Width = 23;
            //pictureBox_W_A.Location = new Point(23, 0);
            //pictureBox_W_C.Location = new Point(23, 0);
            pictureBox_W_A.Width = panel22.Width - panel_W_A.Width - 5;
            pictureBox_W_A.Height = panel22.Height-5;
            pictureBox_W_C.Width = panel22.Width - panel_W_C.Width - 5;
            pictureBox_W_C.Height = panel22.Height-5;
            label120.Location = new Point(6, panel22.Height + 15);
            label113.Location = label120.Location;
            checkBox_WA_b0.Location = new Point(20, panel22.Height + 15 + 20);
            checkBox_WA_b1.Location = new Point(90, panel22.Height + 15 + 20);
            checkBox_WA_b2.Location = new Point(20, panel22.Height + 15 + 40);
            checkBox_WA_b3.Location = new Point(90, panel22.Height + 15 + 40);
            checkBox_WC_b0.Location = new Point(20, panel22.Height + 15 + 20);
            checkBox_WC_b1.Location = new Point(90, panel22.Height + 15 + 20);
            checkBox_WC_b2.Location = new Point(20, panel22.Height + 15 + 40);
            checkBox_WC_b3.Location = new Point(90, panel22.Height + 15 + 40);
            groupBox29.Location = new Point(0, panel22.Height + 80);
            groupBox30.Location = new Point(tabControlFuTu.Width / 2, panel22.Height + 80);
            groupBox19.Location = new Point(0, panel22.Height + 80);
            groupBox18.Location = new Point(tabControlFuTu.Width / 2, panel22.Height + 80);

            panel15.Location = new Point(panelGPSTrack.Width - panel15.Width - 5, panelGPSTrack.Height - panel15.Height - 2);

            //GPSdisplayPanel.Height = (int)(tabPageTrack.Height * 0.9f);
            //GPSdepthPanel.Height = tabPageTrack.Height - GPSdisplayPanel.Height;
            //GPSdepthPanel.Location = new Point(0, GPSdisplayPanel.Height);
            #region data
            panel7.Width = this.Width / 4;
            panel7.Height = this.Height - 35;
            //panel8.Width = panel7.Width - 5;
            //tabControl8.Width = panel7.Width - 5;
            //panel19.Width = panel7.Width - 5;
            
            panel6.Width = this.Width - panel7.Width - 20;
            panel6.Location = new Point(panel7.Width + 15, 5);
            tabControl2.Width = this.Width - panel7.Width - 25;

            panel2.Width = (panel6.Width - 20) / 2;
            panel2.Height = (this.Height - panel6.Height - 50) / 2;
            panel2.Location = new Point(panel7.Width + 15, panel6.Height + 5);
            tabControl3.Width = panel2.Width;
            tabControl3.Height = panel2.Height - label55.Height - 5;

            panel5.Width = panel2.Width;
            panel5.Height = panel2.Height;
            panel5.Location = new Point(panel2.Location.X + panel2.Width + 10, panel5.Location.Y);
            tabControl7.Width = tabControl3.Width;
            tabControl7.Height = tabControl3.Height;
        
            panel4.Width = panel2.Width;
            panel4.Height = panel2.Height;
            panel4.Location = new Point(panel2.Location.X, panel2.Location.Y + panel2.Height + 10);
            tabControl5.Width = tabControl3.Width;
            tabControl5.Height = tabControl3.Height;
           
            panel3.Width = panel2.Width;
            panel3.Height = panel2.Height;
            panel3.Location = new Point(panel5.Location.X,panel4.Location.Y);
            tabControl6.Width = tabControl3.Width;
            tabControl6.Height = tabControl3.Height;
            #endregion

            #region smart page
            panel17.Height = this.Height - 30;
            //panel23.Height = this.Height + 30;
            panel17.Width = this.Width * 3 / 4;
            //panel23.Width = this.Width;
            panel34.Width = this.Width - panel17.Width;
            textBoxHelpTips.Width = panel34.Width;
            panel34.Height = this.Height;
            textBoxHelpTips.Height = panel34.Height;
            panel34.Location = new Point(this.Width * 3 / 4, 0);
            textBoxHelpTips.Location = new Point(0, 0);

            //system setting

            if (Form1.bSurveyMode)
            {
                label261.Location = new Point(13, 5);
                label260.Location = new Point(13, 22);
                label18.Location = new Point(13, 40);
                label259.Location = new Point(13, 59);
                linkLabelGPSConf.Location = new Point(13, 79);
                linkLabelCompassCalibration.Location = new Point(13, 98);

                labelSN.Location = new Point(204, 5);
                labelFirmWare.Location = new Point(204, 22);
                labelInstrumentSN.Location = new Point(204, 40);
                labelSystemNumber.Location = new Point(204, 59);
                //labelSystemNumber.Location = new Point(label259.Left + label259.Width, 59);
                linkLabelSettingTime.Location = new Point(204, 79);
            }
            else
            {
                label261.Location = new Point(13, 5);
                label260.Location = new Point(13, 30);
                label18.Location = new Point(13, 55);
                label259.Location = new Point(13, 80);
                linkLabelGPSConf.Location = new Point(13, 100);
                linkLabelCompassCalibration.Location = new Point(13, 101);

                labelSN.Location = new Point(204, 5);
                labelFirmWare.Location = new Point(204, 30);
                labelInstrumentSN.Location = new Point(204, 55);
                labelSystemNumber.Location = new Point(204, 80);
                //labelSystemNumber.Location = new Point(label259.Left + label259.Width, 80);
                linkLabelSettingTime.Location = new Point(204, 100);
            }

            #endregion

            panelSerialTime.Location = new Point(0, 0); //LPJ 2013-9-22
            //panelSerialTime.Height = tabPageSerialTime.Height; //LPJ 2013-9-22
            panelSerialTime.Height = this.Height-20; //LPJ 2013-9-22
            panelSerialTime.Width = tabPageSerialTime.Width; //LPJ 2013-9-22

            ResizeListViewSummaryWidth(); //LPJ 2014-8-7
           
        }

        private void ResizeListViewSummaryWidth()
        {
            int widthSummary = listView_Summary.Width / 17;
            for (int i = 0; i < 17; i++)
            {
                listView_Summary.Columns[i].Width = widthSummary;
            }
        }

        //private bool bUsePCTime = false;
        //private string strTime = null; //LPJ 2013-10-30 当仪器发送“STIME”后，从仪器读取时间
        private void linkLabelSettingTime_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            //strTime = "";
            #region cancel
            //try
            //{
            //    //LPJ 2013-10-30 获取仪器时间
            //    sp.Write("STIME" + '\r');
            //    Thread.Sleep(300);

            //    //设置时间
            //    //FrmSetTime setTime = new FrmSetTime(strTime);
            //    lock (l)
            //    {
            //        FrmSetTime setTime = new FrmSetTime(ReceiveBufferString);
            //        if (DialogResult.OK == setTime.ShowDialog())
            //        {
            //            if (!setTime.bUsePCTime)
            //            {
            //                sp.Write("STIME " + setTime.strDateTime + '\r'); //将设置的时间发送到仪器
            //                Thread.Sleep(2000);
            //                bUsePCTime = false;
            //            }
            //            else
            //            {
            //                sp.Write("STIME " + DateTime.Now.Year.ToString("0000") + "/" + DateTime.Now.Month.ToString("00") + "/" + DateTime.Now.Day.ToString("00") + "," +
            //                                  DateTime.Now.Hour.ToString("00") + ":" + DateTime.Now.Minute.ToString("00") + ":" + DateTime.Now.Second.ToString("00") + '\r'); //LPJ 2017-1-3 将电脑时间发送到仪器
            //                Thread.Sleep(2000);
            //                bUsePCTime = true;
            //            }
            //        }
            //    }
            //}
            //catch
            //{
            //}
            #endregion

            sp.Close();
            FrmSetTime setTime = new FrmSetTime(sp);
            if (DialogResult.OK == setTime.ShowDialog())
            {
            }
            sp.Open();
        }

        private void linkLabelCompassCalibration_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            //罗盘校准
        }

        private void linkLabelSystemTest_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                //系统测试
                FrmSystemTest frmsystemtest = new FrmSystemTest();
                if (frmsystemtest.ShowDialog() == DialogResult.OK)
                {
                    FrmProgressBar frmBar = new FrmProgressBar(0, 100);
                    frmBar.Show();

                    string strResult = "";

                    #region compass
                    sp.Write("ENGPNI" + '\r');
                    Thread.Sleep(150);

                    // Decode the result
                    lock (l)
                    {
                        CAdcpCommands.HPR hpr = CAdcpCommands.DecodeEngPniResult(ReceiveBufferString);

                        // Check if all the values are 0
                        if (hpr.Heading == 0 && hpr.Pitch == 0 && hpr.Roll == 0)
                        {
                            strResult += Resource1.String288 + "\r\n";
                        }
                        else
                        {
                            strResult += "Heading (Degrees): " + hpr.Heading.ToString() + "\r\n";
                            strResult += "Pitch (Degrees): " + hpr.Pitch.ToString() + "\r\n";
                            strResult += "Roll (Degrees): " + hpr.Roll.ToString() + "\r\n";
                        }
                    }
                    #endregion

                    frmBar.setPos(20);

                    #region SD card
                    sp.Write("DSSHOW" + '\r');
                    Thread.Sleep(150);

                    //Decode
                    lock (l)
                    {
                        CAdcpCommands.AdcpDirListing dirlisting = CAdcpCommands.DecodeDSDIR(ReceiveBufferString);

                        //check if the memory is 0 
                        strResult += Resource1.String289 + dirlisting.TotalSpace.ToString() + "MB\r\n";
                        strResult += Resource1.String290 + dirlisting.UsedSpace.ToString() + "MB\r\n";

                        if (dirlisting.TotalSpace - dirlisting.UsedSpace == 0)
                        {
                            strResult += Resource1.String291 + "\r\n";
                        }
                    }
                    #endregion

                    frmBar.setPos(40);

                    #region firmware version
                    sp.Write("FMSHOW" + '\r');
                    Thread.Sleep(300);
                    string firmware;
                    lock (l)
                    {
                        firmware = CAdcpCommands.DecodeFMSHOW(ReceiveBufferString);
                    }
                    #endregion

                    frmBar.setPos(60);

                    #region batteries
                    sp.Write("ENGSAMP" + '\r');
                    Thread.Sleep(8000);

                    lock (l)
                    {
                        CAdcpCommands.samp samp = CAdcpCommands.DecodeENGSAMP(ReceiveBufferString);
                        strResult += Resource1.String292 + samp.Battery.ToString() + " Volts." + "\r\n";

                    #endregion

                        frmBar.setPos(80);

                        #region temperature sensor
                        strResult += Resource1.String293 + samp.Temperature.ToString() + " degrees." + "\r\n";
                        if (samp.Temperature < -30 || samp.Temperature > 70)
                        {
                            strResult += Resource1.String294 + "\r\n";
                        }
                    }
                    #endregion

                    frmBar.setPos(100);
                    frmBar.Close();

                    //show result
                    MessageBox.Show(strResult, Resource1.String295);

                    #region save to file
                    DateTime date = DateTime.Now;
                    string strFile = "\r\n";
                    strFile += date.ToString() + "\r\n";
                    strFile += firmware + "\r\n\r\n";
                    strFile += "System Test: \r\n";
                    strFile += strResult + "\r\n";

                    try
                    {
                        File.AppendAllText(System.IO.Path.Combine(Directory.GetCurrentDirectory(), "dp300Data") + "\\SystemTest.txt", strFile);
                    }
                    catch
                    {
                        File.AppendAllText(Directory.GetCurrentDirectory() + "\\SystemTest.txt", strFile);
                    }
                    #endregion

                }
            }
            catch
            {
            }
        }

        private void linkLabelUpdateFirmware_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            { //固件升级
                OpenFileDialog file = new OpenFileDialog();
                file.InitialDirectory = Directory.GetCurrentDirectory();
                file.Filter = "BIN(*.bin)|*.bin|All Doucement(*.*)|*.*";
                file.Title = "Open File:";

                if (file.ShowDialog() == DialogResult.OK)
                {
                    string strPath = file.FileName;

                    RTI.SerialOptions serial = new RTI.SerialOptions();

                    serial.Port = sp.PortName;
                    serial.BaudRate = sp.BaudRate;

                    if (sp.IsOpen)
                    {
                        sp.Close();
                        sp.Dispose();
                    }

                    RTI.AdcpSerialPort adcpsp = new RTI.AdcpSerialPort(serial);

                    FrmUpLoad frmUpload = new FrmUpLoad(adcpsp, strPath);
                    frmUpload.ShowDialog();

                    Thread.Sleep(150);

                    sp = new SerialPort();
                    
                    /*
                    sp.ReadBufferSize = 16 * 65536;
                    sp.BaudRate = 115200;
                    sp.StopBits = StopBits.One;
                    sp.Parity = Parity.None;
                    sp.DataBits = 8;
                    sp.Handshake = Handshake.None;//_serialPort.Handshake = Handshake.RequestToSend;
                    sp.DtrEnable = true;
                    //Set the read/write timeouts
                    sp.ReadTimeout = 50;
                    sp.WriteTimeout = 500;
                    */

                    sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);

                    sp.PortName = serial.Port;
                    sp.BaudRate = serial.BaudRate;
                    if (!sp.IsOpen)
                        sp.Open();

                }
            }
            catch
            {
            }
        }


        #region 以下部分为拖动图示图例框
        private void MouseDown_Clicked(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                //pntPanelTrackLabel = this.panel16.Location;
                bDragMainPanel = true;
                DragStartPntMainPanel = e.Location;
                this.Cursor = Cursors.Hand;
            }
        }
        private void MouseMove_Clicked(object sender, MouseEventArgs e)
        {
            if (bDragMainPanel && e.Button == MouseButtons.Left)
            {
                PointF DragEndPntMainPanel = e.Location;
                float DragLengthX_MainPanel = 0, DragLengthY_MainPanel = 0;
                DragLengthX_MainPanel = DragEndPntMainPanel.X - DragStartPntMainPanel.X;
                DragLengthY_MainPanel = DragEndPntMainPanel.Y - DragStartPntMainPanel.Y;

                this.panel16.Location = new Point((int)(panel16.Location.X + DragLengthX_MainPanel), (int)(panel16.Location.Y + DragLengthY_MainPanel));
            }
        }
        private void MouseUp_Clicked(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                bDragMainPanel = false;
                this.Cursor = Cursors.Default;
            }
        }
        #endregion

        private void tabPageSerialTime_Paint(object sender, PaintEventArgs e) //LPJ 2013-9-16 增加页面用于显示船速、流向、Pitch、Roll等信息
        {
           
        }

        private  List<double> dBoatSpeed = new List<double>();
        private List<double> dWaterDir = new List<double>();
        private List<double> dPitch = new List<double>();
        private List<double> dRoll = new List<double>();
        private List<double> dWater_Boat = new List<double>();

        private void panelSerialTime_Paint(object sender, PaintEventArgs e)  //LPJ 2013-9-16 增加页面用于显示船速、流向、Pitch、Roll等信息
        {
            BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
            BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, this.panelSerialTime.DisplayRectangle);

            Graphics g = MainBuffer.Graphics;
            g.FillRectangle(Brushes.White, 0, 0, panelSerialTime.Width, panelSerialTime.Height); 

            #region paint
           
            dBoatSpeed.Clear();
            dWaterDir.Clear();
            dPitch.Clear();
            dRoll.Clear();
            dWater_Boat.Clear();
          
            double boatSpeed;
            double waterDir;
            float pitch, roll;
            double water_Boat;

            try
            {
                for (int i = 0; i < BinDataEnsembleNum; i++)
                {
                    try
                    {
                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-11-21 当船速参考GPS时，显示GPS船速
                        {
                            Velocity boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPS[i];
                            boatSpeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                        }
                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-11-21 当船速参考GPS时，显示GPS船速
                        {
                            Velocity boatV = (Velocity)EnsemblesInfoToStore.BoatV_GPGGA[i];
                            boatSpeed = Math.Sqrt(Math.Pow(boatV.VX, 2) + Math.Pow(boatV.VY, 2));
                        }
                        else if (Resource1.String233 == labelVesselRef.Text)
                        {
                            boatSpeed = 0;
                        }
                        else
                            boatSpeed = (double)EnsemblesInfoToStore.BoatSpeed[i];
                        dBoatSpeed.Add(boatSpeed);

                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-11-21
                            waterDir = (double)EnsemblesInfoToStore.WaterDir_GPS[i];
                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-11-21
                            waterDir = (double)EnsemblesInfoToStore.WaterDir_GPGGA[i];
                        else if (Resource1.String233 == labelVesselRef.Text)
                            waterDir = (double)EnsemblesInfoToStore.WaterDir_Null[i];
                        else
                            waterDir = (double)EnsemblesInfoToStore.WaterDir[i];
                        dWaterDir.Add(waterDir);
                        if (!playBackMode)
                        {
                            pitch = (float)EnsemblesInfoToStore.Pitch[i];
                            roll = (float)EnsemblesInfoToStore.Roll[i];
                        }
                        else
                        {
                            pitch = (float)RTIdata[i].A_Pitch;
                            roll = (float)RTIdata[i].A_Roll;
                        }

                        if (roll > 0)
                            roll = 180 - roll;
                        else
                            roll = -180 - roll;

                        dPitch.Add((double)pitch);
                        dRoll.Add((double)roll);

                        if ("GPS VTG" == labelVesselRef.Text) //LPJ 2013-11-21
                            water_Boat = (double)EnsemblesInfoToStore.BoatWater_GPS[i];
                        else if ("GPS GGA" == labelVesselRef.Text) //LPJ 2013-11-21
                            water_Boat = (double)EnsemblesInfoToStore.BoatWater_GPGGA[i];
                        else if (Resource1.String233 == labelVesselRef.Text)
                            water_Boat = 0;
                        else
                            water_Boat = (double)EnsemblesInfoToStore.BoatWater[i];
                        dWater_Boat.Add(water_Boat);
                    }
                    catch//(Exception ex)
                    {
                        //MessageBox.Show(ex.Message);
                    }
                }

                float fDistanceMG = 0;
                try
                {
                    fDistanceMG = float.Parse(current_Length); //LPJ 2013-9-23 该变量用于记录当前航迹长度
                }
                catch
                {
                    fDistanceMG = 0;
                }

                string strSpeed = "";
                string strDis = "";
                if (!bEnglish2Metric)
                {
                    strSpeed = "(ft/s)";
                    strDis = "(ft)";
                }
                else
                {
                    strSpeed = "(m/s)";
                    strDis = "(m)";
                }

                ClassDrawSerialTime serialTime = new ClassDrawSerialTime();
                //船速
                Rectangle rect_BoatSpeed = new Rectangle(panelSerialTime.DisplayRectangle.X,
                                   panelSerialTime.DisplayRectangle.Y, panelSerialTime.Width, panelSerialTime.Height / 5 + 1);
                serialTime.OnDrawBoatSpeed(e.Graphics, rect_BoatSpeed, dBoatSpeed, Resource1.String100 + strSpeed, 20, Color.Blue, fDistanceMG, strDis);

                //水流方向
                Rectangle rect_WaterDir = new Rectangle(panelSerialTime.DisplayRectangle.X,
                    rect_BoatSpeed.Bottom - 1, panelSerialTime.Width, panelSerialTime.Height / 5 + 1);
                serialTime.OnDrawWaterDirect(e.Graphics, rect_WaterDir, dWaterDir, Color.Green, Resource1.String103 + Resource1.String270, fDistanceMG, strDis);

                //Pitch值
                Rectangle rect_Pitch = new Rectangle(panelSerialTime.DisplayRectangle.X,
                                  rect_WaterDir.Bottom - 1, panelSerialTime.Width, tabPageSerialTime.Height / 5 + 1);
                serialTime.OnDrawAttitude(e.Graphics, rect_Pitch, dPitch, Color.Purple, Resource1.String119 + Resource1.String270, fDistanceMG, strDis);

                //Roll值
                Rectangle rect_Roll = new Rectangle(panelSerialTime.DisplayRectangle.X,
                    rect_Pitch.Bottom - 1, panelSerialTime.Width, panelSerialTime.Height / 5 + 1);
                serialTime.OnDrawAttitude(e.Graphics, rect_Roll, dRoll, Color.Magenta, Resource1.String120 + Resource1.String270, fDistanceMG, strDis);

                //流速船速比值
                Rectangle rect_BoatWater = new Rectangle(panelSerialTime.DisplayRectangle.X,
                    rect_Roll.Bottom - 1, panelSerialTime.Width, panelSerialTime.Height / 5 + 1);
                serialTime.OnDrawBoatWater(e.Graphics, rect_BoatWater, dWater_Boat, Color.DarkOrange, Resource1.String271, fDistanceMG, strDis);

            }
            catch(Exception ex)
            {
                MessageBox.Show(ex.Message);
            } 
            #endregion

        }

        private void PrivatePaintRefreshEvent()
        {
            tabPage_BoatSpeed.Refresh(); //LPJ 2013-5-18
            tabPage_WaterDirection.Refresh(); //LPJ 2013-5-18
            tabPage_Pitch.Refresh(); //LPJ 2013-5-18
            tabPage_Roll.Refresh();  //LPJ 2013-5-18
            tabPage_BoatWater.Refresh();  //LPJ 2013-5-18

            //if (playBackMode)
            panelSerialTime.Refresh();

            GPSdisplayPanel.Refresh(); //2017-5-31
        }

        //private bool bGPSCalibrationStartBtn = false; //LPJ 2013-11-15 添加变量控制按钮的操作
        //private void btnGPSCalibration_Click(object sender, EventArgs e) //LPJ 2013-11-15
        //{
        //    bGPSCalibrationStartBtn = !bGPSCalibrationStartBtn;

        //    if (bGPSCalibrationStartBtn)
        //    {
        //        if (btnGPSCalibration_Start())
        //        {
        //            btnGPSCalibration.Text = "Stop";
        //        }
        //        else
        //        {
        //            MessageBox.Show("GPS Calibration failed");
        //            btnGPSCalibration.Text = "Start";
        //        }
        //    }
        //    else
        //    {
        //        if (btnGPSCalibration_Stop())
        //            btnGPSCalibration.Text = "Start";
        //        else
        //        {
        //            btnGPSCalibration.Text = "Stop";
        //        }
        //    }
        //}

        private void linkLabelHeadingOffset_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e) //LPJ 2013-11-18 计算艏向偏差角
        {
            FrmGetHeadingOffset frmHeadingOffset = new FrmGetHeadingOffset(sp);

            if (frmHeadingOffset.ShowDialog() == DialogResult.OK)
            {
                fHeadingOffset = frmHeadingOffset.fHeadingOffset;
            }
        }

        #region delegate
        private delegate void PaintRefreshEventHandler();
        PaintRefreshEventHandler PaintRefreshEvent;

        private delegate void WriteToDataPageEventHandler(ArrayClass arr);
        WriteToDataPageEventHandler WriteToDataPageEvent;

        #endregion

        List<ArrayClass> ArrRaw = new List<ArrayClass>(); //设置一个全局变量ArrRaw，用于存储解析的ArrayClass数据
        bool bBeamCheck = false; //
       
        private void linkLabelBeamCheck_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                bBeamCheck = true;
                ArrRaw.Clear();

                sp.Write("START" + '\r'); //发送Start
                Thread.Sleep(150);

                StartRecord = true;

                RealTimeProcessingTimer = new System.Timers.Timer();
                RealTimeProcessingTimer.Elapsed += new System.Timers.ElapsedEventHandler(RealTimeProcessingTimer_Elapsed);
                RealTimeProcessingTimer.Interval = iRealTimeInterval;
                RealTimeProcessingTimer.Start();

                beamCheckTimer = new System.Timers.Timer();
                beamCheckTimer.Elapsed += new System.Timers.ElapsedEventHandler(beamCheckTimer_Elapsed);
                beamCheckTimer.Interval = 5 * iRealTimeInterval;
                beamCheckTimer.Start();

                #region 
                //float range = 0;
                //int cells = 200;
                //float[,] snr = new float[4, 200];

                //while (ArrRaw.Count() < 1)
                //{
                //    Thread.Sleep(150);
                //}
                //int i = ArrRaw.Count() - 1;
                //range = ArrRaw[i].B_Depth;
                //cells = (int)ArrRaw[i].E_Cells;
                //snr = ArrRaw[i].Amplitude;
               
                //FrmBeamCheck frmbeamcheck = new FrmBeamCheck(range, cells, snr);
                //frmbeamcheck.ShowDialog();

                //StartRecord = false;
                //RealTimeProcessingTimer.Stop();

                //sp.Write("STOP" + '\r'); //发送Stop
                //Thread.Sleep(150);

                //while (!ReceiveBufferString.Contains("STOP"))
                //{
                //    sp.Write("STOP" + '\r');
                //    Thread.Sleep(150);
                //}

                //bBeamCheck = false;
                //ArrRaw.Clear();
                #endregion
            }
            catch
            {
            }
        }

        System.Timers.Timer beamCheckTimer;
        private void beamCheckTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            if (ArrRaw.Count() > 0)
            {
                //beamCheckTimer.Stop();
                StopBeamCheck();
            }
        }

        private void StopBeamCheck()
        {
            float range = 0;
            int cells = 200;
            float[,] snr = new float[4, 200];

            if (ArrRaw.Count() > 0)
            {
                try
                {
                    int i = ArrRaw.Count() - 1;
                    //range = ArrRaw[i].B_Depth;
                    cells = (int)ArrRaw[i].E_Cells;
                    range = cells * ArrRaw[i].A_CellSize;
                    snr = ArrRaw[i].Amplitude;
                }
                catch
                {
                }
            }

            StartRecord = false;
            RealTimeProcessingTimer.Stop();

            sp.Write("STOP" + '\r'); //发送Stop
            Thread.Sleep(150);

            while (!ReceiveBufferString.Contains("STOP"))
            {
                sp.Write("STOP" + '\r');
                Thread.Sleep(150);
            }

            beamCheckTimer.Stop();
            bBeamCheck = false; 
            ArrRaw.Clear();

            FrmBeamCheck frmbeamcheck = new FrmBeamCheck(range, cells, snr);
            frmbeamcheck.ShowDialog();

        }

        private void linkLabelDownload_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                RTI.SerialOptions serial = new RTI.SerialOptions();

                serial.Port = sp.PortName;
                serial.BaudRate = sp.BaudRate;

                if (sp.IsOpen)
                {
                    sp.Close();
                    sp.Dispose();
                }

                RTI.AdcpSerialPort adcpsp = new RTI.AdcpSerialPort(serial);
                FrmDownload frmDownload = new FrmDownload(adcpsp);
                if (DialogResult.OK == frmDownload.ShowDialog())
                {
                    MessageBox.Show("Download Finish");
                }

                sp = new SerialPort();

                /*
                sp.ReadBufferSize = 16 * 65536;
                sp.BaudRate = 115200;
                sp.StopBits = StopBits.One;
                sp.Parity = Parity.None;
                sp.DataBits = 8;
                sp.Handshake = Handshake.None;//_serialPort.Handshake = Handshake.RequestToSend;
                sp.DtrEnable = true;
                //Set the read/write timeouts
                sp.ReadTimeout = 50;
                sp.WriteTimeout = 500;
                */

                sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);
                sp.PortName = serial.Port;
                sp.BaudRate = serial.BaudRate;
                if (!sp.IsOpen)
                    sp.Open();
            }
            catch
            {
            }
        }

        private void btnScaleIncrease_Click(object sender, EventArgs e)
        {
            AverageScale += 5;
            if (AverageScale > 5000)
                AverageScale = 5000;
            
            panelGPSTrack.Refresh();
        }

        private void btnScaleDecrease_Click(object sender, EventArgs e)
        {
            AverageScale -= 5;
            if (AverageScale < 1)
                AverageScale = 1;

            panelGPSTrack.Refresh();
        }

        #region 航迹鼠标右键功能
        private bool bBottomTrack = true;  //LPJ 2016-10-21
        private bool bGPSVTGTrack = false;
        private bool bGPSGGATrack = false;

        
        private void BTToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BTToolStripMenuItem.Checked = !bBottomTrack;

            if (BTToolStripMenuItem.Checked)
                bBottomTrack = true;
            else
                bBottomTrack = false;

            panelGPSTrack.Refresh();
        }

        private void GPSVTGToolStripMenuItem_Click(object sender, EventArgs e)
        {
            GPSVTGToolStripMenuItem.Checked = !bGPSVTGTrack;

            if (GPSVTGToolStripMenuItem.Checked)
                bGPSVTGTrack = true;
            else
                bGPSVTGTrack = false;

            panelGPSTrack.Refresh();
        }

        private void GPSGGAToolStripMenuItem_Click(object sender, EventArgs e)
        {
            GPSGGAToolStripMenuItem.Checked = !bGPSGGATrack;

            if (GPSGGAToolStripMenuItem.Checked)
                bGPSGGATrack = true;
            else
                bGPSGGATrack = false;

            panelGPSTrack.Refresh();
        }

        #endregion

        #region Amplitude & BackScatter Display. -RMa 11/19/2020
        private int MaxDataBuff = 1400000 - 1;
        private byte[] aBuff = new byte[1400000];
        private byte[] bBuff = new byte[1400000];
        private byte[] cBuff = new byte[1400000];
        private byte[] DataBuff = new byte[1400000];

        private int DataBuffReadIndex = 0;
        private int DataBuffWriteIndex = 0;

        List<BackScatter.EnsembleClass> ensembles = new List<BackScatter.EnsembleClass>(); 

        #region BackScatter. -RMa 12/01/2020
        int TheBSbeam = 0;
        private void textBoxBSbeam_TextChanged(object sender, EventArgs e)
        {
            try
            {
                TheBSbeam = Convert.ToInt32(textBoxBSbeam.Text);
                //textBoxBSprofile.Text = BackScatter.GetBsProfileString(TheBSbeam, BackScatter.Ensemble);
                tbs[0].Text = BackScatter.GetBsProfileString(TheBSbeam, BackScatter.Ensemble);
            }
            catch { }
        }

        private void radioButtonBSsystem_CheckedChanged(object sender, EventArgs e)
        {
            textBoxBSsystem.BringToFront();
        }

        private void radioButtonBSdata_CheckedChanged(object sender, EventArgs e)
        {
            textBoxBSdata.BringToFront();
        }

        private void radioButtonBSleaders_CheckedChanged(object sender, EventArgs e)
        {
            textBoxBSleaders.BringToFront();
        }

        private void radioButtonBSprofile_CheckedChanged(object sender, EventArgs e)
        {
            panel_BSProfile.BringToFront();

            #region Create 10 beam textboxes
            //Create 10 beam textboxes
            int X = panel_BSProfile.Location.X;
            int Y = panel_BSProfile.Location.Y;

            //the first row of beam textBoxs
            for (int i = 0; i < n / 2; i++)
            {
                var txt = new TextBox();
                tbs[i] = txt;
                txt.Name = "Beam" + i;
                txt.Text = "Beam" + i;
                txt.Location = new Point(X + (i * 250) - 100 + i * 10, Y);
                txt.Size = new System.Drawing.Size(250, 327);
                txt.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top)
                                | System.Windows.Forms.AnchorStyles.Left))));
                txt.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
                txt.Font = new System.Drawing.Font("Courier New", 8.25F);
                txt.Multiline = true;
                txt.Visible = true;
                this.panel_BSProfile.Controls.Add(txt);
            }

            //the second row of beam textBoxs
            for (int i = n / 2; i < n; i++)
            {
                var txt = new TextBox();
                tbs[i] = txt;
                txt.Name = "Beam" + i;
                txt.Text = "Beam" + i;
                txt.Location = new Point(X + ((i - n / 2) * 250) - 100 + (i - n / 2) * 10, Y + 340);
                txt.Size = new System.Drawing.Size(250, 327);
                txt.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top)
                                | System.Windows.Forms.AnchorStyles.Left))));
                txt.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
                txt.Font = new System.Drawing.Font("Courier New", 8.25F);
                txt.Multiline = true;
                txt.Visible = true;
                this.panel_BSProfile.Controls.Add(txt);
            }

            for (int i = 0; i < n; i++)
            {
                tbs[i].Text = BackScatter.GetBsProfileString(i, BackScatter.Ensemble);
            }
            #endregion
        }
        #endregion

        #endregion

        bool bAmp = true; 
        private void panel_contour_Paint(object sender, PaintEventArgs e)
        {
            panel_contour.Width = this.Width;
            panel_contour.Height = this.Height - 50;

            hScrollBar_BS.Location = new Point(panel_contour.Location.X, panel_contour.Bottom + 2);
            hScrollBar_BS.Width = panel_contour.DisplayRectangle.Width * 2 / 3;

            if (ensembles.Count > 0 && iCheckedBeam.Count() > 0)
            {
                int icheckedBeam = iCheckedBeam.Count();
                int icount = 0;
                for (int i = 0; i < BackScatter.MaxBSbeams; i++)
                {
                    bool bchecked = false;
                    for (int j = 0; j < icheckedBeam; j++) //判断该beam是否选中
                    {
                        if (i == iCheckedBeam[j])
                            bchecked = true;
                    }

                    if (!bchecked) //如该beam没有被选中，则不绘制
                        continue;

                    List<float[]> fData = new List<float[]>();
                    //float fMinData = 0;
                    //float fMaxData = 0;
                    float fMinData = trackBarMaxV_BS.Minimum;
                    float fMaxData = (float)trackBarMaxV_BS.Value; //color scale knob

                    string _systemfreq = "";

                    int istartEns = 0;
                    //int iendEns = ensembles.Count();
                    int iendEns = iEndEnsemble;
                    bool bDraw = false;
                    bool bDrawTitle = true;

                    string strVertical = "Depth (m)";
                    string strTitle = "Title";
                    string strUnit = "dB";

                    float fMinDistance = 0;
                    float fMaxDistance = 50;

                    //for (int k = 0; k < ensembles.Count(); k++)
                    for (int k = 0; k < iendEns; k++) //for scroll bar
                    {
                        BackScatter.EnsembleClass m = ensembles[k];

                        float[] data = new float[m.BS_Bins[i]];
                        int t = 0;

                        float depth = m.BS_FirstBin[i];

                        for (int bin = 0; bin < m.BS_Bins[i]; bin++)
                        {
                            if (bAmp)  //Amplitude
                            {
                                data[t++] = m.BS_Amplitude[i, bin];
                                if (fMinData > m.BS_Amplitude[i, bin])
                                    fMinData = m.BS_Amplitude[i, bin];

                                if (fMaxData < m.BS_Amplitude[i, bin])
                                    fMaxData = m.BS_Amplitude[i, bin];

                                strTitle = "Amp Beam" + i.ToString();
                            }
                            else    //BackScatter
                            {
                                data[t++] = m.BS_BackScatter[i, bin];
                                if (fMinData > m.BS_BackScatter[i, bin])
                                    fMinData = m.BS_BackScatter[i, bin];

                                if (fMaxData < m.BS_BackScatter[i, bin])
                                    fMaxData = m.BS_BackScatter[i, bin];

                                strTitle = "BackScatter Beam" + i.ToString();
                            }

                            depth += m.BS_BinSize[i];
                        }

                        fMaxDistance = depth;
                        _systemfreq = m.BS_Frequency[i].ToString();

                        fData.Add(data);
                    }

                    CDrawDisplay drawDisplay = new CDrawDisplay();

                    Rectangle rect = new Rectangle();

                    rect.X = 0;
                    rect.Y = panel_contour.DisplayRectangle.Y + panel_contour.DisplayRectangle.Height / icheckedBeam * icount - 1; //icheckedBeam * icount - 1;
                    rect.Width = panel_contour.DisplayRectangle.Width * 2 / 3;
                    rect.Height = panel_contour.DisplayRectangle.Height / icheckedBeam;

                    if (icount == icheckedBeam - 1) //判断是否为最后一组图形
                        bDraw = true;

                    drawDisplay.OnDrawContour_BS(rect, e, _systemfreq, strTitle, strUnit, fData, fMinDistance, fMaxDistance, fMinData, fMaxData, strVertical, istartEns, iendEns, bDraw, bDrawTitle); //LPJ 2019-8-7

                    icount++;
                }

                //backscatter
                #region backscatter
                //BackScatter.EnsembleClass mm = BackScatter.Ensemble;
                int _icurrentEns = iCurrentEns;  //ensemble picker
                if (_icurrentEns >= ensembles.Count)   //ensemble picker
                    _icurrentEns = ensembles.Count - 1;   //ensemble picker
                if (_icurrentEns < 0)   //ensemble picker
                    _icurrentEns = 0;    //ensemble picker
                BackScatter.EnsembleClass mm = ensembles[_icurrentEns];   //ensemble picker

                icount = 0;
                for (int k = 0; k < BackScatter.MaxBSbeams; k++)
                {
                    List<float[]> fData = new List<float[]>();

                    //float fMinData = 0;
                    //float fMaxData = 0;
                    float fMinData = trackBarMaxV_BS.Minimum;
                    float fMaxData = trackBarMaxV_BS.Value; //color scale knob

                    float fScreen = 10000;
                    string strTitle = "";
                    string strVertical = "Depth (m)";
                    float fLeftMinDistance = 0;
                    float fLeftMaxDistance = 50;

                    List<float[]> fDataDown = new List<float[]>();

                    float[] data = new float[mm.BS_Bins[k]];
                    int t = 0;

                    float depth = mm.BS_FirstBin[k];
                    fLeftMinDistance = depth;
                    for (int bin = 0; bin < mm.BS_Bins[k]; bin++)
                    {
                        if (bAmp)  //Amplitude
                        {
                            if (bin == 0)
                                fMinData = mm.BS_Amplitude[k, bin];

                            data[t++] = mm.BS_Amplitude[k, bin];
                            if (fMinData > mm.BS_Amplitude[k, bin])
                                fMinData = mm.BS_Amplitude[k, bin];

                            if (fMaxData < mm.BS_Amplitude[k, bin])
                                fMaxData = mm.BS_Amplitude[k, bin];

                            strTitle = "Amp Beam" + k.ToString();
                        }
                        else    //BackScatter
                        {
                            if (bin == 0)
                                fMinData = mm.BS_BackScatter[k, bin];

                            data[t++] = mm.BS_BackScatter[k, bin];
                            if (fMinData > mm.BS_BackScatter[k, bin])
                                fMinData = mm.BS_BackScatter[k, bin];

                            if (fMaxData < mm.BS_BackScatter[k, bin])
                                fMaxData = mm.BS_BackScatter[k, bin];

                            strTitle = "BackScatter Beam" + k.ToString();
                        }

                        depth += mm.BS_BinSize[k];

                        fData.Add(data);
                    }

                    fLeftMaxDistance = (int)(depth + 0.5);
                    fMinData = (int)(fMinData - 0.5);
                    fMaxData = (int)(fMaxData + 0.5);

                    CDrawDisplay drawDisplay = new CDrawDisplay();

                    Rectangle rect = new Rectangle();
                    rect.X = panel_contour.DisplayRectangle.X + panel_contour.DisplayRectangle.Width * 2 / 3 + 10;
                    rect.Y = panel_contour.DisplayRectangle.Y + panel_contour.DisplayRectangle.Height / icheckedBeam * icount;
                    rect.Width = panel_contour.DisplayRectangle.Width * 1 / 3 - 130;
                    rect.Height = panel_contour.DisplayRectangle.Height / icheckedBeam;

                    //vertical profile
                    drawDisplay.OnDrawVertical(rect, e, fData, strTitle, 4, fLeftMinDistance, fLeftMaxDistance, fLeftMinDistance, fLeftMaxDistance, fScreen, fMaxData, fMinData, strVertical);
                    icount++;
                }
                #endregion

                #region Ensemble picker line
                Pen p = new Pen(Brushes.LightGray, 0.1f);  //LPJ 2020-11-27
                int startY = panel_contour.DisplayRectangle.Y + 20;  //LPJ 2020-11-27
                int endY = panel_contour.DisplayRectangle.Y + 20 + panel_contour.DisplayRectangle.Height - 40;  //LPJ 2020-11-27
                if (bPickCurrentEns)  //LPJ 2020-11-27
                    e.Graphics.DrawLine(p, _currentX, startY, _currentX, endY);  //LPJ 2020-11-27
                #endregion
            }
        }

        private void btn_Amp_Click(object sender, EventArgs e)
        {
            bAmp = true;
            panel_contour.Refresh();
        }

        private void btn_backscatter_Click(object sender, EventArgs e)
        {
            bAmp = false;
            panel_contour.Refresh();
        }


        //BackScatter Ensemble. -RMa 12/01/2020
        private byte[] EnsBuf = new byte[1000000];
        private void checkBox_beam_CheckedChanged(object sender, EventArgs e)
        {
            getCheckednumber();
            panel_contour.Refresh();
        }

        List<int> iCheckedBeam = new List<int>();
        private void getCheckednumber() 
        {
            iCheckedBeam.Clear();
            if (checkBox_b0.Checked)
                iCheckedBeam.Add(0);
            if (checkBox_b1.Checked)
                iCheckedBeam.Add(1);
            if (checkBox_b2.Checked) 
                iCheckedBeam.Add(2);
            if (checkBox_b3.Checked)
                iCheckedBeam.Add(3);
            if (checkBox_b4.Checked)
                iCheckedBeam.Add(4);

            if (checkBox_b5.Checked)
                iCheckedBeam.Add(5);
            if (checkBox_b6.Checked)
                iCheckedBeam.Add(6);
            if (checkBox_b7.Checked)
                iCheckedBeam.Add(7);
            if (checkBox_b8.Checked)
                iCheckedBeam.Add(8);
            if (checkBox_b9.Checked)
                iCheckedBeam.Add(9);
        }

        static int n = 10; //10 beams
        TextBox[] tbs = new TextBox[n]; //10 beam profile textboxes
        void DecodeBackScatterEnsemble(int beam, BackScatter.EnsembleClass E)
        {
            BackScatter.DecodeEnsemble(EnsBuf, E);

            textBoxBSsystem.BringToFront();
            textBoxBSsystem.Text = BackScatter.GetSystemString(E);
            textBoxBSdata.Text = BackScatter.GetBsString(E);
            textBoxBSleaders.Text = BackScatter.GetHeaderString(E) + BackScatter.GetHeaderDataTypesString();
            //textBoxBSprofile.Text = BackScatter.GetBsProfileString(beam, E);
            textBox_EnsNum.Text = E.System_EnsembleNumber.ToString();
        }

        int iStartEnsemble = 0;    
        int iEndEnsemble = 1;    


        #region ensemble picker. -RMa 12/01/2020
        bool bPickCurrentEns = false;  
        int iCurrentEns = 0;   
        int _currentX;    
        bool bpick = false;
        private void btnPick_Click(object sender, EventArgs e)
        {
            bPickCurrentEns = !bPickCurrentEns;

            if (bPickCurrentEns)
            {
                btnPick.BackColor = Color.LightBlue;
            }
            else
            {
                btnPick.BackColor = Color.LightGray;
            }

            panel_contour.Refresh();
        }

        private void panel_contour_MouseUp(object sender, MouseEventArgs e)
        {
            if (bPickCurrentEns && bpick)
            {
                if (e.X >= panel_contour.DisplayRectangle.X + 60 && e.X <= panel_contour.DisplayRectangle.X + 60 + panel_contour.DisplayRectangle.Width - 110)
                {
                    _currentX = e.X;
                    iCurrentEns = OnTransferMap2Number(panel_contour.DisplayRectangle.X + 60, panel_contour.DisplayRectangle.X + 60 + panel_contour.DisplayRectangle.Width - 110, _currentX, iStartEnsemble, iEndEnsemble + 1);
                }

                bpick = false;
                panel_contour.Refresh();
            }
        }

        private void panel_contour_MouseMove(object sender, MouseEventArgs e)
        {
            if (bPickCurrentEns && bpick)
            {
                if (e.X >= panel_contour.DisplayRectangle.X + 60 && e.X <= panel_contour.DisplayRectangle.X + 60 + panel_contour.DisplayRectangle.Width - 110
                          && e.Y >= panel_contour.DisplayRectangle.Y + 15 && e.Y <= panel_contour.DisplayRectangle.Y + 15 + panel_contour.DisplayRectangle.Height - 30)
                {
                    _currentX = e.X;
                }
            }
        }

        private void panel_contour_MouseDown(object sender, MouseEventArgs e)
        {
            if (bPickCurrentEns)
            {
                bpick = true;
                _currentX = e.X;
            }
        }

        int OnTransferMap2Number(int iStart, int iEnd, int iCurrent, int iStartNo, int iEndNo)
        {
            int iCurrentNo = 0;
            iCurrentNo = iStartNo + (int)((iEndNo - iStartNo) * (iCurrent - iStart) * 1.0 / (iEnd - iStart));

            return iCurrentNo;
        }

        #endregion


        //scroll bar. -RMa 12/01/2020
        private void hScrollBar_BS_Scroll(object sender, ScrollEventArgs e)
        {
            if (ensembles.Count() > 0)
            {
                iEndEnsemble = iStartEnsemble + hScrollBar_BS.Value;
                if (iEndEnsemble == 0) iEndEnsemble = 1;
                //textBox_hScrollBarV.Text = hScrollBarPlayback.Value.ToString();
                textBox_EnsN.Text = iEndEnsemble.ToString();
                BackScatter.EnsembleClass m1 = ensembles[iEndEnsemble - 1];
                label_DateTime.Text = m1.System_Year.ToString("D4") + "/" + m1.System_Month.ToString("D2") + "/" + m1.System_Day.ToString("D2") + ",";
                label_DateTime.Text += m1.System_Hour.ToString("D2") + ":" + m1.System_Minute.ToString("D2") + ":" + m1.System_Second.ToString("D2") + "." + m1.System_Hsec.ToString("D2");

                panel_contour.Refresh();
            }
        }



        #region BS color scale knob. -RMa 12/01/2020
        private void InfoPanel_BS_Paint(object sender, PaintEventArgs e)
        {
            BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
            BufferedGraphics MainBuffer = currentContext.Allocate(e.Graphics, InfoPanel_BS.DisplayRectangle);
            using (Graphics g = MainBuffer.Graphics)
            {
                g.FillRectangle(Brushes.White, InfoPanel_BS.DisplayRectangle); 

                //if (true == SixColor.Checked)
                {
                    for (int c = 0; c <= 1275; c++)
                    {
                        //   float x = 470f * ((float)num / 1275) + 16;
                        float x = InfoPanel_BS.Width * ((float)c / 1275); //Horizontal
                        //float x = InfoPanel_BS.DisplayRectangle.X; //Vertical
                        //float y = InfoPanel_BS.DisplayRectangle.Y + InfoPanel_BS.Height  * (1 - (float)c / 1275); //Vertical
                        Color cl;
                        if (c <= 127)
                            cl = Color.FromArgb(0, 0, 127 + c);//(0,0,127)-(0,0,255)深蓝色->蓝色
                        else if (c <= 382)
                            cl = Color.FromArgb(0, c - 127, 255);//(0,0,255)-(0,255,255)蓝色->青色
                        else if (c <= 637)
                            cl = Color.FromArgb(0, 255, 637 - c);//(0,255,255)-(0,255,0)青色->绿色
                        else if (c <= 892)
                            cl = Color.FromArgb(c - 637, 255, 0);//(0,255,0)-(255,255,0)绿色->黄色
                        else if (c <= 1147)
                            cl = Color.FromArgb(255, 1147 - c, 0);//(255,255,0)-(255,0,0)黄色->红色
                        else if (c <= 1275)
                            cl = Color.FromArgb(1403 - c, 0, 0);//(255,0,0)-(127,0,0)红色->深红色
                        else
                            //cl = Color.FromArgb(245, 245, 245);//white snow
                            //cl = Color.FromArgb(211, 211, 211);//light gray
                            cl = Color.FromArgb(248, 248, 255);//Gainsboro
                        using (Pen p = new Pen(cl))
                        {
                            //  p.Width = 470f / 1275;
                            p.Width = InfoPanel_BS.Width / 1275;
                            g.DrawLine(p, x, 0, x, 16); //Horizontal
                            //g.DrawLine(p, x, y, x + InfoPanel.Width, y); //Vertical
                            p.Dispose();
                        }
                    }
                    using (Font font = new Font("Arial", 6))
                    {
                        SizeF size = g.MeasureString((trackBarMaxV_BS.Value / 40f).ToString("0.00"), font);
                        g.DrawString((trackBarMaxV_BS.Minimum).ToString("0.00"), font, Brushes.Black, new PointF(1, 16));
                        g.DrawString(((trackBarMaxV_BS.Value - trackBarMaxV_BS.Minimum) / 2f).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel_BS.Width / 2f - size.Width / 2, 16));
                        g.DrawString((trackBarMaxV_BS.Value / 1f).ToString("0.00"), font, Brushes.Black, new PointF(InfoPanel_BS.Width - size.Width - 1, 16));
                    }

                    //
                    Font font2 = new System.Drawing.Font("Arial Narrow", 7, FontStyle.Bold);//Font2
                    Font font3 = new System.Drawing.Font("Arial Narrow", 7);//Font3

                    Rectangle rect = new Rectangle(DisplayRectangle.X + 60, DisplayRectangle.Y + 2, DisplayRectangle.Width - 110, DisplayRectangle.Height - 17);
                }

                g.DrawRectangle(Pens.Black, 0, 0, InfoPanel_BS.Width, 16);

                MainBuffer.Render(e.Graphics);
                g.Dispose();
                MainBuffer.Dispose();
            }
        }

        private void trackBarMaxV_BS_Scroll(object sender, EventArgs e)
        {
            labelMavV_BS.Text = (float)trackBarMaxV_BS.Value + " dB";

            panel_contour.Refresh();
            InfoPanel_BS.Refresh();
        }

        private void numericUpDown_Min_ValueChanged(object sender, EventArgs e)
        {
            trackBarMaxV_BS.Minimum = Convert.ToInt32(numericUpDown_Min.Value);
            panel_contour.Refresh();
            InfoPanel_BS.Refresh();
        }

        private void numericUpDown_Max_ValueChanged(object sender, EventArgs e)
        {
            trackBarMaxV_BS.Maximum = Convert.ToInt32(numericUpDown_Max.Value);
            labelMavV_BS.Text = (float)trackBarMaxV_BS.Maximum + " dB";
            panel_contour.Refresh();
            InfoPanel_BS.Refresh();
        }
        #endregion
    }
}


//Steve email 2011-8-23, 
//There is an error in the  Earth transformation documentation. The corrected documentation is shown below:
//East  = X * (SH * CP) - Y * (CH * CR + SH * SR * SP) + Z * (CH * SR - SH * CR * SP); 
//North = X * (CH * CP) + Y * (SH * CR - CH * SR * SP) - Z * (SH * SR + CH * SP * CR); 
//Up    = X * (SP)      + Y * (SR * CP)                + Z * (CP * CR); 
//Q     = (BmVel[0] + BmVel[1] - BmVel[2] - BmVel[3])/(4)

//Modified 2011-11-11 DLL for Latitude Longitude screen position
//Point_XY MouseLatLong(Point MousePosition,  Point UperLeftOfDisplayRectangle,  Point LowerRightOfDisplayRectagle,  
//  double leftLatitudeOfDisplayArea,  double rightLatitudeOfDisplayArea,  double topLongitudeOfDisplayArea,  
//  double bottomLongitudeOfDisplayArea );
//Point CurrentScreenPosition(double currentLatitude,  double currentLongitude,  Point UperLeftOfDisplayRectangle,  
//    Point LowerRightOfDisplayRectagle,  double leftLongitudeOfDisplayArea,  double rightLongitudeOfDisplayArea,  
//    double topLatitudeOfDisplayArea,  double bottomLatitudeOfDisplayArea );